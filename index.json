[{"authors":null,"categories":null,"content":"","date":1612051200,"expirydate":-62135596800,"kind":"term","lang":"zh","lastmod":1612051200,"objectID":"7e67303e3d29a2216e9a2e04059938a0","permalink":"https://CoMath21.github.io/authors/comath/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/comath/","section":"authors","summary":"","tags":null,"title":"CoMath","type":"authors"},{"authors":null,"categories":null,"content":"关于我 96后，2019级计算数学硕士在读， 一个刚步入计算数学领域的小学生😂；本科专业信息与计算科学，当初作为一个刚刚步入大学生活的小年轻，没有过多的考虑，只想毕业工作挣钱😅. 在荒废了一年的时间后，开始学习计算机编程. C++入门，后自学Java进阶(也快忘的差不多了😖，不过编程的思想还在)，目前能够熟练掌握Matlab和Python(稍差一点). 相比较于编程，对数学的热爱略少一点(数学底子较差)，希望以后能够弥补这一短板. 不会抽烟，跟朋友会小酌一杯，喜欢动电影、动漫；运动细胞比较稀缺，仍不断开发训练中💪.\n为什么写博客 其实在我大三的时候就已经谋生了做个人博客的想法🤔，当时的我还是一心想着毕业之后工作，一直埋头于学程序、敲代码，很多学习笔记也是在那个时候积累的；凭借当初学习的Java、数据库等知识确实做了一个基于SSH框架的个人博客(如果还能重新搭建出原来的环境，我会将这个博客的代码共享出来😎)，想的是可以将学过的编程语言、遇到的各种Bug进行整理留个备份，方便自己随时翻阅；还有一个原因就是想着有这样一个完全由自己搭建的Blog能够得到HR的认可😄.直到后来选择读研就一直放下了，现在再捡起来的目的一是为了不想让当初整理的笔记无处安放，另一个也是为了督促自己能够在学习新知识的同时能把它讲出来，分享出来，这样对自己也是有推动作用的🧐. ","date":1612051200,"expirydate":-62135596800,"kind":"term","lang":"zh","lastmod":1612051200,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://CoMath21.github.io/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"关于我 96后，2019级计算数学硕士在读， 一个刚步入计算数学领域的小学生😂；本科专业信息与计算科学，当初作为一个刚刚步入大学生活的小年轻，没有过多的考虑，只想毕业工作挣钱😅. 在荒废了一年的时间后，开始学习计算机编程. C++入门，后自学Java进阶(也快忘的差不多了😖，不过编程的思想还在)，目前能够熟练掌握Matlab和Python(稍差一点). 相比较于编程，对数学的热爱略少一点(数学底子较差)，希望以后能够弥补这一短板. 不会抽烟，跟朋友会小酌一杯，喜欢动电影、动漫；运动细胞比较稀缺，仍不断开发训练中💪.\n为什么写博客 其实在我大三的时候就已经谋生了做个人博客的想法🤔，当时的我还是一心想着毕业之后工作，一直埋头于学程序、敲代码，很多学习笔记也是在那个时候积累的；凭借当初学习的Java、数据库等知识确实做了一个基于SSH框架的个人博客(如果还能重新搭建出原来的环境，我会将这个博客的代码共享出来😎)，想的是可以将学过的编程语言、遇到的各种Bug进行整理留个备份，方便自己随时翻阅；还有一个原因就是想着有这样一个完全由自己搭建的Blog能够得到HR的认可😄.直到后来选择读研就一直放下了，现在再捡起来的目的一是为了不想让当初整理的笔记无处安放，另一个也是为了督促自己能够在学习新知识的同时能把它讲出来，分享出来，这样对自己也是有推动作用的🧐. ","tags":null,"title":"Xin态好先生","type":"authors"},{"authors":["Xin态好先生","CoMath"],"categories":["学习笔记","编程语言"],"content":"　Python下有许多款不同的 Web 框架. Django是最有代表性的一个. 许多成功的网站和APP都基于Django. 2019年通过慕课网的视频教学整理了由基于Django的网站开发. 整过过程持续了多长时间已经记不清了. 中间很多磕磕碰碰，网上找了很多材料整合成了一个笔记. 本来想着能接着做点东西，但后来还是没捡起来.\n虚拟环境的安装与配置 virtualenv virtualenv是一款轻量级第三方虚拟环境管理工具.\nWindows 安装virtualenv命令：pip install virtualenv\npip安装技巧：python豆瓣源：https://pypi.doubanio.com/simple/\n安装时中间加入豆瓣源即可，如：\npip3 install -i https://pypi.doubanio.com/simple/ selenium\neasy_install -i https://pypi.doubanio.com/simple/ selenium\n创建虚拟环境：\n 正常创建：virtualenv 虚拟环境名称 其他版本：virtualenv -p python版本\\python.exe 虚拟环境名称  进入到虚拟环境的目录下执行activate.bat命令启动虚拟环境\n退出虚拟环境deactivate.bat命令\nLinux 安装virtualenv命令：sudo apt-get install python-virtualenv\n创建虚拟环境：virtualenv 虚拟环境名称（默认是Python2.7版本）\n需要进入到虚拟环境的bin目录下执行source activate启动虚拟环境\n退出虚拟环境命令：deactivate\n创建Python3的虚拟环境：\nvirtualenv -p python3目录 虚拟环境名称\nvirtualenv -p /usr/bin/python3 py3test\nvirtualenvwrapper virtualenv使用过于麻烦，所以便于管理，使用virtualenvwrapper（依赖virtualenv）\nWindows 安装：\n​\tpip install virtualenvwrapper-win\n命令：\n workon：查看所有虚拟环境； workon XXX：启动名为XXX的虚拟工作环境； mkvirtualenv XXX ：创建名为XXX的虚拟环境；（目录在C:\\Users\\Wise_Hai\\Envs） mkvirtualenv \u0026ndash;python=python版本目录\\python.exe XXX：创建名为XXX的python版本的虚拟环境； deactivate：关闭当前虚拟环境.  配置工作环境（可选）\n 计算机右键属性 》高级系统设置 》环境变量 新建系统变量  变量名：WORKON_HOME 变量值：工作环境地址   保存并退出，重新开启命令行窗口 如果需要，可以找到之前的虚拟环境目录将其中的虚拟环境直接拷贝过来即可.  备注：可在虚拟环境中安装任意包，如果出错可以在这里中找到安装失败的包及相应的版本进行下载安装，在执行之前的安装命令.\nLinux 安装命令：pip install virtualenvwrapper\nLinux不能像Windows一样直接调用mkvirtualenv，因为没有配置.\n 创建目录来存放虚拟环境   mkdir $HOME/.virtualenvs  需要通过sudo find / -name virtualenvwrapper.sh在根目录下查找virtualenvwrapper.sh文件的路径 配置文件：vim/sudo gedit ~/.bashrc  export WORKON_HOME=$HOME/ .virtualenvs export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3 #如果是pip3安装的virtualenvwrapper把这条加上 最后一行添加source virtualenvwrapper.sh文件的路径   重新加载：source ~/.bashrc mkvirtualenv XXX ：在~/ .virtualenvs创建名为XXX的虚拟环境 mkvirtualenv \u0026ndash;python=/usr/bin/python3 XXX：创建名为XXX的python版本的虚拟环境；  环境配置及Model设计 环境配置（PyCharm，MySQL，Django1.11）\n​\t此项目主要是在Windows上创建并执行，所以所有环境需改成Windows环境，由于之前安装过Anconda，而虚拟环境需要pip安装virtualenv，所以通过以下方法使得Anconda与Python3.6共存，并且可以切换：\n​\t安装Python3.6（不添加到Path），在Python目录下将python.exe文件更名为python3.exe，并将其添加到Path下即可.测试：cmd中使用python3命令.\n项目初始化   创建虚拟环境（这里随便起的名字）\n  安装Django Rest Framework（基于Django）\n  安装Django Rest Framework：pip install djangorestframework\n  注意：DjangRestFramework没有安装Django，需要手动安装\n  安装Django\npip install -i https://pypi.doubanio.com/simple/ django\n地址：https://www.django-rest-framework.org/\n  安装markdown和django-filter\npip install markdown django-filter\n  Pycharm创建Django项目\n  测试运行\n  更改数据库配置\n将setting.py中的DATABASE内容\nDATABASES = {\r'default': {\r'ENGINE': 'django.db.backends.mysql', # 连接mysql数据库\r'NAME': \u0026quot;mxshop\u0026quot;, # 数据库名称\r'USER': 'root', # 账户\r'PASSWORD': \u0026quot;root\u0026quot;, # 密码\r'HOST': \u0026quot;127.0.0.1\u0026quot;, # 地址\r\u0026quot;OPTIONS\u0026quot;:{\u0026quot;init_command\u0026quot;:\u0026quot;SET default_storage_engine=INNODB;\u0026quot;} # mysql数据库的版本5.6以后\r# 'OPTIONS': { 'init_command': 'SET storage_engine=INNODB;' }\r# 用于第三方登录\r}\r}\r   创建数据库\nMySQL数据库下创建名为mxshop的数据库（此时重新运行醒目会出现数据库连接错误，主要是因为缺少连接数据的mysqlckient或者MySQL-python包）\n  安装mysqlclient数据库\npip install -i https://pypi.doubanio.com/simple/ mysqlclient\n此处可能有坑，如果报错无法安装，https://www.lfd.uci.edu/~gohlke/pythonlibs/#mysqlclient找到对应版本下载，通过pip install xx 安装即可\n如果出现下面问题，可能的问题\n?: (mysql.W002) MySQL Strict Mode is not set for database connection \u0026lsquo;default\u0026rsquo; HINT: MySQL\u0026rsquo;s Strict Mode fixes many data integrity problems in MySQL, such as data truncation upon insertion, by escalating warnings into errors. It is strongly recommended you activate it. See: https://docs.djangoproject.com/en/2.1/ref/databases/#mysql-sql-mode\n# 解决\rDATABASES = { 'default': { 'OPTIONS': { \u0026quot;init_command\u0026quot;: \u0026quot;SET sql_mode='STRICT_TRANS_TABLES'\u0026quot;, } }\r}\r   安装图片处理包\npip install -i https://pypi.doubanio.com/simple/ pillow\n  整理项目结构\n创建Package\n apps：保存所有app extra_apps：存放第三方的包，随着源码包打包而不会安装到虚拟环境中  创建Directory\n media：保存图片等 db_tools：数据库初始化等  为了以后方便将apps和extra_apps映射Sources Root并且加入到setting的搜索目录下\nimport sys\rsys.path.insert(0, BASE_DIR)\rsys.path.insert(0, os.path.join(BASE_DIR, 'apps'))\rsys.path.insert(0, os.path.join(BASE_DIR, 'extra_apps'))\r   app models设计 在Tools的Run manage.py Task下运行startapp xxx创建model\n找到对应model的逻辑，创建相应的model\n注意：此处有坑！！\n与视频不同的地方在于django以及MySQL的版本不同，创建外键的时候需要添加on_delete=models.CASCADE\nusers-用户相关 这里面主要是使用UserProfile覆盖了原Users\n# _*_ encoding:utf-8\rfrom datetime import datetime\rfrom django.db import models\rfrom django.contrib.auth.models import AbstractUser\rclass UserProfile(AbstractUser):\rnick_name = models.CharField(max_length=50, verbose_name=u\u0026quot;昵称\u0026quot;, default=\u0026quot;\u0026quot;)\rbirthday = models.DateField(verbose_name=u\u0026quot;生日\u0026quot;, null=True, blank=True)\rgender = models.CharField(max_length=5, choices=((\u0026quot;male\u0026quot;, u\u0026quot;男\u0026quot;), (\u0026quot;female\u0026quot;, \u0026quot;女\u0026quot;)), default=\u0026quot;female\u0026quot;)\raddress = models.CharField(max_length=100, default=u\u0026quot;\u0026quot;)\rmobile = models.CharField(max_length=11, null=True, blank=True)\rimage = models.ImageField(upload_to=\u0026quot;image/%Y/%m\u0026quot;, default=u\u0026quot;image/default..jpg\u0026quot;, max_length=100)\rclass Meta:\rverbose_name = u\u0026quot;用户信息\u0026quot;\rverbose_name_plural = verbose_name\rdef __unicode__(self):\rreturn self.username\rclass EmailVerifyRecord(models.Model):\rcode = models.CharField(max_length=20, verbose_name=u\u0026quot;验证码\u0026quot;)\remail = models.EmailField(max_length=50, verbose_name=u\u0026quot;邮箱\u0026quot;)\rsend_type = models.CharField(max_length=10, choices=((\u0026quot;register\u0026quot;, u\u0026quot;注册\u0026quot;), (\u0026quot;forget\u0026quot;, u\u0026quot;找回密码\u0026quot;)))\rsend_time = models.DateTimeField(default=datetime.now)\rclass Meta:\rverbose_name = u\u0026quot;邮箱验证码\u0026quot;\rverbose_name_plural = verbose_name\r# def __unicode__(self):\r# return self.username\rclass Banner(models.Model):\rtitle = models.CharField(max_length=100, verbose_name=u\u0026quot;标题\u0026quot;)\rimage = models.ImageField(upload_to=\u0026quot;banner/%Y/%m\u0026quot;, verbose_name=u\u0026quot;轮播图\u0026quot;)\rurl = models.URLField(max_length=200, verbose_name=u\u0026quot;访问地址\u0026quot;)\rindex = models.IntegerField(default=100, verbose_name=u\u0026quot;顺序\u0026quot;)\radd_time = models.DateTimeField(default=datetime.now, verbose_name=u\u0026quot;添加时间\u0026quot;)\rclass Meta:\rverbose_name = u\u0026quot;轮播图\u0026quot;\rverbose_name_plural = verbose_name\r courses-课程相关 # _*_ encoding:utf-8\rfrom django.db import models\rfrom datetime import datetime\rclass Course(models.Model):\rname = models.CharField(max_length=50, verbose_name=u\u0026quot;课程名称\u0026quot;)\rdesc = models.CharField(max_length=50, verbose_name=u\u0026quot;课程描述\u0026quot;)\rdetail = models.TextField(verbose_name=u\u0026quot;课程详情\u0026quot;)\rdegree = models.CharField(max_length=2, choices=((\u0026quot;cj\u0026quot;, \u0026quot;初级\u0026quot;), (\u0026quot;zj\u0026quot;, \u0026quot;中级\u0026quot;), (\u0026quot;gj\u0026quot;, \u0026quot;高级\u0026quot;)))\rlearn_times = models.IntegerField(default=0, verbose_name=u\u0026quot;学习时长（分钟）\u0026quot;)\rstudents = models.IntegerField(default=0, verbose_name=u\u0026quot;学习人数\u0026quot;)\rfav_nums = models.IntegerField(default=0, verbose_name=u\u0026quot;收藏人数\u0026quot;)\rimage = models.ImageField(upload_to=\u0026quot;courses/%Y/%m\u0026quot;, verbose_name=u\u0026quot;封面图\u0026quot;, max_length=100)\rclick_nums = models.IntegerField(default=0, verbose_name=u\u0026quot;点击数\u0026quot;)\radd_time = models.DateTimeField(default=datetime.now, verbose_name=u\u0026quot;添加时间\u0026quot;)\rclass Meta:\rverbose_name = u\u0026quot;课程\u0026quot;\rverbose_name_plural = verbose_name\rclass Lesson(models.Model):\rcourse = models.ForeignKey(Course, verbose_name=u\u0026quot;课程\u0026quot;, on_delete=models.CASCADE)\rname = models.CharField(max_length=100, verbose_name=u\u0026quot;章节名称\u0026quot;)\radd_time = models.DateTimeField(default=datetime.now, verbose_name=u\u0026quot;添加时间\u0026quot;)\rclass Meta:\rverbose_name = u\u0026quot;章节\u0026quot;\rverbose_name_plural = verbose_name\rclass Video(models.Model):\rlesson = models.ForeignKey(Lesson, verbose_name=u\u0026quot;课程\u0026quot;, on_delete=models.CASCADE)\rname = models.CharField(max_length=100, verbose_name=u\u0026quot;视频名称\u0026quot;)\radd_time = models.DateTimeField(default=datetime.now, verbose_name=u\u0026quot;添加时间\u0026quot;)\rclass Meta:\rverbose_name = u\u0026quot;视频\u0026quot;\rverbose_name_plural = verbose_name\rclass CourseResource(models.Model):\rcourse = models.ForeignKey(Course, verbose_name=u\u0026quot;课程\u0026quot;, on_delete=models.CASCADE)\rname = models.CharField(max_length=100, verbose_name=u\u0026quot;名称\u0026quot;)\rdownload = models.FileField(upload_to=\u0026quot;course/resource/%Y/%m\u0026quot;, verbose_name=u\u0026quot;资源文件\u0026quot;, max_length=100)\radd_time = models.DateTimeField(default=datetime.now, verbose_name=u\u0026quot;添加时间\u0026quot;)\rclass Meta:\rverbose_name = u\u0026quot;课程资源\u0026quot;\rverbose_name_plural = verbose_name\r organization-机构相关 # _*_ encoding:utf-8\rfrom django.db import models\rfrom datetime import datetime\rclass CityDic(models.Model):\rname = models.CharField(max_length=20, verbose_name=u\u0026quot;城市\u0026quot;)\rdesc = models.CharField(max_length=200, verbose_name=u\u0026quot;描述\u0026quot;)\radd_time = models.DateTimeField(default=datetime.now, verbose_name=u\u0026quot;添加时间\u0026quot;)\rclass Meta:\rverbose_name = u\u0026quot;城市\u0026quot;\rverbose_name_plural = verbose_name\rclass CourseOrg(models.Model):\rname = models.CharField(max_length=50, verbose_name=u\u0026quot;机构名称\u0026quot;)\rdesc = models.CharField(max_length=50, verbose_name=u\u0026quot;机构描述\u0026quot;)\rfav_nums = models.IntegerField(default=0, verbose_name=u\u0026quot;收藏人数\u0026quot;)\rclick_nums = models.IntegerField(default=0, verbose_name=u\u0026quot;点击数\u0026quot;)\rimage = models.ImageField(upload_to=\u0026quot;courses/%Y/%m\u0026quot;, verbose_name=u\u0026quot;封面图\u0026quot;, max_length=100)\raddress = models.CharField(max_length=150, verbose_name=u\u0026quot;机构地址\u0026quot;)\rcity = models.ForeignKey(CityDic, on_delete=models.CASCADE, verbose_name=u\u0026quot;所在城市\u0026quot;)\radd_time = models.DateTimeField(default=datetime.now, verbose_name=u\u0026quot;添加时间\u0026quot;)\rclass Meta:\rverbose_name = u\u0026quot;课程机构\u0026quot;\rverbose_name_plural = verbose_name\rclass Teacher(models.Model):\rorg = models.ForeignKey(CourseOrg, on_delete=models.CASCADE, verbose_name=u\u0026quot;所属机构\u0026quot;)\rname = models.CharField(max_length=50, verbose_name=u\u0026quot;教师名\u0026quot;)\rwork_years = models.IntegerField(default=0, verbose_name=u\u0026quot;工作年限\u0026quot;)\rwork_company = models.CharField(max_length=50, verbose_name=u\u0026quot;就职公司\u0026quot;)\rwork_position = models.CharField(max_length=50, verbose_name=u\u0026quot;公司职位\u0026quot;)\rpoints = models.CharField(max_length=50, verbose_name=u\u0026quot;教学特点\u0026quot;)\rfav_nums = models.IntegerField(default=0, verbose_name=u\u0026quot;收藏人数\u0026quot;)\rclick_nums = models.IntegerField(default=0, verbose_name=u\u0026quot;点击数\u0026quot;)\rclass Meta:\rverbose_name = u\u0026quot;教师\u0026quot;\rverbose_name_plural = verbose_name\r operation-操作相关 # _*_ encoding:utf-8\rfrom django.db import models\rfrom datetime import datetime\rfrom users.models import UserProfile\rfrom courses.models import Course\rclass UserAsk(models.Model):\rname = models.CharField(max_length=20, verbose_name=u\u0026quot;姓名\u0026quot;)\rmobile = models.CharField(max_length=11, verbose_name=u\u0026quot;手机\u0026quot;)\rcourse_name = models.CharField(max_length=50, verbose_name=u\u0026quot;课程名\u0026quot;)\radd_time = models.DateTimeField(default=datetime.now, verbose_name=u\u0026quot;添加时间\u0026quot;)\rclass Meta:\rverbose_name = u\u0026quot;用户咨询\u0026quot;\rverbose_name_plural = verbose_name\rclass CourseComments(models.Model):\r\u0026quot;课程评论\u0026quot;\ruser = models.ForeignKey(UserProfile, on_delete=models.CASCADE, verbose_name=u\u0026quot;用户\u0026quot;)\rcourse = models.ForeignKey(Course, on_delete=models.CASCADE, verbose_name=u\u0026quot;课程\u0026quot;)\rcomments = models.CharField(max_length=200, verbose_name=u\u0026quot;评论\u0026quot;)\radd_time = models.DateTimeField(default=datetime.now, verbose_name=u\u0026quot;添加时间\u0026quot;)\rclass Meta:\rverbose_name = u\u0026quot;课程评论\u0026quot;\rverbose_name_plural = verbose_name\rclass UserFavorite(models.Model):\ruser = models.ForeignKey(UserProfile, on_delete=models.CASCADE, verbose_name=u\u0026quot;用户\u0026quot;)\rfav_id = models.IntegerField(default=0, verbose_name=u\u0026quot;数据id\u0026quot;)\rfav_type = models.IntegerField(choices=((1, \u0026quot;课程\u0026quot;), (2, \u0026quot;课程机构\u0026quot;), (3, \u0026quot;讲师\u0026quot;)))\radd_time = models.DateTimeField(default=datetime.now, verbose_name=u\u0026quot;添加时间\u0026quot;)\rclass Meta:\rverbose_name = u\u0026quot;用户收藏\u0026quot;\rverbose_name_plural = verbose_name\rclass UserMessage(models.Model):\ruser = models.IntegerField(default=0, verbose_name=u\u0026quot;接收用户\u0026quot;)\rmessage = models.CharField(max_length=500, verbose_name=u\u0026quot;消息内容\u0026quot;)\rhas_read = models.BooleanField(default=False, verbose_name=u\u0026quot;是否已读\u0026quot;)\radd_time = models.DateTimeField(default=datetime.now, verbose_name=u\u0026quot;添加时间\u0026quot;)\rclass Meta:\rverbose_name = u\u0026quot;用户消息\u0026quot;\rverbose_name_plural = verbose_name\rclass UserCourse(models.Model):\ruser = models.ForeignKey(UserProfile, on_delete=models.CASCADE, verbose_name=u\u0026quot;用户\u0026quot;)\rcourse = models.ForeignKey(Course, on_delete=models.CASCADE, verbose_name=u\u0026quot;课程\u0026quot;)\radd_time = models.DateTimeField(default=datetime.now, verbose_name=u\u0026quot;添加时间\u0026quot;)\rclass Meta:\rverbose_name = u\u0026quot;用户课程\u0026quot;\rverbose_name_plural = verbose_name\r 考虑到存在很多models的情况，创建名为apps的Python Package，存储所有的models，并且将所有apps映射成Sources Root（否则，各个model中调用的包将报错）\n并且，在settings.py中设置\nimport os\rimport sys\rBASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\rsys.path.insert(0, os.path.join(BASE_DIR, 'apps'))\r 文件上传操作 设置字段的时候存在上传文件路径，所以需要配置文件上传的目录\nimage = models.ImageField(upload_to=\u0026quot;courses/%Y/%m\u0026quot;)\r 项目根目录下创建名为miedia的Directory，然后在settings.py中添加\nMEDIA_URL = '/media/'\rMEDIA_ROOT = os.path.join(BASE_DIR, 'media')\r 文件上传访问 配置文件上传访问处理函数\nfrom django.views.static import serve\rfrom mxonline.settings import MEDIA_ROOT\r# 配置文件上传的访问处理函数\rurl(r'^media/(?P\u0026lt;path\u0026gt;.*)$', serve, {\u0026quot;document_root\u0026quot;: MEDIA_ROOT}),\r 配置上下文处理器（在settings.py中找到TEMPLATES下的'context_processors' 添加'django.template.context_processors.media',),其目的是将{{ MEDIA_URL }}注册到url中\nTEMPLATES = [\r{\r'OPTIONS': {\r'context_processors': [\r'django.template.context_processors.media',\r],\r},\r},\r]\r 在对应位置即可访问上传的图片\n\u0026lt;img width=\u0026quot;200\u0026quot; height=\u0026quot;120\u0026quot; class=\u0026quot;scrollLoading\u0026quot; data-url=\u0026quot;{{ MEDIA_URL }}{{ xxx.image }}\u0026quot;/\u0026gt;\r 后台管理系统 admin 创建Django之后就会自动生成再带的后台管理系统（注意：红色框框）\n在PyCharm的新版本中创建Django文件的时候，不要勾掉最后的Enable Django admin\n通过http://127.0.0.1:8000/admin进行访问，但是Django并不默认生成登录账号及密码，需要通过createsuperuser注册admin后台管理的账号和密码\n修改成中文显示：在settings.py中设置\nLANGUAGE_CODE = 'zh-hans'\rTIME_ZONE = 'Asia/Shanghai'\rUSE_I18N = True\rUSE_L10N = True\rUSE_TZ = False\r 默认显示的只有Group，如果想显示其他model，需要在对应的model目录下的admin中创建对应的class即可\nform django.contrib import admin form .model import UserProfile\rclass UserProfileAdmin(admin.ModelAdmin): # 添加一个管理器\rpass\radmin.site.register(UserProfile, UserProfileAdmin)\t# 关联注册\r url配置技巧 urlpatterns = [\r# url(R'^admin/', admin.site.urls)\rurl(r'^form/$', getform, name='go_form')\r]\r 解释为：以^后的名字开头，以/$结尾，转到getform的views下，在html的form表单中，可以通过配置action=\u0026quot;{% url \u0026lsquo;go_form\u0026rsquo; %}\u0026ldquo;提交表单.\nxadmin 命令安装   安装\n在对应的虚拟环境中通过pip install xadmin进行安装.（依赖的安装包也会被安装）\n  环境配置\n在项目setting.py中，找到INSTALLED_APPS，在下面添加\u0026rsquo;xadmin\u0026rsquo;以及\u0026rsquo;crispy_forms'，在urls.py中，引入xadmin包，并经命令中的admin改成xadmin.\nimport xadmin\rurlpatterns = [\rurl(r'^xadmin/', xadmin.site.urls),\r]\r   生成管理表单\n配置之后，xadmin需要自己的管理表单，所以重新创建表单makemigrations，migrate\n  源码安装(推荐使用)   GitHub下载\n  安装\n解压下载的xadmin-master.zip文件，找到其中的xadmin文件夹并将其拷贝到项目文件的根目录下，为了能够更好的管理，也为了model能够直接访问到xadmin，创建一个package包（例如：extra_apps），并将其映射成Sources Root，将xadmin文件夹拖到改文件夹下即可.\n注意：此时可以卸载命令行安装的xadmin包，但是不要卸载自动下载的依赖包.除此之外，还需要在setting.py下注册extra_apps.\nsys.path.insert(0, os.path.join(BASE_DIR, 'extra_apps'))\r 依赖包：\n此处有坑：（Django版本在2.0以上有坑）\n  首先报错：“ from future.utils import iteritems ImportError: No module named future.utils”\n  原因是缺少future包\n  解决方法：\n pip install future    然后报错：from django.urls import NoReverseMatch, reverse\n  原因是django2.0 把原来的 django.core.urlresolvers 包 更改为了 django.urls包\n  解决方法：\n 将django.core.urlresolvers 改为 django.urls    有坑！！！！\n  有坑！！！！\n  有坑！！！！\n  参照https://www.cnblogs.com/netalen/p/10987016.html更改\n  还有坑：需要将生成xadmin管理表，即执行makemigrations xadmin以及migrate xadmin.\n  环境配置\n将model注册到xadmin：\n在相应的model创建adminx.py文件，并且\nimport xadmin\rfrom .models import modelClassName\rclass modelClassNameAdmin(object):\rlist_display = ['字段1', '字段2', ...]/('',)\t# 显示xadmin列表题头(最好选择数组类型)\rsearch_fields = ['字段1', '字段2', ...]/('',)\t#搜索功能\tlistr_filter = ['字段1', '字段2', ...]/('',)\t# 过滤器功能\rxadmin.site.register(modelClassName, modelClassNameAdmin)\r 如果存在外键，在添加过滤器功能的时候需要制定通过哪个字段，如：\u0026lsquo;User__name\u0026rsquo;\n这里要注意的是，添加一条数据之后需要添加以下代码，才能显示想要的数据\ndef __unicode__(self):\rreturn self.name\r# 或者\rdef __str__(self):\rreturn self.name\r   xadmin源码安装优势\n可以享用xadmin的新特性，并且可以根据需求添加插件等.\n  xadmin全局修改\n  设置主题：\n在adminx.py下创建calss\nfrom xadmin import views\rclass BaseSetting(object):\renable_themes = True\ruse_bootswatch = True\rxadmin.site.register(views.BaseAdminView, BaseSetting)    全局变量\nfrom xadmin import views\rclass GlobalSetting(object):\rsite_title = \u0026quot;\u0026quot;\rsite_footer = \u0026quot;\u0026quot;\rmenu_style = \u0026quot;accordion\u0026quot;\t# 折叠菜单\rxadmin.site.register(views.CommAdminView, GlobalSetting)  备注：如果需要对显示菜单名称改成中文咋需要在对应model下找到apps.py进行添加，然后更改当前目录下的__init__.py\napps.py下添加verbose_name = u\u0026quot;Name\u0026quot;\n__init__.py下添加：default_app_config = model.apps.ModelConfig \n注意：如果在setting.py中配置.XxxConfig则不需要上述__init__.py操作.\n    前端 首页 首先准备好前端页面及样式\n在项目下创建名为static的Directory，同于存放所有的静态文件，并将img/images/css/js等文件拷贝到static文件夹下\n然后在urls.py中配置url即可访问\nfrom django.views.generic import TemplateView\rurlpatterns = [\rurl('^$', TemplateView.as_view(template_name=\u0026quot;index.html\u0026quot;), name=\u0026quot;index\u0026quot;)\r]\r 存在问题：静态文件没有加载\n解决方法：\n  settings.py中找到STATIC_URL = '/static/'，在下面添加\nSTATICFILES_DIRS = (\ros.path.join(BASE_DIR, \u0026quot;static\u0026quot;),\r)\r   在对应的html界面中找到对应的样式文件，将相对路径跟改为/static/\u0026hellip;或者引入{% load staticfiles %}然后使用{% static 'css/xx.css' %}\n  登录页面 页面   复制登录页面到template下，并更改样式文件\n  配置url访问路径：\nurl('^login/$', TemplateView.as_view(template_name=\u0026quot;login.html\u0026quot;), name=\u0026quot;login\u0026quot;)\r   找到index.html下的登录入口，a标签更改为href=\u0026quot;/login\u0026quot;或者{% url 'login' %}\n  url使用include 在项目下的urls.py文件中可以通过include导入其他url配置文件（url分解），也是为了更好的管理，不至于项目下的urls.py杂乱无章. 可以在对应的app下创建urls.py文件，然后导入即可.\n# 项目下的urls.py文件\rfrom django.conf.urls import url, include\rurlpatterns = [\r# namespace命名空间\rurl(r'^org/$', include('organization.urls'), namespace=\u0026quot;org\u0026quot;),\r]\r # organization下的urls.py\rfrom django.conf.urls import url, include\rurlpatterns = [\r# ...\rurl(r'^list/$', OrgListView.as_view(), name=\u0026quot;org_list\u0026quot;),\r]\r 访问以org*开头的的url都会到organization.urls中查找，提交变为\n\u0026lt;a href=\u0026quot;{% url 'org:org_list' %}\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\r 访问地址由原来的http://127.0.0.1:8000/org-list变为http://127.0.0.1:8000/org/list\n逻辑 在users下的views.py中添加逻辑\n注意：在view中配置函数逻辑后，就可以替换url下的内容，如：\n在views.py中创建login函数方法\ndef login(request):\rif request.method == \u0026quot;POST\u0026quot;:\rpass\relif request.method == \u0026quot;GET\u0026quot;:\rreturn render(request, \u0026quot;login.html\u0026quot;, {})\r 在urls.py中就可以更改为：\nfrom django.views.generic import TemplateView\rfrom model.views import login\rurlpatterns = [\rurl('^$', login, name=\u0026quot;index\u0026quot;)\r]\r 注意：这里面的login不带()，不是点用函数方法，只是指向了login函数.\n  HTML表单提交\n主要在于action以及method，除此之外，Django自带一种安全机制，防止跨越提交，反复向后台提交表单对服务器造成负担，Django为了防止这种攻击，会做一种CSRF验证（当用post提交数据的时候，Django会去检查是否有一个CSRF的随机字符串，如果没有就会报错），所以需要在form表单里面添加{% csrf_token %}（可以查看页面源码,看到form中有一个input是隐藏的）!\n  接收数据\nviews.py通过request.POST.get(\u0026quot;labelName\u0026quot;,\u0026quot;\u0026quot;)来获取表单中的数据，第一个参数为参数名字，第二个参数为默认值.\n    基于函数的登录操作\nDjango自带的用户认证auth，django.contrib.auth中提供了许多方法，其中：\n  authenticate()\n提供了用户认证，即验证用户名以及密码是否正确，一般需要username password两个关键字参数，如果认证信息有效，会返回一个 User 对象.authenticate()会在User 对象上设置一个属性来标识后端已经认证了该用户，且该信息在后续的登录过程中是需要的。当试图登陆一个从数据库中直接取出来不经过authenticate()的User对象时会报错！\nfrom django.contrib.auth import authenticate\ruser = authenticate(username='username',password='password')\r   User对象\nUser 对象属性：username， password（必填项）password用哈希算法保存到数据库\nis_staff ： 用户是否拥有网站的管理权限.\nis_active ： 是否允许用户登录, 设置为False，可以不用删除用户来禁止 用户登录\n    login(HttpRequest, user)　该函数接受一个HttpRequest对象，以及一个认证了的User对象\n备注：auth.login方法将校验通过的用户封装到request中，这样在request的生命周期我们都可以使用request.user得到这个用户的对象，不管是在视图函数还是在模板语言中都可以使用request.user 然后在 .字段属性 来取到需要的内容。此函数使用django的session框架给某个已认证的用户附加上session id等信息.\nfrom django.contrib.auth import authenticate, login\rdef user_login(request):\rif request.method == \u0026quot;POST\u0026quot;:\rusername = request.POST.get(\u0026quot;username\u0026quot;, \u0026quot;\u0026quot;)\rpassword = request.POST.get(\u0026quot;password\u0026quot;, \u0026quot;\u0026quot;)\ruser = authenticate(username=username, password=password)\rif user is not None:\rlogin(request, user)\rreturn render(request, \u0026quot;index.html\u0026quot;)\relse:\rreturn render(request, \u0026quot;login.html\u0026quot;, {\u0026quot;msg\u0026quot;: \u0026quot;用户名或密码错误\u0026quot;})\relif request.method == \u0026quot;GET\u0026quot;:\rreturn render(request, \u0026quot;login.html\u0026quot;, {})\r 显示错误信息：\n逻辑代码中返回的错误信息可以用{{ }}来显示在页面中\n\u0026lt;div class=\u0026quot;error btns login-form-tips\u0026quot; id=\u0026quot;jsLoginTips\u0026quot;\u0026gt;{{ msg }}\u0026lt;/div\u0026gt;\r   is_authenticated()\n判断是否已经通过了认证，但通过认证并不意味着用户拥有任何权限，这个方法甚至也不检查该用户是否处于激活状态，只是表明用户成功的通过了认证。\n这个方法很重要, 在后台用request.user.is_authenticated()判断用户是否已经登录，如果true则可以向前台展示request.user.name\n备注：前端可以通过{% request.user.is_authenticated() %}进行判断.\n    logout(request) 注销用户　from django.contrib.auth import logout\rdef logout_view(request):\rlogout(request)\r# Redirect to a success page.\r 该函数接受一个HttpRequest对象，无返回值。当调用该函数时，当前请求的session信息会全部清除。该用户即使没有登录，使用该函数也不会报错.\n备注：注销用户后，直接访问这个路径，还可以登录，但是可以print(request.user)，当用户通过校验登录时，得到的是一个具体的用户对象；当注销时，再次访问，就会输出AnonymousUser（是一个类 \u0026lt;class \u0026lsquo;django.utils.functional.SimpleLazyObject\u0026rsquo;\u0026gt;），意为匿名用户，可以通过这个处理一些判断.\n    多账户信息登录\n需要在usersModel下的views.py中创建继承django.contrib.auth.backends import ModelBackends的类，然后定义函数，并将函数注册到settings.py下\nfrom django.contrib.auth.backends import ModelBackends\rfrom django.db.models import Q\rcalss CustomBackend(ModelBackends):\r# 该方法会被django自动调用\rdef authenticate(self, username=None, password=None, **kwargs):\rtry:\r# 根据用户名查找是否存在用户(get()函数只会返回存在一个的数据)\ruser = User.oject.get(username=username)\r# 如果行多个账号形式，需要导入Q包，然后执行：\r# user = User.oject.get(Q(username=username)|Q(email=username)\rif user.check_password(password):\rreturn user\rexcept Exception as e:\rretirn None\r settings.py中配置\nAUTHenTICATION_BACKENDS = (\r'model.views.CustomBackend',\r)\r Q：\na、在 filter() 等函式中关键字参数彼此之间都是 \u0026ldquo;AND\u0026rdquo; 关系。如果你要执行更复杂的查询(比如，实现筛选条件的 OR 关系)，可以使用 Q 对象。 b、Q对象包括 AND 关系 和OR 关系 c、Q 对象可以用 \u0026amp; 和 | 运算符进行连接。当某个操作连接两个 Q 对象时，就会产生一个新的等价的 Q 对象。\n如：下面这段语句就产生了一个 Q ，这是用 \u0026ldquo;OR\u0026rdquo; 关系连接\nQ(question__startswith='Who') | Q(question__startswith='What')\r d、每种查询函式(比如 filter(), exclude(), get()) 除了能接收关键字参数以外，也能以位置参数的形式接受一个或多个 Q 对象。如果你给查询函式传递了多个 Q 对象，那么它们彼此间都是**\u0026ldquo;AND\u0026rdquo; 关系。**例如：\nPoll.objects.get(\rQ(question__startswith='Who'), Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6))\r)\r e: filter() 等函数 可以接受 Q对象和条件参数，但Q对象必须放在 条件参数前面\nsettings.py中配置，重载变量\n  基于类的登录操作\n定义继承django.views.generic.base下View的class类，直接重写get/post方法\nfrom django.views.generic.base import View\rclass LoginView（View）：\rdef get(self, request):\rreturn render(request, \u0026quot;login.heml\u0026quot;, {})\rdef post(self, request):\rusername = request.POST['username']\rpassword = request.POST['password']\ruser = authenticate(username=username, password=password)\rif user is not None:\rlogin(request, user)\r# Redirect to a success page.\r...\relse:\r# Return an 'invalid login' error message.\r...\r 同时urls.py中还要更改为\nfrom model.views import LoginView\rurlpatterns = [\r# 调用LoginView下的as_view()方法\rurl('^login/$', LoginView.as_view(), name=\u0026quot;index\u0026quot;)\r]\r   Django Form 表单\n在实际的生产环境中比如登录和验证的时候，一般都使用Jquery+ajax来判断用户的输入是否为空，假如JS被禁用的话，这个认证屏障是就消失了（虽然一般不会禁用掉但是还是存在风险）\n所以一般做两种认证一种是前端做一遍认证，在后端做一遍认证. 通过Django的form来实现.\n  Django的form的作用： 1). 生成html标签\n2). 用来做用户提交的验证\n  生成\n创建forms.py脚本文件\nfrom django import forms\rclass Loginform(forms.Form):\r# 要求 变量名与form表单提交的字段名一致\remail = forms.EmailField(required=True) #required是否可以为空,如果为False说明可以为空\rusername = forms.CharField() #如果required不写默认为Ture\rpassword = forms.CharField()  views.py中\nfrom .forms import LginForm\r# 创建实例,LoginForm(参数)需要传入字典类型的参数，这里将request.POST传入即可\rlogin_form = LoginForm(request.POST)\r# 就可以通过.is_valid()来判断用户输入是否合法\rif login_form.is_valid():\rpass\r   使用.is_valid()函数之后可以更改返回页面的错误信息，\nreturn render(request, \u0026quot;login.html\u0026quot;, {\u0026quot;login_form\u0026quot;: login_form})\r html页面中获取可以使用\n循环获取错误信息：\n{% for key, error in login_form.errors.items %}{{ error }}{% endfor %}{{ msg }}    Forms.ModelForm ModelForm表单同样需要导入包from django import forms,它可以简化元form表单的生成，即可以直接将Model转换成表单，通过定义Meta类来指定Model，并且使用files指定哪些变量为表单内容\nfrom django import forms\rfrom operation.models import UserAsk\rclass UserAskForm(forms.ModelForm):\r# 这里可以再添加字段\r# temp = forms.CharField()\rclass Meta:\rmodel = UserAsk\rfields = ['name', 'mobile', 'course_name']\r# 如果相对某个字段进行正则判断，可以定义'clean_字段名'的函数\rdef clean_mobile(self):\r# 验证手机号码是否合法\rmobile = self.cleaned_data['mobile']\rREGEX_MOBIE = \u0026quot;^1[358]\\d{9}$|^147\\d{8}$|^176\\\\d{8}$\u0026quot;\rp = re.compile(REGEX_MOBIE)\rif p.match(mobile):\rreturn mobile\relse:\r# 抛出异常\rraise forms.ValidationError(u\u0026quot;手机号码非法\u0026quot;, \u0026quot;mobile_invalid\u0026quot;)\r 实例化过程\nclass AddUserAskView(View):\rdef post(self, request):\ruserask_form = UserAskForm(request.POST)\rif userask_form.valid():\ruser_ask = userask_form.save(commit=True)\r 备注：无需提取表单信息，直接save()即可\n注意：需要指定save()参数commit=TRUE否则无法存入数据库\n注册页面 页面 DJango captcha 验证码插件 下拉找到documentation online\n Installation    Install django-simple-captcha via pip: pip install django-simple-captcha\n  Add captcha to the INSTALLED_APPS in your settings.py\n  Run python manage.py migrate\n  Add an entry to your urls.py:\nurlpatterns += [\rurl(r'^captcha/', include('captcha.urls')),\r]\r     Adding to a Form\nfrom django import forms\rfrom captcha.fields import CaptchaField\rclass CaptchaTestForm(forms.Form):\rmyfield = AnyOtherField()\rcaptcha = CaptchaField()\r 实例化CaptchaTestForm，传给前台在对应位置添加{{ CaptchaTestForm.captcha }}即可.\n  逻辑 from django import forms\rfrom captcha.fields import CaptchaField\rclass RegisterForm(forms.Form):\rmyfield = AnyOtherField() # 与页面一一对应\rcaptcha = CaptchaField()\t# 可以添加参(error_messages={\u0026quot;错误内容\u0026quot;:\u0026quot;将显示的错误信息\u0026quot;})\r 在views.py中创建RegisterView(View)类， 然后再前端验证码label下面添加{{ register_form.captcha }}\nfrom django.contrib.auth.hashers import make_password\rclass RegisterView(View):\rdef get(self, request)\rregister_form = RegisterForm()\t# 实例化注册表单\rreturn render(request, \u0026quot;register.html\u0026quot;, {\u0026quot;register_form\u0026quot;:register_form})\rdef post(self, request):\r# 创建实例register_form(参数)\rregister_form = RegisterForm(request.POST)\r# 就可以通过.is_valid()来判断用户输入是否合法\rif register_form.is_valid():\r# ...\ruser.password = make_password(password)\ruser.save() # 如果发送邮件执行发送邮箱验证代码\rreturn else:\rreturn  创建逻辑即可，值得一提的是存储明码的时候需要存密文，所以需要加密：\nfrom django.contrib.auth.hashers import make_password\ruser.password = make_password(password)\r 发送邮箱验证   注册邮箱账号\n首先注册邮箱账号（以新浪/网易邮箱为例），在常规设置中找到：POP3/SMTP/IMAP\n  配置Email\nsettings.py中添加\n  EMAIL_HOST = \u0026quot;smtp.sina.com\u0026quot;\rEMAIL_PORT= 25\rEMAIL_HOST_USER = \u0026quot;xxx@xxx.com\u0026quot;\rEMAIL_HOST_PASSWORD = \u0026quot;xxxxxx\u0026quot; # 这里的PASSWORD是授权码，而不是普通的邮箱密码\rEMAIL_USE_TLS = False\rEMAIL_FORM = \u0026quot;xxx@xxx.com\u0026quot;\r   函数\nfrom random import Random\rfrom django.core.mail import send_mail\rdef random_str(randomlength=8):\rstr = ''\rchars = 'AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz0123456789'\rlength = len(chars) - 1\rrandom = Random()\rfor i in range(randomlength):\rstr += chars[random.randint(0, length)]\rreturn str\rdef send_register_email(email, send_type=\u0026quot;register\u0026quot;): email_record = EmailVerifyRecord()\rcode = random_str(16)\remail_record.code = code\remail_record.email = email\remail_record.type = send_type\remail_record.save()\remail title=\u0026quot;\u0026quot;\remail body=\u0026quot;\u0026quot;\rif send type==\u0026quot;register\u0026quot;：\remail_title=\u0026quot;在线网注册激活链接”\remail_body=\u0026quot;请点击下面的链接激活你的账号：http://127.0.0.1：8000/active/{0}\u0026quot;.format(code)\r# 返回状态\rsend_status = send_mail(email_title, email_body, EMAIL_FORM, [email])\r# send_status = send_mail(email_title, email_body, 需要导入settings.py, 列表list类型)\t返回状态为0/1\rif send_status:\rpass\relse:\rpass\r   激活操作\n urls.py配置拿到随机码进行匹配  url(r'^active/(?P\u0026lt;Name\u0026gt;.*)/$', ActiveUserView.as_view())\r# 提取active/后面所有的东西存到Name中\r class ActiveUserView(View):\rdef get(self, request, Name)\rall_records = EmaolVerifyRecord.object.filter(code=Name)\rif all_records:\rfor record in all_records:\remail = record.mail\ruser = User.object.get(email=email)\ruser.active = True\ruser.save()\rreturn ...\r 在django中，查询经常用的两个API：get()和filter()两个方法，\n object.get()：得到的是一个对象，如果在数据库中查不到这个对象或者查找到对象都会报错！！！ object.filter() ：返回的是一个对象列表。如果在数据库中找不到这个对象，那么会返回一个空列表[]    找回密码 urls.py中配置链接 url(r'^active/(?P\u0026lt;Name\u0026gt;.*)/$', ForgetPwdView.as_view(), name=\u0026quot;forget_pwd\r\u0026quot;)\r 找到忘记密码的标签，将href='{% url 'forget_pwd' %}'\nclass ForgetPwdView(View):\rdef get(self, request)\rforget_form = ForgetForm()\t# 实例化忘记密码表单\rreturn render(request, \u0026quot;forget.html\u0026quot;,{\u0026quot;forget_form\u0026quot;:forget_form})\rdef post(self, request)\rforget_form = ForgetForm(request.POST)\rif forget_form.is_valid():\r# ...\remail = request.POST.get(\u0026quot;email\u0026quot;)\r# 如果发送邮件执行发送邮箱验证代码\rreturn else:\rreturn  激活操作 urls.py配置拿到随机码进行匹配\nurl(r'^reset/(?P\u0026lt;Name\u0026gt;.*)/$', ResetView.as_view())\r class ResetView(View):\rdef get(self, request, Name)\rall_records = EmaolVerifyRecord.object.filter(code=Name)\rif all_records:\rfor record in all_records:\remail = record.mail\rreturn render(request, \u0026quot;password.html\u0026quot; {\u0026quot;email\u0026quot;:email})\relse: return def post(self, request):\r... class ModifyPwdView(View):\rdef post(self, request):\rmodify_form = ModifyPwdForm(request.POST)\rif modify_form.is_valid():\remail = request.POST.get(\u0026quot;email\u0026quot;, \u0026quot;\u0026quot;)\rpassword1 = request.POST.get(\u0026quot;password1\u0026quot;, \u0026quot;\u0026quot;)\rpassword2 = request.POST.get(\u0026quot;password2\u0026quot;, \u0026quot;\u0026quot;)\rif password1 != password2:\rreturn render(request, \u0026quot;password_reset.html\u0026quot;, {\u0026quot;email\u0026quot;: email, \u0026quot;msg\u0026quot;: \u0026quot;密码不一致\u0026quot;})\rmodify_user = UserProfile.objects.get(email=email)\rmodify_user.password = make_password(password1)\rmodify_user.save()\rreturn render(request, \u0026quot;login.html\u0026quot;)\relse:\rreturn render(request, \u0026quot;login.html\u0026quot;, {\u0026quot;modify_form\u0026quot;: modify_form})\r 机构的功能实现 Django网页模板的继承block   新建母版html文件（在里面挖坑block）\n\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;\r{% block title %}\u0026lt;title\u0026gt;模板页\u0026lt;/title\u0026gt;{% endblock %}\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r{% block custom_bread %}\r\u0026lt;section\u0026gt;\r\u0026lt;div class=\u0026quot;wp\u0026quot;\u0026gt;\r\u0026lt;ul class=\u0026quot;crumbs\u0026quot;\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;{% url 'index' %}\u0026quot;\u0026gt;首页\u0026lt;/a\u0026gt;\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;/ul\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/section\u0026gt;\r{% endblock %}\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r   新建子网页并继承母版extends（在里面填坑）\n{% extends 'base.html' %} # 注意： 继承语句必须放在首行 {% block title %}授课机构列表{% endblock %}\r{% block custom_bread %}\r\u0026lt;section\u0026gt;\r\u0026lt;div class=\u0026quot;wp\u0026quot;\u0026gt;\r\u0026lt;ul class=\u0026quot;crumbs\u0026quot;\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;{% url 'index' %}\u0026quot;\u0026gt;首页\u0026lt;/a\u0026gt;\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;课程机构\u0026lt;/li\u0026gt;\r\u0026lt;/ul\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/section\u0026gt;\r{% endblock %}\r   写路由，只需写子网页的路由即可。（无需写母版页的路由）\nfrom django.shortcuts import render\rfrom django.views.generic import View\rclass OrgListView(View):\rdef get(self, request):\rreturn render(request, \u0026quot;org-list.html\u0026quot;)\r   分页功能 geihub搜索：pure pagination\nInstallation  Install package from PYPI:  pip install django-pure-pagination\r ​\tor clone and install from repository:\ngit clone git@github.com:jamespacileo/django-pure-pagination.git\rcd django-pure-pagination\rpython setup.py install\r Add pure_pagination to INSTALLED_APPS  INSTALLED_APPS = (\r...\r'pure_pagination',\r)\r  Finally substitute from django.core.paginator import Paginator with from pure_pagination import Paginator\n  A few settings can be set within settings.py\n  PAGINATION_SETTINGS = {\r'PAGE_RANGE_DISPLAYED': 10,\r'MARGIN_PAGES_DISPLAYED': 2,\r'SHOW_FIRST_PAGE_WHEN_INVALID': True,\r}\r Usage example Following is a simple example for function based views. For generic class-based views, see bellow.\nview file: views.py\n# views.py\rfrom django.shortcuts import render_to_response\rfrom pure_pagination import Paginator, EmptyPage, PageNotAnInteger\rdef index(request):\rtry:\rpage = request.GET.get('page', 1)\rexcept PageNotAnInteger:\rpage = 1\robjects = ['john', 'edward', 'josh', 'frank']\r# Provide Paginator with the request object for complete querystring generation\r# 需要传递三个参数，中间参数为每页显示数据\rp = Paginator(objects, 5, request=request)\rpeople = p.page(page)\rreturn render_to_response('index.html', {\r'people': people,\r}\r template file: index.html\n{# index.html #}\r{% extends 'base.html' %}\r{% block content %}\r{% for person in people.object_list %}\r\u0026lt;div\u0026gt;\rFirst name: {{ person }}\r\u0026lt;/div\u0026gt;\r{% endfor %}\r{# The following renders the pagination html #}\r\u0026lt;div id=\u0026quot;pagination\u0026quot;\u0026gt;\r{{ people.render }} # 默认页码样式\r\u0026lt;/div\u0026gt;\r{% endblock %}\r 自定义页码样式\nUsage There a few different way you can make use of the features introduced within django-pure-pagination.\nEasiest way to render the pagination is to call the render method i.e. {{ page.render }}\nAlternatively you can access the Page object low level methods yourself\nSpecial note: page_obj and current_page both point to the page object within the template.\n{% load i18n %}\r\u0026lt;div class=\u0026quot;pagination\u0026quot;\u0026gt;\r{% if page_obj.has_previous %}\r\u0026lt;a href=\u0026quot;?{{ page_obj.previous_page_number.querystring }}\u0026quot; class=\u0026quot;prev\u0026quot;\u0026gt;\u0026amp;lsaquo;\u0026amp;lsaquo; {% trans \u0026quot;previous\u0026quot; %}\u0026lt;/a\u0026gt;\r{% else %}\r\u0026lt;span class=\u0026quot;disabled prev\u0026quot;\u0026gt;\u0026amp;lsaquo;\u0026amp;lsaquo; {% trans \u0026quot;previous\u0026quot; %}\u0026lt;/span\u0026gt;\r{% endif %}\r{% for page in page_obj.pages %}\r{% if page %}\r{% ifequal page page_obj.number %}\r\u0026lt;span class=\u0026quot;current page\u0026quot;\u0026gt;{{ page }}\u0026lt;/span\u0026gt;\r{% else %}\r\u0026lt;a href=\u0026quot;?{{ page.querystring }}\u0026quot; class=\u0026quot;page\u0026quot;\u0026gt;{{ page }}\u0026lt;/a\u0026gt;\r{% endifequal %}\r{% else %}\r...\r{% endif %}\r{% endfor %}\r{% if page_obj.has_next %}\r\u0026lt;a href=\u0026quot;?{{ page_obj.next_page_number.querystring }}\u0026quot; class=\u0026quot;next\u0026quot;\u0026gt;{% trans \u0026quot;next\u0026quot; %} \u0026amp;rsaquo;\u0026amp;rsaquo;\u0026lt;/a\u0026gt;\r{% else %}\r\u0026lt;span class=\u0026quot;disabled next\u0026quot;\u0026gt;{% trans \u0026quot;next\u0026quot; %} \u0026amp;rsaquo;\u0026amp;rsaquo;\u0026lt;/span\u0026gt;\r{% endif %}\r\u0026lt;/div\u0026gt;\r mxonline分页设置\n\u0026lt;ul class=\u0026quot;pagelist\u0026quot;\u0026gt;\r{% if all_orgs.has_previous %}\r\u0026lt;li class=\u0026quot;long\u0026quot;\u0026gt;\u0026lt;a href=\u0026quot;?{{all_orgs.previous_page_number.querystring }}\u0026quot;\u0026gt;上一页\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\r{% endif %}\r{% for page in all_orgs.pages %}\r{% if page %}\r{% ifequal page all_orgs.number %}\r\u0026lt;li class=\u0026quot;active\u0026quot;\u0026gt;\u0026lt;a href=\u0026quot;?{{ page.querystring }}\u0026quot;\u0026gt;{{ page }}\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\r{% else %}\r\u0026lt;li\u0026gt;\u0026lt;a class=\u0026quot;page\u0026quot; href=\u0026quot;?{{ page.querystring }}\u0026quot;\u0026gt;{{ page }}\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\r{% endifequal %}\r{% else %}\r\u0026lt;li class=\u0026quot;none\u0026quot;\u0026gt;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;...\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\r{% endif %}\r{% endfor %}\r{% if all_orgs.has_next %}\r\u0026lt;li class=\u0026quot;long\u0026quot;\u0026gt;\u0026lt;a href=\u0026quot;?{{ all_orgs.next_page_number.querystring }}\u0026quot;\u0026gt;下一页\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\r{% endif %}\r\u0026lt;/ul\u0026gt;\r 分类显示及课程排行 前端页面通过a标签向后跳提供参数，如：\n\u0026lt;a href=\u0026quot;?ct=pxjg\u0026amp;city={{ city.id }}\u0026quot;\u0026gt;\r view逻辑获取，并分页显示\nclass OrgListView(View):\rdef get(self, request):\r# 获取所有机构\rall_orgs = CourseOrg.objects.all()\r# 热门机构\r# 注意这里，排序参数前如果有‘-’则代表着降序，没有则默认升序\rhot_orgs = all_orgs.order_by(\u0026quot;-click_nums\u0026quot;)[:5]\rall_citys = CityDic.objects.all()\r# 取出筛选城市\rcity_id = request.GET.get('city', \u0026quot;\u0026quot;)\rif city_id:\rall_orgs = all_orgs.filter(city_id=int(city_id))\r# 类别筛选\rcategory = request.GET.get('ct', \u0026quot;\u0026quot;)\rif category:\rall_orgs = all_orgs.filter(category=category)\rorg_nums = all_orgs.count()\rtry:\rpage = request.GET.get('page', 1)\rexcept PageNotAnInteger:\rpage = 1\rp = Paginator(all_orgs, 5, request=request)\rorgs = p.page(page)\rreturn render(request, \u0026quot;org-list.html\u0026quot;, {\r\u0026quot;all_orgs\u0026quot;: orgs,\r\u0026quot;org_nums\u0026quot;: org_nums,\r\u0026quot;all_citys\u0026quot;: all_citys,\r\u0026quot;city_id\u0026quot;: city_id,\r\u0026quot;category\u0026quot;: category,\r\u0026quot;hot_orgs\u0026quot;: hot_orgs\r})\r 前端以通过\u0026lt;span class=\u0026quot;{% ifequal category \u0026quot;pxjg\u0026quot; %} active2{% endifequal %}\u0026quot;\u0026gt;培训机构\u0026lt;/span\u0026gt;添加样式\n\u0026lt;a href=\u0026quot;?city={{ city.id }}\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;{% ifequal category \u0026quot;\u0026quot; %}active2{% endifequal %}\u0026quot;\u0026gt;全部\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\r\u0026lt;a href=\u0026quot;?ct=pxjg\u0026amp;city={{ city.id }}\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;{% ifequal category \u0026quot;pxjg\u0026quot; %} active2{% endifequal %}\u0026quot;\u0026gt;培训机构\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\r # 课程排行前端\r\u0026lt;div class=\u0026quot;right companyrank layout\u0026quot;\u0026gt;\r\u0026lt;div class=\u0026quot;head\u0026quot;\u0026gt;授课机构排名\u0026lt;/div\u0026gt;\r{% for hot_org in hot_orgs %}\r\u0026lt;dl class=\u0026quot;des\u0026quot;\u0026gt;\r\u0026lt;dt class=\u0026quot;num fl\u0026quot;\u0026gt;{{ forloop.counter }}\u0026lt;/dt\u0026gt;\r\u0026lt;dd\u0026gt;\r\u0026lt;a href=\u0026quot;/company/2/\u0026quot;\u0026gt;\u0026lt;h1\u0026gt;{{ hot_org.name }}\u0026lt;/h1\u0026gt;\u0026lt;/a\u0026gt;\r\u0026lt;p\u0026gt;{{ hot_org.address }}\u0026lt;/p\u0026gt;\r\u0026lt;/dd\u0026gt;\r\u0026lt;/dl\u0026gt;\r{% endfor %}\r\u0026lt;/div\u0026gt;\r 页面内异步提交表单 异步操作需要ajax操作，对指定的表单声明自定义script\n如对网页中的某一表单进行异步操作\n配置url\nurl('^add_ask/$', AddUserAskView.as_view(), name=\u0026quot;add_ask\u0026quot;),\r 表单提交逻辑\nclass AddUserAskView(View):\rdef post(self, request):\ruserask_form = UserAskForm(request.POST)\rif userask_form.is_valid():\ruser_ask = userask_form.save(commit=True)\rreturn HttpResponse('{\u0026quot;status\u0026quot;:\u0026quot;success\u0026quot;}')\relse:\rreturn HttpResponse(json.dumps('{\u0026quot;status\u0026quot;:\u0026quot;fail\u0026quot;, \u0026quot;msg\u0026quot;: \u0026quot;添加错误\u0026quot;}', ensure_ascii=False), content_type=\u0026quot;application/json,charset=utf-8\u0026quot;)\r# return JsonResponse('{\u0026quot;status\u0026quot;:\u0026quot;success\u0026quot;}', safe=False)\r# else:\r# return JsonResponse('{\u0026quot;status\u0026quot;:\u0026quot;fail\u0026quot;, \u0026quot;msg\u0026quot;: \u0026quot;添加错误\u0026quot;}', safe=False)\r 备注：django一般用JsonResponse来返回json数据格式，这种方式返回简单，但是中文会乱码\n# 格式\rreturn JsonResponse(result, safe=False)\r 如若显示中文，需要改用HttpResponse来返回\n# 格式\rreturn HttpResponse(json.dumps(result,ensure_ascii=False),content_type=\u0026quot;application/json,charset=utf-8\u0026quot;)\r 注意： 此处有坑,result要严格按照JSON格式书写.即\nresult = {\u0026quot;status\u0026quot;:\u0026quot;success\u0026quot;}\rresult = {\u0026quot;status\u0026quot;:\u0026quot;fail\u0026quot;, \u0026quot;msg\u0026quot;: \u0026quot;添加错误\u0026quot;}\r 写下面的javascript代码，对表单提交进行监听\n{% block custom_js %}\r\u0026lt;script\u0026gt;\r$(function () {\r$('#jsStayBtn').on('click', function () {\r$.ajax({\rcache: false,\rtype: \u0026quot;POST\u0026quot;,\rurl: \u0026quot;{% url 'org:add_ask' %}\u0026quot;,\rdata: $('#jsStayForm').serialize(),\rasync: true,\rsuccess: function (data) {\rconsole.log(data)\r# 装换成JSON格式，否则data.status为undefined\rdata = JSON.parse(data)\rconsole.log(data.status)\rif (data.status == 'success') {\r$('#jsStayForm')[0].reset();\ralert(\u0026quot;提交成功\u0026quot;)\r} else if (data.status == 'fail') {\r$('#jsCompanyTips').html(data.msg)\r}\r},\r});\r});\r})\r\u0026lt;/script\u0026gt;\r{% endblock %}\r 机构首页/课程/介绍/讲师 点击机构图片查看机构详情等操作\n与前面操作类似，唯一需要提到的是url配置，因为点击机构图片logo的时候需要传递参数，以便知道是哪个机构，所以\n# url配置\rurl(r'^home/(?P\u0026lt;org_id\u0026gt;.*)/$', OrgHomeView.as_view(), name=\u0026quot;org_home\u0026quot;),\r # view逻辑\rclass OrgHomeView(View):\r\u0026quot;\u0026quot;\u0026quot;\r机构首页\r\u0026quot;\u0026quot;\u0026quot;\rdef get(self, request, org_id):\rcurrent_page = \u0026quot;home\u0026quot;\rcourse_org = CourseOrg.objects.get(id=int(org_id))\rhas_fav = False\rif request.user.is_authenticated:\rif UserFavorite.objects.filter(user=request.user, fav_id=course_org.id, fav_type=2):\rhas_fav = True\r# 这里可以通过外键_set来反向获取外键数据\rall_courses = course_org.course_set.all()[:3]\rall_teachers = course_org.teacher_set.all()[:2]\rreturn render(request, 'org-detail-homepage.html', {\r\u0026quot;all_courses\u0026quot;: all_courses,\r\u0026quot;all_teachers\u0026quot;: all_teachers,\r\u0026quot;course_org\u0026quot;: course_org,\r\u0026quot;current_page\u0026quot;: current_page,\r\u0026quot;has_fav\u0026quot;: has_fav\r})\rclass OrgCourseView(View):\r\u0026quot;\u0026quot;\u0026quot;\r机构课程\r\u0026quot;\u0026quot;\u0026quot;\rdef get(self, request, org_id):\rcurrent_page = \u0026quot;course\u0026quot;\rcourse_org = CourseOrg.objects.get(id=int(org_id))\rhas_fav = False\rif request.user.is_authenticated:\rif UserFavorite.objects.filter(user=request.user, fav_id=course_org.id, fav_type=2):\rhas_fav = True\rall_courses = course_org.course_set.all()\rreturn render(request, 'org-detail-course.html', {\r\u0026quot;all_courses\u0026quot;: all_courses,\r\u0026quot;course_org\u0026quot;: course_org,\r\u0026quot;current_page\u0026quot;: current_page,\r\u0026quot;has_fav\u0026quot;: has_fav\r})\rclass OrgDescView(View):\r\u0026quot;\u0026quot;\u0026quot;\r机构介绍\r\u0026quot;\u0026quot;\u0026quot;\rdef get(self, request, org_id):\rcurrent_page = \u0026quot;desc\u0026quot;\rcourse_org = CourseOrg.objects.get(id=int(org_id))\rhas_fav = False\rif request.user.is_authenticated:\rif UserFavorite.objects.filter(user=request.user, fav_id=course_org.id, fav_type=2):\rhas_fav = True\rreturn render(request, 'org-detail-desc.html', {\r\u0026quot;course_org\u0026quot;: course_org,\r\u0026quot;current_page\u0026quot;: current_page,\r\u0026quot;has_fav\u0026quot;: has_fav\r})\rclass OrgTeacherView(View):\r\u0026quot;\u0026quot;\u0026quot;\r机构讲师\r\u0026quot;\u0026quot;\u0026quot;\rdef get(self, request, org_id):\rcurrent_page = \u0026quot;teacher\u0026quot;\rcourse_org = CourseOrg.objects.get(id=int(org_id))\rhas_fav = False\rif request.user.is_authenticated:\rif UserFavorite.objects.filter(user=request.user, fav_id=course_org.id, fav_type=2):\rhas_fav = True\rall_teachers = course_org.teacher_set.all()\rreturn render(request, 'org-detail-teachers.html', {\r\u0026quot;all_teachers\u0026quot;: all_teachers,\r\u0026quot;course_org\u0026quot;: course_org,\r\u0026quot;current_page\u0026quot;: current_page,\r\u0026quot;has_fav\u0026quot;: has_fav\r})\r # 访问时需要在url 'org:org_home'后空一格，然后带上id\r\u0026lt;a href=\u0026quot;{% url 'org:org_home' org.id %}\u0026quot;\u0026gt;\r 其他操作均相同，略\n用户收藏 用户收藏操作同样是异步操作，需要ajax，因为页面采用继承式，所以只需要在org_base.html中更改即可，首先在organization的url中配置\nurl(r'^add_fav/$', AddFavoriteView.as_view(), name=\u0026quot;add_fav\u0026quot;),\r 由于页面中的继承，在点击左侧的时候页面会刷新，导致收藏按钮更改，所以需要对每个操作（机构首页/课程/介绍/讲师）等均进行判断是否收藏，前端需要注意的是，由于界面中不存在form表单提交，所以无法使用{% csrf-token %}，需要在ajax向后提交的时候补充发送，即：\n//收藏分享\rfunction add_fav(current_elem, fav_id, fav_type) {\r$.ajax({\rcache: false,\rtype: \u0026quot;POST\u0026quot;,\rurl: \u0026quot;{% url 'org:add_fav' %}\u0026quot;,\rdata: {'fav_id': fav_id, 'fav_type': fav_type},\rasync: true,\r# ！！！！！！！！！！！！！！！！！！！！！！！\rbeforeSend: function (xhr, settings) {\rxhr.setRequestHeader(\u0026quot;X-CSRFToken\u0026quot;, \u0026quot;{{ csrf_token }}\u0026quot;);\r},\r# ！！！！！！！！！！！！！！！！！！！！！！！\rsuccess: function (data) {\rdata = JSON.parse(data)\rconsole.log(data)\rconsole.log(data.status)\rconsole.log(data.msg)\rif (data.status == 'fail') {\rif (data.msg == '用户未登录') {\rwindow.location.href = \u0026quot;{% url 'login' %}\u0026quot;;\r} else {\ralert(data.msg)\r}\r} else if (data.status == 'success') {\rcurrent_elem.text(data.msg)\r}\r},\r});\r}\r$('.collectionbtn').on('click', function () {\radd_fav($(this), {{ course_org.id }}, 2);\r});\r 后台逻辑\nclass AddFavoriteView(View):\r\u0026quot;\u0026quot;\u0026quot;\r用户收藏\r\u0026quot;\u0026quot;\u0026quot;\rdef post(self, request):\r# 拿到前端数据\rfav_id = request.POST.get('fav_id', 0)\rfav_type = request.POST.get('fav_type', 0)\r# 判断用户是否登录(即使在未登录的情况下，request对象也会产生不同于自定义User的user对象，判断是否登录)\rif not request.user.is_authenticated:\rreturn HttpResponse(json.dumps('{\u0026quot;status\u0026quot;:\u0026quot;fail\u0026quot;, \u0026quot;msg\u0026quot;: \u0026quot;用户未登录\u0026quot;}', ensure_ascii=False), content_type=\u0026quot;application/json, charset=utf-8\u0026quot;)\rexit_records = UserFavorite.objects.filter(user=request.user, fav_id=int(fav_id), fav_type=int(fav_type))\rif exit_records:\r# 如果存在则证明已收藏，现取消收藏\rexit_records.delete()\r# 返回JSON数据\rreturn HttpResponse(json.dumps('{\u0026quot;status\u0026quot;:\u0026quot;success\u0026quot;, \u0026quot;msg\u0026quot;: \u0026quot;收藏\u0026quot;}', ensure_ascii=False), content_type=\u0026quot;application/json, charset=utf-8\u0026quot;)\relse:\ruser_fav = UserFavorite()\rif int(fav_id) \u0026gt; 0 and int(fav_type) \u0026gt; 0:\ruser_fav.user = request.user\ruser_fav.fav_id = int(fav_id)\ruser_fav.fav_type = int(fav_type)\ruser_fav.save()\rreturn HttpResponse(json.dumps('{\u0026quot;status\u0026quot;:\u0026quot;success\u0026quot;, \u0026quot;msg\u0026quot;: \u0026quot;已收藏\u0026quot;}', ensure_ascii=False), content_type=\u0026quot;application/json, charset=utf-8\u0026quot;)\relse:\rreturn HttpResponse(json.dumps('{\u0026quot;status\u0026quot;:\u0026quot;fail\u0026quot;, \u0026quot;msg\u0026quot;: \u0026quot;收藏出错\u0026quot;}', ensure_ascii=False), content_type=\u0026quot;application/json, charset=utf-8\u0026quot;)\r 公开课 首先在courses下创建urls.py文件，然后通过导入到项目下的urls.py文件下，配置操作：\n# urls.py\r# 配置课程相关url\rurl(r'^course/', include('courses.urls', namespace=\u0026quot;course\u0026quot;)),\r# courses下urls.py\rurl(r'^list/$', CourseListView.as_view(), name=\u0026quot;course_list\u0026quot;),\r View\nclass CourseListView(View):\rdef get(self, request):\rall_courses = Course.objects.all().order_by(\u0026quot;-add_time\u0026quot;)\rhot_courses = Course.objects.all().order_by(\u0026quot;-click_nums\u0026quot;)[:3]\rsort = request.GET.get(\u0026quot;sort\u0026quot;, \u0026quot;\u0026quot;)\rif sort:\rif sort == \u0026quot;students\u0026quot;:\rall_courses = all_courses.order_by(\u0026quot;-students\u0026quot;)\relif sort == \u0026quot;hot\u0026quot;:\rall_courses = all_courses.order_by(\u0026quot;-click_nums\u0026quot;)\rorg_nums = all_courses.count()\r# 对课程分页\rtry:\rpage = request.GET.get('page', 1)\rexcept PageNotAnInteger:\rpage = 1\rp = Paginator(all_courses, 6, request=request)\rcorses = p.page(page)\rreturn render(request, 'course-list.html', {\r\u0026quot;all_courses\u0026quot;: corses,\r\u0026quot;hot_courses\u0026quot;: hot_courses,\r\u0026quot;sort\u0026quot;: sort\r})\r 课程列表 同课程机构一样，首先修改页面，只需要在对应位置进行修改（{% block %}）即可完成页面配置，然后进行url配置，在course下创建urls.py文件，最后编写后台View逻辑\n# url 配置\rurl(r'^list/$', CourseListView.as_view(), name=\u0026quot;course_list\u0026quot;),\r class CourseListView(View):\rdef get(self, request):\rall_courses = Course.objects.all().order_by(\u0026quot;-add_time\u0026quot;)\rhot_courses = Course.objects.all().order_by(\u0026quot;-click_nums\u0026quot;)[:3]\rsort = request.GET.get(\u0026quot;sort\u0026quot;, \u0026quot;\u0026quot;)\rif sort:\rif sort == \u0026quot;students\u0026quot;:\rall_courses = all_courses.order_by(\u0026quot;-students\u0026quot;)\relif sort == \u0026quot;hot\u0026quot;:\rall_courses = all_courses.order_by(\u0026quot;-click_nums\u0026quot;)\rorg_nums = all_courses.count()\r# 对课程分页\rtry:\rpage = request.GET.get('page', 1)\rexcept PageNotAnInteger:\rpage = 1\rp = Paginator(all_courses, 6, request=request)\rcorses = p.page(page)\rreturn render(request, 'course-list.html', {\r\u0026quot;all_courses\u0026quot;: corses,\r\u0026quot;hot_courses\u0026quot;: hot_courses,\r\u0026quot;sort\u0026quot;: sort\r})\r 课程详情 # 课程详情页\rurl(r'^detail/(?P\u0026lt;course_id\u0026gt;.*)/$', CourseDetailView.as_view(), name=\u0026quot;course_detail\u0026quot;),\r class CourseDetailView(View):\rdef get(self, request, course_id):\rcourse = Course.objects.get(id=int(course_id))\r# 增加课程点击数\rcourse.click_nums += 1\rcourse.save()\r# 判断是否收藏\rhas_fav_course = False\rhas_fav_org = False\rif request.user.is_authenticated:\rif UserFavorite.objects.filter(user=request.user, fav_id=course.id, fav_type=1):\rhas_fav_course = True\rif UserFavorite.objects.filter(user=request.user, fav_id=course.course_org.id, fav_type=2):\rhas_fav_org = True\rtag = course.tag\rif tag:\rrelate_courses = Course.objects.filter(tag=tag)[:1]\relse:\rrelate_courses = []\rreturn render(request, 'course-detail.html', {\r\u0026quot;course\u0026quot;: course,\r\u0026quot;relate_courses\u0026quot;: relate_courses,\r\u0026quot;has_fav_course\u0026quot;: has_fav_course,\r\u0026quot;has_fav_org\u0026quot;: has_fav_org,\r})\r 课程章节信息配置 获取课程的章节：打开courses/models.py文件，在Course函数里面，新定义函数def get_course_lesson用于获取课程的章节：\ndef get_course_lesson(self):\r# 获取课程所有章节\rreturn self.lesson_set.all()\r 在lesson函数里面，新定义函数def get_lesson_video用于获取章节的视频信息：\ndef get_lesson_video(self):\r# 获取章节视频信息\rreturn self.video_set.all()\r 现在打开course-video.html页面，配置数据的动态显示：\n{% for lesson in course.get_course_lesson %}\r\u0026lt;div class=\u0026quot;chapter chapter-active\u0026quot; \u0026gt;\r\u0026lt;h3\u0026gt;\u0026lt;strong\u0026gt;\u0026lt;i class=\u0026quot;state-expand\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;{{ lesson.name }}\u0026lt;/strong\u0026gt;\u0026lt;/h3\u0026gt;\r\u0026lt;ul class=\u0026quot;video\u0026quot;\u0026gt;\r{% for video in lesson.get_lesson_video %}\r\u0026lt;li\u0026gt;\r\u0026lt;a target=\u0026quot;_blank\u0026quot; href='/video/3662' class=\u0026quot;J-media-item studyvideo\u0026quot;\u0026gt;{{ video.name }}({{ video.learn_times }})\r\u0026lt;i class=\u0026quot;study-state\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;\r\u0026lt;/a\u0026gt;\r\u0026lt;/li\u0026gt;\r{% endfor %}\r\u0026lt;/ul\u0026gt;\r\u0026lt;/div\u0026gt;\r{% endfor %}\r 课程评论 打开courses/urls.py文件，配置课程评论页面的url\nfrom .views import CourseCommentView\r# 课程评论页面url\rre_path('comment/(?P\u0026lt;course_id\u0026gt;.*)/', CourseCommentView.as_view(), name=\u0026quot;course_comment\u0026quot;),\r 然后打开courses/views.py文件，新定义课程评论页面函数：\nfrom operation.models import CourseComments\r# 课程评论页面\rclass CourseCommentView(View):\rdef get(self, request, course_id):\rcourse = Course.objects.get(id=int(course_id))\rall_resources = CourseResource.objects.filter(course=course)\rall_comments = CourseComments.objects.all()\rreturn render(request, \u0026quot;course-comment.html\u0026quot;, {\r\u0026quot;course\u0026quot;: course,\r\u0026quot;all_resources\u0026quot;: all_resources,\r\u0026quot;all_comments\u0026quot;: all_comments,\r})\r 接着打开course-comment.html页面,修改跳转代码：\n\u0026lt;li\u0026gt;\u0026lt;a class=\u0026quot;ui-tabs-active active\u0026quot; id=\u0026quot;learnOn\u0026quot; href=\u0026quot;{% url 'courses:course_info' course.id %}\u0026quot;\u0026gt;\u0026lt;span\u0026gt;章节\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;a id=\u0026quot;commentOn\u0026quot; class=\u0026quot;\u0026quot; href=\u0026quot;{% url 'course:course_comment' course.id %}\u0026quot;\u0026gt;\u0026lt;span\u0026gt;评论\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\r 然后打开course-comment.html页面，修改课程信息，资料下载，讲师提示等, 和前面在video页面配置的一样\n课程资源 第一步，前往xadmin后台为某一门课添加课程资源，第二步打开courses/views.py文件，修改视图函数：\nfrom .models import CourseResource\rall_resources = CourseResource.objects.filter(course=course)\rreturn render(request, \u0026quot;course-video.html\u0026quot;, {\r\u0026quot;all_resources\u0026quot;: all_resources,\r})\r 打开course-video.html页面，配置资源下载的动态显示：\n{% for resources in all_resources %}\r\u0026lt;li\u0026gt;\r\u0026lt;span \u0026gt;\u0026lt;i class=\u0026quot;aui-iconfont aui-icon-file\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;{{ resources.name }}\u0026lt;/span\u0026gt;\r\u0026lt;a href=\u0026quot;{{ MEDIA_URL }}{{ resources.download }}\u0026quot; class=\u0026quot;downcode\u0026quot; target=\u0026quot;_blank\u0026quot; download=\u0026quot;\u0026quot; data-id=\u0026quot;274\u0026quot; title=\u0026quot;\u0026quot;\u0026gt;下载\u0026lt;/a\u0026gt;\r\u0026lt;/li\u0026gt;\r{% endfor %}\r 然后刷新页面，发现显示没有问题。\n接下在course-video.html页面完成课程信息的修改：\n\u0026lt;div class=\u0026quot;static-item \u0026quot;\u0026gt;\r\u0026lt;span class=\u0026quot;meta-value\u0026quot;\u0026gt;\u0026lt;strong\u0026gt;{{ course.get_degree_display }}\u0026lt;/strong\u0026gt;\u0026lt;/span\u0026gt;\r\u0026lt;span class=\u0026quot;meta\u0026quot;\u0026gt;难度\u0026lt;/span\u0026gt;\r\u0026lt;em\u0026gt;\u0026lt;/em\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;static-item static-time\u0026quot;\u0026gt;\r\u0026lt;span class=\u0026quot;meta-value\u0026quot;\u0026gt;\u0026lt;strong\u0026gt;{{ course.learn_times }}分钟\u0026lt;/strong\u0026gt;\t\u0026lt;/span\u0026gt;\r\u0026lt;span class=\u0026quot;meta\u0026quot;\u0026gt;时长\u0026lt;/span\u0026gt;\r\u0026lt;em\u0026gt;\u0026lt;/em\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;static-item\u0026quot;\u0026gt;\r\u0026lt;span class=\u0026quot;meta-value\u0026quot;\u0026gt;\u0026lt;strong\u0026gt;{{ course.students }}人\u0026lt;/strong\u0026gt;\u0026lt;/span\u0026gt;\r\u0026lt;span class=\u0026quot;meta\u0026quot;\u0026gt;学习人数\u0026lt;/span\u0026gt;\r\u0026lt;em\u0026gt;\u0026lt;/em\u0026gt;\r\u0026lt;/div\u0026gt;\r 在配置讲师提示的时候，发现讲师和课程之间没有建立外键连接，所以在courses/models.py文件的Course函数，新增讲师字段 :\nfrom organization.models import Teacher\rteacher = models.ForeignKey(Teacher, on_delete=models.CASCADE, verbose_name=\u0026quot;讲师\u0026quot;, null=True, blank=True)\r 记得数据库的变动需要两部曲：makemigrations和migrate。\n然后前往xadmin后台为这门课添加一个讲师。然后修改course-video.html页面\n课程相关推荐 打开courses/views.py文件，找到CourseInfoView这个函数，修改为如下：\n# 课程章节信息\rclass CourseInfoView(View):\rdef get(self, request, course_id):\rcourse = Course.objects.get(id=int(course_id))\rall_resources = CourseResource.objects.filter(course=course)\r# 取出所有选过这门课的学生\ruser_courses = UserCourse.objects.filter(course=course)\r# 取出所有选过这门课的学生的id,采用递归表达式形式\ruser_ids = [user_course.user.id for user_course in user_courses]\r# 取出刚才那些学生选过的所有的课程\rall_user_courses = UserCourse.objects.filter(user_id__in=user_ids)\r# 取出刚才那些学生选过的所有的课程的id,同样采用递归表达式形式\rcourse_ids = [all_user_course.course_id for all_user_course in all_user_courses]\r# 取出学过该课程用户学过的其他课程\rrelate_courses = Course.objects.filter(id__in=course_ids).order_by(\u0026quot;-click_nums\u0026quot;)[:5]\rreturn render(request, \u0026quot;course-video.html\u0026quot;, {\r\u0026quot;course\u0026quot;: course,\r\u0026quot;all_resources\u0026quot;: all_resources,\r\u0026quot;relate_courses\u0026quot;: relate_courses,\r})\r 注意：双下划线代表代表传进来的是一个可以遍历的list。\n接着就是在前端页面配置动态加载信息了（记得course-video.html和course_comment.html这两个页面都需要配置，一模一样）：\n\u0026lt;ul class=\u0026quot;other-list\u0026quot;\u0026gt;\r{% for relate_course in relate_courses %}\r\u0026lt;li class=\u0026quot;curr\u0026quot;\u0026gt;\r\u0026lt;a href=\u0026quot;{% url 'course:course_detail' relate_course.id %}\u0026quot;target=\u0026quot;_blank\u0026quot;\u0026gt;\r\u0026lt;img src=\u0026quot;{{ MEDIA_URL }}{{ relate_course.image }}\u0026quot;alt=\u0026quot;{{ relate_course.name }}\u0026quot;\u0026gt;\r\u0026lt;span class=\u0026quot;name autowrap\u0026quot;\u0026gt;{{ relate_course.name }}\u0026lt;/span\u0026gt;\r\u0026lt;/a\u0026gt;\r\u0026lt;/li\u0026gt;\r{% endfor %}\r\u0026lt;/ul\u0026gt;\r 存在问题：那就是用户如果没有登录，那是不能让他进入课程章节这个页面的，因此需要判断一下。这里因为使用的是方法型编程所以可以使用装饰器loginrequired来进行判断。\n在utils文件夹下面，新建一个名为mixin_utils.py文件，在里面添加如下代码：\nfrom django.contrib.auth.decorators import login_required\rfrom django.utils.decorators import method_decorator\rclass LoginRequiredMixin(object):\r@method_decorator(login_required(login_url='/login/'))\rdef dispatch(self, request, *args, **kwargs):\rreturn super(LoginRequiredMixin, self).dispatch(request, *args, **kwargs)\r 接着打开courses/views.py文件，在里面修改CourseInfoView和CourseCommentView，修改后如下：\nfrom utils.mixin_utils import LoginRequiredMixin\r# 课程章节信息\rclass CourseInfoView(LoginRequiredMixin, View):\rlogin_url = '/login/'\rredirect_field_name = 'redirect_to'\rdef get(self, request, course_id):\rcourse = Course.objects.get(id=int(course_id))\rall_resources = CourseResource.objects.filter(course=course)\r# 查询用户是否已经开始学习了该课程，如果没有则开始学习\ruser_courses = UserCourse.objects.filter(user=request.user, course=course)\rif not user_courses:\ruser_course = UserCourse(user=request.user, course=course)\rcourse.students += 1\rcourse.save()\ruser_course.save()\r# 取出所有选过这门课的学生\ruser_courses = UserCourse.objects.filter(course=course)\r# 取出所有选过这门课的学生的id,采用递归表达式形式\ruser_ids = [user_course.user.id for user_course in user_courses]\r# 取出刚才那些学生选过的所有的课程\rall_user_courses = UserCourse.objects.filter(user_id__in=user_ids)\r# 取出刚才那些学生选过的所有的课程的id,同样采用递归表达式形式\rcourse_ids = [all_user_course.course_id for all_user_course in all_user_courses]\r# 取出学过该课程用户学过的其他课程\rrelate_courses = Course.objects.filter(id__in=course_ids).order_by(\u0026quot;-click_nums\u0026quot;)[:5]\rreturn render(request, \u0026quot;course-video.html\u0026quot;, {\r\u0026quot;course\u0026quot;: course,\r\u0026quot;all_resources\u0026quot;: all_resources,\r\u0026quot;relate_courses\u0026quot;: relate_courses,\r})\r# 课程评论页面\rclass CourseCommentView(LoginRequiredMixin, View):\rlogin_url = '/login/'\rredirect_field_name = 'redirect_to' def get(self, request, course_id):\rcourse = Course.objects.get(id=int(course_id))\rall_resources = CourseResource.objects.filter(course=course)\rall_comments = CourseComments.objects.all()\rreturn render(request, \u0026quot;course-comment.html\u0026quot;, {\r\u0026quot;course\u0026quot;: course,\r\u0026quot;all_resources\u0026quot;: all_resources,\r\u0026quot;all_comments\u0026quot;: all_comments,\r})\r 刷新一下页面，点几个课程试试看，发现都在该同学还学过哪些课里推荐了。\n课程视频 课程播放页面配置 打开courses/urls.py文件，新增代码：\nfrom .views import VideoPlayView\r# 视频播放页面url\rre_path('video/(?P\u0026lt;video_id\u0026gt;.*)/', VideoPlayView.as_view(), name=\u0026quot;video_play\u0026quot;),\r或者 re_path('video/(?P\u0026lt;video_id\u0026gt;\\d+)/', VideoPlayView.as_view(), name=\u0026quot;video_play\u0026quot;),都是可以的\r 接着打开courses/views.py文件，新增代码：\nfrom .models import Video\r# 视频播放页面\rclass VideoPlayView(LoginRequiredMixin, View):\rlogin_url = '/login/'\rredirect_field_name = 'redirect_to'\rdef get(self, request, video_id):\rvideo = Video.objects.get(id=int(video_id))\rcourse = video.lesson.course\rall_resources = CourseResource.objects.filter(course=course)\r# 查询用户是否已经开始学习了该课程，如果没有则开始学习\ruser_courses = UserCourse.objects.filter(user=request.user, course=course)\rif not user_courses:\ruser_course = UserCourse(user=request.user, course=course)\rcourse.students += 1\rcourse.save()\ruser_course.save()\r# 取出所有选过这门课的学生\ruser_courses = UserCourse.objects.filter(course=course)\r# 取出所有选过这门课的学生的id,采用递归表达式形式\ruser_ids = [user_course.user.id for user_course in user_courses]\r# 取出刚才那些学生选过的所有的课程\rall_user_courses = UserCourse.objects.filter(user_id__in=user_ids)\r# 取出刚才那些学生选过的所有的课程的id,同样采用递归表达式形式\rcourse_ids = [all_user_course.course_id for all_user_course in all_user_courses]\r# 取出学过该课程用户学过的其他课程\rrelate_courses = Course.objects.filter(id__in=course_ids).order_by(\u0026quot;-click_nums\u0026quot;)[:5]\rreturn render(request, \u0026quot;course-play.html\u0026quot;, {\r\u0026quot;course\u0026quot;: course,\r\u0026quot;all_resources\u0026quot;: all_resources,\r\u0026quot;relate_courses\u0026quot;: relate_courses,\r\u0026quot;video\u0026quot;: video,\r})\r 上面的代码和之前在课程章节信息里面定义的几乎一模一样，只是course的来源不一样。\n接着打开course-video.html文件，配置跳转链接：\n{% for video in lesson.get_lesson_video %}\r\u0026lt;li\u0026gt;\r\u0026lt;a target=\u0026quot;_blank\u0026quot; href='{% url 'course:video_play' video.id %}'\rclass=\u0026quot;J-media-item studyvideo\u0026quot;\u0026gt;{{ video.name }}({{ video.learn_times }})\r\u0026lt;i class=\u0026quot;study-state\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;\r\u0026lt;/a\u0026gt;\r\u0026lt;/li\u0026gt;\r{% endfor %}\r 然后打开course-video.html文件，配置视频链接，记住由于我们这边是type=\u0026lsquo;video/mp4\u0026rsquo;所以后台所添加的视频必须是.mp4结尾，否则会出错。\n备注：{{ forloop.counter|add:2 }}是为了从第三个开始计数的，这是Django自带的功能\n{% if forloop.counter|divisibleby:5 %}five{% endif %}表示如果能被5整除则显示five，这也是Django自带的功能\n404和500页面的配置 从前端资料里面拷贝我们的404和500页面到templates文件夹并修改文件里面的静态文件地址。打开eduline/urls.py文件，新增代码如下：\n# 全局404页面配置\rhandler404 = 'users.views.page_not_found'\r 然后打开users/views.py文件，新增以下代码：\n# 404页面对应的处理函数\rdef page_not_found(request):\rfrom django.shortcuts import render_to_response\rresponse = render_to_response(\u0026quot;404.html\u0026quot;, {})\r# 设置response的状态码\rresponse.status_code = 404\rreturn response\r 接着运行项目，随意输入一个地址，发现页面并没有出来，那是因为在eduline/settings.py文件里面：DEBUG = True，所以我们需要修改它为False，还有下面的允许访问IP地址，否则404页面也是出不来的：\nDEBUG = False\rALLOWED_HOSTS = ['*']\r 这样重新运行一下项目，发现页面有了，但是样子却没加载出来，这是为什么呢？\n因为DEBUG为True时，系统会自动前往STATICFILES_DIRS下寻找文件。所以一般都会选择True，便于错误信息的显示。\n但是一旦DEBUG为False时，情况就不一样了，Django就不会代管静态文件，而事实上一般静态文件都是通过第三方http服务器来代理转发。（如常见的服务器Nignx 和 Apache都会自动代理这些静态文件）\n为了解决上述问题，可以：打开eduline/settings.py文件，新增代码如下：\nSTATIC_ROOT = os.path.join(BASE_DIR, 'static')\r 打开eduline/urls.py文件，新增代码如下：\nfrom eduline.settings import STATIC_ROOT\r# 配置静态文件上传的访问处理url\rre_path('static/(?P\u0026lt;path\u0026gt;.*)', serve, {\u0026quot;document_root\u0026quot;: STATIC_ROOT}),\r 重新运行项目即可.500的页面的配置和这个一样（注意函数名为page_error）\n隐藏的坑：按照上述步骤可以解决404/500等问题，但是进入到后台管理界面(127.0.0.1:800/xadmin)界面则会发现样式丢失！\n产生原因： django的生产环境不同开发环境，在生产环境下（DEBUG=False）,django.contrib.staticfiles 是不起任何作用的，也就说 django.contrib.staticfiles 只对开发环境（DEBUG=True）开启。所以会导致xadmin样式丢失现象。\n解决方案： ① 在settings.py中添加如下配置，同时注释STATICFILES_DIRS\n# STATICFILES_DIRS = (\r# os.path.join(BASE_DIR, \u0026quot;static\u0026quot;),\r# )\rSTATIC_ROOT = os.path.join(BASE_DIR, 'static')\r ② 修改主项目中的urls.py文件\nfrom.settings import STATIC_ROOT\rurlpatterns = [\r//...\rurl(r'^static/(?P\u0026lt;path\u0026gt;.*)$', serve, {\u0026quot;document_root\u0026quot;: STATIC_ROOT}),\r]\r ③ 在控制台执行如下命令，它会在根目录下生成static文件，里边存储的是xadmin的样式文件：\n\u0026gt; collectstatic\r 常见的Web攻击 具体包括SQL注入攻击及防护，XSS攻击及防护以及CSRF攻击及防护\nSQL注入攻击及防护 什么是SQL注入？\n 所谓SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。具体来说，它是利用现有应用程序，将（恶意的）SQL命令注入到后台数据库引擎执行的能力，它可以通过在Web表单中输入（恶意）SQL语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行SQL语句。比如先前的很多影视网站泄露VIP会员密码大多就是通过WEB表单递交查询字符暴出的，这类表单特别容易受到SQL注入式攻击。\n SQL注入的危害:\n非法读取、篡改、删除数据库中的数据\n盗取用户的各类敏感信息，获取利益\n通过修改数据库来修改网页上的内容\n注入木马等等\n下面通过一段代码了解一下SQL注入的过程：\n# users/views.py文件：\rclass LoginUnsafeView(View):\rdef get(self, request):\rreturn render(request, \u0026quot;login.html\u0026quot;, {})\rdef post(self, request):\ruser_name = request.POST.get(\u0026quot;username\u0026quot;, \u0026quot;\u0026quot;)\rpass_word = request.POST.get(\u0026quot;password\u0026quot;, \u0026quot;\u0026quot;)\rimport MySQLdb\rconn = MySQLdb.connect(host='127.0.0.1', user='root', passwd='root', db='mxonline', charset='utf8')\rcursor = conn.cursor()\rsql_select = \u0026quot;select * from users_userprofile where email='{0}' and password='{1}'\u0026quot;.format(user_name, pass_word)\rresult = cursor.execute(sql_select)\rfor row in cursor.fetchall():\r# 查询到用户\rpass\rprint 'hello'\r# eduline/urls.py文件:\rfrom users.views import LoginUnsafeView\rurlpatterns = [\rpath('login/', LoginUnsafeView.as_view(), name='login'),\r]\r 这里竟然把sql语句写到这里，所以可以在参数中加入sql语句，使之拼接字符串从而为真被系统识别通过，盗取用户信息。但是在Django自带了orm,可以对这个进行验证，从而保证系统的安全。因此建议采用orm这种形式，不要使用原生的sql语句。\nXSS攻击及防护 CSRF攻击及防护 xadmin进阶 自定义icon 以修改邮箱验证码为例，打开users/adminx.py文件，在EmailVerifyRecordAdmin函数新增一行代码：\nmodel_icon = 'fa fa-user'\r 其实这个样式就是对应于font awesome/http://www.fontawesome.com.cn/里面的图标，你可以下载新的源代码对目录下的css和fonts文件夹进行替换：\n然后刷新一下就出现想要的样式icon了。（如果为出现，用Ctrl+F5强制刷新，还是不行的话，注销重新登录）\n默认排序，字段只读，字段隐藏 我们以课程为例，来介绍这3个小功能。打开couses/adminx.py文件，在CourseAdmin中加入以下代码：\n# 默认排序：以点击数排序\rordering = ['-click_nums']\r# 字段只读：点击数只允许读取\rreadonly_fields = ['click_nums', 'fav_nums']\r# 字段隐藏：收藏数隐藏显示\rexclude = ['fav_nums']\r# 注意字段只读和字段隐藏是冲突的，不允许设置一个字段只读同时隐藏\r 搜索框 当课程很多时，我们不能以下拉菜单的形式来查找课程，需要有搜索框。课程它有一个外键是课程机构，因此需要到课程机构里面进行搜索框的配置。打开organization/adminx.py文件，在CourseOrgAdmin函数里面添加一行代码：\n# 搜索框，当课程数据量过大时，有课程指向它，会以ajax方式加载\rrelfield_style = 'fk-ajax'\r inlines添加数据 在这之前，新增课程的时候是不能同时新增课程章节信息的，需要跳到另一个页面，这是很麻烦的。所以考虑采用inlines来添加数据从而完成在一个页面直接完成章节信息的添加。\n打开couses/adminx.py文件，在最顶部新定义一个函数：\n# 课程直接添加章节\rclass LessonInline(object):\rmodel = Lesson\rextra = 0\r# 同时在CourseAdmin中，新增一行代码\r# 课程直接添加章节\rclass CourseAdmin(object):\rinlines = [LessonInline] # 数组，支持多个\r 刷新一下后台，发现章节信息在课程页面底部\n支持多个添加，但不支持嵌套添加（只能添加一级）\n# 再添加 一个CourseRecourseInline\rclass CourseRecourseInline(object):\rmodel = CourseRecource\rextra = 0\r# 同时在CourseAdmin中，新增一行代码\r# 课程直接添加章节\rclass CourseAdmin(object):\rinlines = [LessonInline, CourseRecourseInline] # 数组，支持多个\r 这样存储到这两个中的数据会保存到对应的表中\n一张表分两个model来进行管理 录播课程与非轮播课程可以分开管理，但是最好是在一张表里显示。打开courses/models.py文件，在course函数下面新增代码\nclass BannerCourse(Course): # 注意是继承Course而不是object这个最高类\rclass Meta:\rverbose_name = \u0026quot;轮播课程\u0026quot;\rverbose_name_plural = verbose_name\rproxy = True # 很重要，否则会生成另外一张表，这样设置具有model的功能，但不会生成表\r 然后打开courses/adminx.py文件，修改之前的代码：\nfrom .models import BannerCourse\rclass CourseAdmin(object):\rlist_display = ['image', ....','add_time'] # 一次显示你想出现的多行数据\rsearch_fields = ['name', ...，'click_nums'] # 查询你想要的数据\rlist_filter = ['name', ..., 'click_nums','add_time'] # 过滤器\r# # 默认排序：以点击数排序\r# ordering = ['-click_nums']\r#\r# # 字段只读：点击数只允许读取\r# readonly_fields = ['click_nums', 'fav_nums']\r#\r# # 字段隐藏：收藏数隐藏显示\r# exclude = ['fav_nums']\r# # 注意字段只读和字段隐藏是冲突的，不允许设置一个字段只读同时隐藏\r# 课程直接添加章节,课程资源\rinlines = [LessonInline, CourseResourceInline]\r# 过滤列表中的数据：为了两个页面信息不重复\rdef queryset(self):\rqs = super(CourseAdmin, self).queryset()\rqs = qs.filter(is_banner=False)\rreturn qs\rclass BannerCourseAdmin(object):\rlist_display = ['image', ....','add_time'] # 一次显示你想出现的多行数据\rsearch_fields = ['name', ...，'click_nums'] # 查询你想要的数据\rlist_filter = ['name', ..., 'click_nums','add_time'] # 过滤器\r# # 默认排序：以点击数排序\r# ordering = ['-click_nums']\r#\r# # 字段只读：点击数只允许读取\r# readonly_fields = ['click_nums', 'fav_nums']\r#\r# # 字段隐藏：收藏数隐藏显示\r# exclude = ['fav_nums']\r# # 注意字段只读和字段隐藏是冲突的，不允许设置一个字段只读同时隐藏\r# 课程直接添加章节,课程资源\rinlines = [LessonInline, CourseResourceInline]\r# 过滤列表中的数据\rdef queryset(self):\rqs = super(BannerCourseAdmin, self).queryset()\rqs = qs.filter(is_banner=True)\rreturn qs\rxadmin.site.register(BannerCourse, BannerCourseAdmin)\r 直接列表页编辑 即可以直接在列表页进行更改编辑操作，在courses/adminx.py文件的CourseAdmin函数，新增一行代码：\n# 直接列表页编辑\rlist_editable = ['degree', 'desc', ]\r 列表页显示章节数 在courses/adminx.py文件的CourseAdmin和BannerCourseAdmin函数的list_display中，新增显示字段get_zj_nums，刷新后台发现是黑色的英文\n需要修改，新增一行代码：\nget_zj_nums.short_description = \u0026quot;章节数\u0026quot;\r 显示自定义的html代码 在刚才的页面下面新增以下代码：\ndef go_to(self):\rfrom django.utils.safestring import mark_safe\r# 如果不使用mark_safe，系统则会对其进行转义\rreturn mark_safe(\u0026quot;\u0026lt;a href='http://www.baidu.com'\u0026gt;跳转\u0026lt;/\u0026gt;\u0026quot;)\rgo_to.short_description = \u0026quot;跳转\u0026quot;\r 列表页定时刷新 打开courses/adminx.py文件，在之前的CourseAdmin函数里面，新增一行代码：\n refresh_times = 3,5 # 列表页定时刷新3s或者5s\r 字段联动 某一字段发生改变的时候不需要手动更改，比如添加一门课程之后，机构的课程数需要+1\n# CourseAdmin中添加\rdef save_models(self):\r# 在保存课程的时候,统计课程机构的课程数\robj = self.new_obj\r# 新增课程还没有保存，统计的课程数就会少一个\robj.save()\r# 必须确定存在\rif obj.course_org is not None:\r# obj实际是一个course对象\rcourse_org = obj.course_org\rcourse_org.course_nums = Course.objects.filter(course_org=course_org).count()\rcourse_org.save()\r xadmin目录 - locale 对应语言包\r- migrations 是数据表的记录\r- plugins 每一个后台页面都是一个plugin插件\r- static 静态文件夹，里面有js,css\r- template 这是xadmin自己使用的html文件\r- templatetags 这是tag模板\r xadmin集成富文本 首先点击Xadmin 插件制作，学着官网的介绍，自己尝试做一个插件:富文本编辑器.\n有坑的插件！！！先看完！！！ 点击DjangoUeditor，获取DjangoUeditor的安装包，然后按照帮助文档或者下面的要求安装DjangoUeditor；或者PYPI下载DjangoUeditor.\n1、安装方法(注意需要转到虚拟环境下面才能安装)  方法一：将github整个源码包下载，在命令行运行  python setup.py install\r  方法二：使用pip工具在命令行运行(推荐)：  pip install DjangoUeditor\r 2、在Django中安装DjangoUeditor   在INSTALL_APPS里面增加\nINSTALLED_APPS = [\r'captcha', # 验证码\r'pure_pagination', # 分页\r'DjangoUeditor',\r]\r   3、富文本相关path配置 配置url\n# 富文本相关url\rurl(\u0026quot;ueditor/\u0026quot;, include('DjangoUeditor.urls')),\r 4、在models中的使用 # courses/models.py文件：\rfrom DjangoUeditor.models import UEditorField\rclass Course(models.Model):\rdetail = UEditorField(verbose_name='课程详情', width=600, height=300, imagePath=\u0026quot;courses/ueditor/\u0026quot;,filePath=\u0026quot;courses/ueditor/\u0026quot;, default='')\r 5、书写代码 在xadmin的plugins文件夹下面，新增一个ueditor.py文件，在里面新增：\nimport xadmin\rfrom xadmin.views import BaseAdminPlugin, CreateAdminView, ModelFormAdminView, UpdateAdminView\rfrom DjangoUeditor.models import UEditorField\rfrom DjangoUeditor.widgets import UEditorWidget\rfrom django.conf import settings\rclass XadminUEditorWidget(UEditorWidget):\rdef __init__(self,**kwargs):\rself.ueditor_options=kwargs\rself.Media.js = None\rsuper(XadminUEditorWidget,self).__init__(kwargs)\rclass UeditorPlugin(BaseAdminPlugin):\rdef get_field_style(self, attrs, db_field, style, **kwargs):\rif style == 'ueditor':\rif isinstance(db_field, UEditorField):\rwidget = db_field.formfield().widget\rparam = {}\rparam.update(widget.ueditor_settings)\rparam.update(widget.attrs)\rreturn {'widget': XadminUEditorWidget(**param)}\rreturn attrs\r# 在生成的页面中放入自己的js文件\rdef block_extrahead(self, context, nodes):\rjs = '\u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;%s\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;' % (settings.STATIC_URL + \u0026quot;ueditor/ueditor.config.js\u0026quot;) #自己的静态目录\rjs += '\u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;%s\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;' % (settings.STATIC_URL + \u0026quot;ueditor/ueditor.all.min.js\u0026quot;) #自己的静态目录\rnodes.append(js)\r# 新增页面\rxadmin.site.register_plugin(UeditorPlugin, UpdateAdminView)\r# 修改页面\rxadmin.site.register_plugin(UeditorPlugin, CreateAdminView)\r 6、字段显示样式 courses/adminx.py文件：\nclass CourseAdmin(object):\r# 字段显示样式\rstyle_fields = {\u0026quot;detail\u0026quot;: \u0026quot;ueditor\u0026quot;}\r 7、注册进入plugins 找到plugins文件夹下的__init__.py文件，在PLUGINS中写入\nPLUGINS= ('ueditor',)\t# 与文件名一致\r 有坑！！！\n会报错！\n原因是UEditor 好像是没有Python3版本的。 直接这样安装，要自己修改里面的一些Python2的语法\n解决方法：找到DjangoUeditor3下载命令行安装，或者解压后复制到项目下的extra_apps下\n（可能还需要将DjangoUeditor下static中的ueditor文件夹拷贝到根目录下的static文件中）\nExcel导入插件 1、根目录下找到\\extra_apps\\xadmin\\plugins\\路径，创建excel.py文件\n# _*_ coding:utf-8 _*_\rimport xadmin\rfrom xadmin.views import BaseAdminPlugin, ListAdminView\rfrom django.template import loader\rfrom xadmin.plugins.utils import get_context_dict\r# excel 导入\rclass ListImportExcelPlugin(BaseAdminPlugin):\rimport_excel = False\rdef init_request(self, *args, **kwargs):\rreturn bool(self.import_excel)\rdef block_top_toolbar(self, context, nodes):\r# context = {\u0026quot;context\u0026quot;: context}\rnodes.append(loader.render_to_string('xadmin/excel/model_list.top_toolbar.import.html',\rcontext=get_context_dict(context)))\rxadmin.site.register_plugin(ListImportExcelPlugin, ListAdminView)\r 注意：这里有个坑！按照视频或者网站上的说法写的excel.py文件会报错\n原因是：context_instance字段在Django1.8以后产生，而在Django1.10之后就移除了，按照网上的修改方法将改成context，即：\nnodes.append(loader.render_to_string('xadmin/excel/model_list.top_toolbar.import.html', context))\r 仍会报错！\n再更改为\ncontext = {\u0026quot;context\u0026quot;: context}\rnodes.append(loader.render_to_string('xadmin/excel/model_list.top_toolbar.import.html', context))\r 可以完成操作，但是会报警告！\n2、配置.html文件，即项目根目录下找到\\extra_apps\\xadmin\\templates\\xadmin，创建excel文件夹，在excel文件夹下创建model_list.top_toolbar.import.html文件，复制以下代码.\n{% load i18n %}\r\u0026lt;div class=\u0026quot;btn-group export\u0026quot;\u0026gt;\r\u0026lt;a class=\u0026quot;dropdown-toggle btn btn-default btn-sm\u0026quot; data-toggle=\u0026quot;dropdown\u0026quot; href=\u0026quot;#\u0026quot;\u0026gt;\r\u0026lt;i class=\u0026quot;icon-share\u0026quot;\u0026gt;\u0026lt;/i\u0026gt; 导入 \u0026lt;span class=\u0026quot;caret\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\r\u0026lt;/a\u0026gt;\r\u0026lt;ul class=\u0026quot;dropdown-menu\u0026quot; role=\u0026quot;menu\u0026quot; aria-labelledby=\u0026quot;dLabel\u0026quot;\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;a data-toggle=\u0026quot;modal\u0026quot; data-target=\u0026quot;#export-modal-import-excel\u0026quot;\u0026gt;\u0026lt;i class=\u0026quot;icon-circle-arrow-down\u0026quot;\u0026gt;\u0026lt;/i\u0026gt; 导入 Excel\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;/ul\u0026gt;\r\u0026lt;script\u0026gt;\rfunction fileChange(target){\r//检测上传文件的类型\rvar imgName = document.all.submit_upload.value;\rvar ext,idx;\rif (imgName == ''){\rdocument.all.submit_upload_b.disabled=true;\ralert(\u0026quot;请选择需要上传的 xls 文件!\u0026quot;);\rreturn;\r} else {\ridx = imgName.lastIndexOf(\u0026quot;.\u0026quot;);\rif (idx != -1){\rext = imgName.substr(idx+1).toUpperCase();\rext = ext.toLowerCase( );\r{# alert(\u0026quot;ext=\u0026quot;+ext);#}\rif (ext != 'xls' \u0026amp;\u0026amp; ext != 'xlsx'){\rdocument.all.submit_upload_b.disabled=true;\ralert(\u0026quot;只能上传 .xls 类型的文件!\u0026quot;);\rreturn;\r}\r} else {\rdocument.all.submit_upload_b.disabled=true;\ralert(\u0026quot;只能上传 .xls 类型的文件!\u0026quot;);\rreturn;\r}\r}\r}\r\u0026lt;/script\u0026gt;\r\u0026lt;div id=\u0026quot;export-modal-import-excel\u0026quot; class=\u0026quot;modal fade\u0026quot;\u0026gt;\r\u0026lt;div class=\u0026quot;modal-dialog\u0026quot;\u0026gt;\r\u0026lt;div class=\u0026quot;modal-content\u0026quot;\u0026gt;\r\u0026lt;form method=\u0026quot;post\u0026quot; action=\u0026quot;\u0026quot; enctype=\u0026quot;multipart/form-data\u0026quot;\u0026gt;\r{% csrf_token %}\r\u0026lt;div class=\u0026quot;modal-header\u0026quot;\u0026gt;\r\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;close\u0026quot; data-dismiss=\u0026quot;modal\u0026quot; aria-hidden=\u0026quot;true\u0026quot;\u0026gt;×\u0026lt;/button\u0026gt;\r\u0026lt;h4 class=\u0026quot;modal-title\u0026quot;\u0026gt;导入 Excel\u0026lt;/h4\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;modal-body\u0026quot;\u0026gt;\r\u0026lt;input type=\u0026quot;file\u0026quot; οnchange=\u0026quot;fileChange(this)\u0026quot; name=\u0026quot;excel\u0026quot; id=\u0026quot;submit_upload\u0026quot;\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;modal-footer\u0026quot;\u0026gt;\r\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;btn btn-default\u0026quot; data-dismiss=\u0026quot;modal\u0026quot;\u0026gt;{% trans \u0026quot;Close\u0026quot; %}\u0026lt;/button\u0026gt;\r\u0026lt;button class=\u0026quot;btn btn-success\u0026quot; type=\u0026quot;submit\u0026quot; id=\u0026quot;submit_upload_b\u0026quot;\u0026gt;\u0026lt;i class=\u0026quot;icon-share\u0026quot;\u0026gt;\u0026lt;/i\u0026gt; 导入\u0026lt;/button\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/form\u0026gt;\r\u0026lt;/div\u0026gt;\u0026lt;!-- /.modal-content --\u0026gt;\r\u0026lt;/div\u0026gt;\u0026lt;!-- /.modal-dalog --\u0026gt;\r\u0026lt;/div\u0026gt;\u0026lt;!-- /.modal --\u0026gt;\r\u0026lt;/div\u0026gt;\r 3、在想导入的XxxAdmin下添加impotr_excel = True，并且重写post方法\ndef post(self, request, *args, **kwargs):\r# 导入逻辑\rif 'excel' in request.FILES:\rpass\rreturn super(CourseAdmin, self).post(request, args, kwargs)\r 4、最后在xadmin/plugins文件夹下找到__init__.py文件夹，添加\nPLUGINS = (\r'excel',\r)\r ","date":1612051200,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1612051200,"objectID":"781a6e1446b01330eb20050255d08d58","permalink":"https://CoMath21.github.io/post/1-%E6%85%95%E8%AF%BE%E7%BD%91mxonline/","publishdate":"2021-01-31T00:00:00Z","relpermalink":"/post/1-%E6%85%95%E8%AF%BE%E7%BD%91mxonline/","section":"post","summary":"慕课网 MxOnline 整理笔记.","tags":["编程语言","Django","Python"],"title":"Django学习笔记","type":"post"},{"authors":["Xin态好先生","CoMath"],"categories":["学习笔记","编程语言"],"content":"准备工作 　首先需要找到开发软件：Eclipse-J2EE版本，并且安装相应插件（最好安装，便于初期简单编程）.\n注：云盘中一个压缩包中有完整软件.\n安装插件步骤： 打开Eclipse-J2EE版本，找到Help→Install New SoftWare → Work with右面的Add ，在Archive…中找到对应软件的路径，点集OK即可. 需要的软件：\n hibernate的插件：hibernatetools-Update-4.1.1.Final_2013-12-08_01-06-33-B605.zip Spring的插件：springsource-tool-suite-3.4.0.RELEASE-e4.3.1-updatesite.zip  如果没有服务器，需要安装Tomcat服务器.\nSpring→Hibernate→Struts的顺序整合框架 1. 加入Spring 1)\t加入 Spring 所需要的 Jar 包文件 　找到 Spring 的 jar 包文件夹，\\Jar包文件\\Spring4.0.0\\spring-framework-4.0.0.RELEASE\\required，大约15个左右；\n com.springsource.net.sf.cglib-2.2.0.jar com.springsource.org.aopalliance-1.0.0.jar com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar commons-logging-1.2.jar spring-aop-4.0.0.RELEASE.jar spring-aspects-4.0.0.RELEASE.jar spring-beans-4.0.0.RELEASE.jar spring-context-4.0.0.RELEASE.jar spring-core-4.0.0.RELEASE.jar spring-expression-4.0.0.RELEASE.jar spring-jdbc-4.0.0.RELEASE.jar spring-orm-4.0.0.RELEASE.jar spring-tx-4.0.0.RELEASE.jar spring-web-4.0.0.RELEASE.jar spring-webmvc-4.0.0.RELEASE.jar  2)\t配置 web.xml 文件 　配置web.xml文件可以找到ContextLoaderListener会自动生成以下代码，随后将Location改为applicationContext（Spring配置文件）的路径.\n\u0026lt;!-- 配置 Spring 配置文件的名称和位置 --\u0026gt; \u0026lt;context-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:applicationContext.xml\u0026lt;/param-value\u0026gt; \u0026lt;/context-param\u0026gt; \u0026lt;!-- 启动 IOC 容器的 ServletContextListener --\u0026gt; \u0026lt;listener\u0026gt; \u0026lt;listener-class\u0026gt; org.springframework.web.context.ContextLoaderListener \u0026lt;/listener-class\u0026gt; \u0026lt;/listener\u0026gt;  3)\t加入 Spring 的配置文件 　可以先创建一个资源文件conf，将资源文件放入其中（也可以直接在src下创建），在资源文件下创建一个Spring的配置文件点击右键找到Spring Bean Configuration File，输入配置文件的名字，（注意这里面的名字要与web.xml下的的配置文件的名字相同，也就是一个文件）；然后选中aop、beans、context、tx等选项，（注意这里面所选取的是最基本的，根据需要可以自行添加其他选项）；最后Finish即可. 2.\t加入Hibernate 1). 建立持久化类, 和其对应的 .hbm.xml 文件, 生成对应的数据表 i. 配置hibernate.cfg.xml文件：\n　鼠标右键找到Hibernate Configuration File(cfg.xml)创建hibernate.cfg.xml配置文件并配置基本信息（可根据需求自行添加）.\n\u0026lt;hibernate-configuration\u0026gt; \u0026lt;session-factory\u0026gt; \u0026lt;!-- 配置基本属性 --\u0026gt; \u0026lt;!-- 方言 --\u0026gt; \u0026lt;property name=\u0026quot;hibernate.dialect\u0026quot;\u0026gt;org.hibernate.dialect.SQLServer2008Dialect \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;hibernate.dialect\u0026quot;\u0026gt; org.hibernate.dialect.MySQL5InnoDBDialect\u0026lt;/property\u0026gt; \u0026lt;!-- 是否显示及格式化SQL --\u0026gt; \u0026lt;property name=\u0026quot;hibernate.show_sql\u0026quot;\u0026gt;true\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;hibernate.format_sql\u0026quot;\u0026gt;true\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;hibernate.temp.use_jdbc_metadata_defaults\u0026quot;\u0026gt;false\u0026lt;/property\u0026gt; \u0026lt;!-- 生成数据表的策略 --\u0026gt; \u0026lt;property name=\u0026quot;hibernate.hbm2ddl.auto\u0026quot;\u0026gt;update\u0026lt;/property\u0026gt; \u0026lt;!-- 生成二级缓存 --\u0026gt; \u0026lt;/session-factory\u0026gt; \u0026lt;/hibernate-configuration\u0026gt;  ii. 建立持久化类:\n　也就是平时所说的对象类、beans（一般创建在domain包下或者entities下），并生成对应参数的getter and setter；之后鼠标右键创建Hibernate XML Mapping file (hbm.xml)文件，直接创建即可. 就会生成对应的*. hbm.xml文件（根据不同的需求可能够对*. hbm.xml文件进行适当的修改）\n2). Spring 整合 Hibernate 步骤\n① 加入 jar 包: 找到 Hibernate 的 jar 包文件夹，\\Jar包文件\\Jar包文件\\Hibernate4.2.21\\hibernate-release-4.2.21.Final\\lib\\required路径下的所有 jar 包.\n antlr-2.7.7.jar dom4j-1.6.1.jar hibernate-commons-annotations-4.0.2.Final.jar hibernate-core-4.2.21.Final.jar hibernate-jpa-2.0-api-1.0.1.Final.jar javassist-3.18.1-GA.jar jboss-logging-3.1.0.GA.jar jboss-transaction-api_1.1_spec-1.0.1.Final.jar  ② 在类路径下加入 hibernate.cfg.xml 文件，并在其中配置 hibernate 的基本属性\n③ 建立持久化类和其对应的 .hbm.xml 文件（过）\n④ 和 Spring 进行整合（过）\n 加入c3p0和SQLServer的驱动（需要引入相关jar包文件：c3p0-0.9.2.1.jar、sqljdbc4.jar（SQL2005））  （c3p0:是一个 数据库连接池 ，利用 sqljdbc4 建立与数据库的连接 ， 并且管理这些连接，不用每次访问数据库都 重新发出数据库连接请求；大大提升性能）\n具体实现： 首先要创建*.properties文件，并对其进行配置，主要为数据库的相关参数设置.\n\u0026lt;!-- 资源文件样式 --\u0026gt; jdbc.user=sa jdbc.password=sa123 jdbc.driverClass=com.microsoft.sqlserver.jdbc.SQLServerDriver jdbc.jdbcUrl=jdbc:sqlserver://localhost:1433; DatabaseName=PwdManagerTest jdbc.initialPoolSize=5 jdbc.maxPoolSize=10  然后在applicationContext.xml中添加\n\u0026lt;!-- 导入资源文件 --\u0026gt; \u0026lt;context:property-placeholder location=\u0026quot;classpath:db.properties\u0026quot; /\u0026gt; \u0026lt;!-- 配置 C3P0 数据源 --\u0026gt; \u0026lt;bean id=\u0026quot;dataSource\u0026quot; class=\u0026quot;com.mchange.v2.c3p0.ComboPooledDataSource\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;user\u0026quot; value=\u0026quot;${jdbc.user}\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;password\u0026quot; value=\u0026quot;${jdbc.password}\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;driverClass\u0026quot; value=\u0026quot;${jdbc.driverClass}\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;jdbcUrl\u0026quot; value=\u0026quot;${jdbc.jdbcUrl}\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;initialPoolSize\u0026quot; value=\u0026quot;${jdbc.initialPoolSize}\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;maxPoolSize\u0026quot; value=\u0026quot;${jdbc.maxPoolSize}\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;  这里会报一个错误：Error creating bean with name \u0026lsquo;dataSource\u0026rsquo; defined in class path resource [applicationContext.xml]:\u0026hellip;\n错误原因：缺少mchange-commons-java-0.2.3.4.jar包.\n作用：mchange-commons-java-0.2.3.4.jar包是c3p0数据库连接池的辅助包，如果没有这个包系统启动时会报classnotfoundexception，这是更新c3p0-0.9.2版本后分离出来的包，0.9.1的时候还是只是一个包.\n解决方法：导入mchange-commons-java-0.2.3.4.jar包即可.\n路径：Jar包文件\\C3P0\\C3P0-0.9-2.1JAR\\c3p0-0.9.2.1\\lib...\n 在Spring 的配置文件中配置:数据源dataSource,SessionFactory,声明式事务（先了解事务，包括事务隔离级别等）  \u0026lt;!-- 配置 SessionFactory --\u0026gt; \u0026lt;bean id=\u0026quot;sessionFactory\u0026quot;\tclass=\u0026quot;org.springframework.orm.hibernate4.LocalSessionFactoryBean\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;dataSource\u0026quot; ref=\u0026quot;dataSource\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;configLocation\u0026quot; value=\u0026quot;classpath:hibernate.cfg.xml\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;mappingLocations\u0026quot; value=\u0026quot;classpath:com/PwdManager/domain/*.hbm.xml\u0026quot; /\u0026gt; \u0026lt;/bean\u0026gt;  说明：执行到当前操作即可打开服务器，运行当前项目检测，正常情况下，不会报错，没有错误信息，而且在数据库中会生成对应的表结构. \n\u0026lt;!-- 配置 Spring 的声明式事务 --\u0026gt; \u0026lt;!-- 1. 配置 Hibernate 的事务管理器 --\u0026gt; \u0026lt;bean id=\u0026quot;transactionManager\u0026quot; class=\u0026quot;org.springframework.orm.hibernate4.HibernateTransactionManager\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;sessionFactory\u0026quot; ref=\u0026quot;sessionFactory\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 2. 配置事务属性 --\u0026gt; \u0026lt;tx:advice id=\u0026quot;txAdvice\u0026quot; transaction-manager=\u0026quot;transactionManager\u0026quot;\u0026gt; \u0026lt;tx:attributes\u0026gt; \u0026lt;tx:method name=\u0026quot;get*\u0026quot; read-only=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;tx:method name=\u0026quot;*\u0026quot;/\u0026gt; \u0026lt;/tx:attributes\u0026gt; \u0026lt;/tx:advice\u0026gt; \u0026lt;!-- 3. 配置事务切入点,再把事务属性和事务切入点关联起来 --\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;!-- 任一修饰符,任意返回值 ..下的所有类下的所有方法,参数值任意--\u0026gt; \u0026lt;aop:pointcut expression=\u0026quot;execution(* com.PwdManager.service.*.*(..))\u0026quot; id=\u0026quot;txPointcut\u0026quot;/\u0026gt; \u0026lt;!-- 把事务属性和事务切入点关联起来 --\u0026gt; \u0026lt;aop:advisor advice-ref=\u0026quot;txAdvice\u0026quot; pointcut-ref=\u0026quot;txPointcut\u0026quot;/\u0026gt; \u0026lt;/aop:config\u0026gt;  3. 加入 Stuts2 1) 加入 jar 包 　找到 Stuts2 的 jar 包文件夹，\\Jar包文件 \\Jar包文件\\Struts2.3.34\\struts-2.3.34\\apps\\struts2-blank\\WEB-INF\\lib路径下的所有 jar 包.\n xwork-core-2.3.34.jar struts2-spring-plugin-2.3.34.jar struts2-json-plugin-2.3.34.jar struts2-core-2.3.34.jar ognl-3.0.21.jar log4j-core-2.3.jar log4j-api-2.3.jar javassist-3.11.0.GA.jar freemarker-2.3.22.jar commons-lang3-3.2.jar commons-io-2.2.jar commons-fileupload-1.3.2.jar asm-tree-3.3.jar asm-commons-3.3.jar asm-3.3.jar  2) 在web.xml文件中配置Struts2的Filter \u0026lt;!-- 配置 Struts2 的 Filter --\u0026gt; \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;struts2\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt; org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter \u0026lt;/filter-class\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;struts2\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt;  3) 加入 Struts2 的配置文件 　可以拷贝例子下的struts.xml文件，例子可以在Jar包文件\\Struts2.3.34\\struts-2.3.34\\apps\\struts2-blank\\WEB-INF\\src\\java\\struts.xml文件参考.\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot; ?\u0026gt; \u0026lt;!DOCTYPE struts PUBLIC \u0026quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\u0026quot; \u0026quot;http://struts.apache.org/dtds/struts-2.3.dtd\u0026quot;\u0026gt; \u0026lt;struts\u0026gt; \u0026lt;constant name=\u0026quot;struts.enable.DynamicMethodInvocation\u0026quot; value=\u0026quot;false\u0026quot; /\u0026gt; \u0026lt;constant name=\u0026quot;struts.devMode\u0026quot; value=\u0026quot;true\u0026quot; /\u0026gt; \u0026lt;package name=\u0026quot;default\u0026quot; namespace=\u0026quot;/\u0026quot; extends=\u0026quot;struts-default\u0026quot;\u0026gt; \u0026lt;action name=\u0026quot;index\u0026quot;\u0026gt; \u0026lt;result type=\u0026quot;redirectAction\u0026quot;\u0026gt; \u0026lt;param name=\u0026quot;actionName\u0026quot;\u0026gt;HelloWorld\u0026lt;/param\u0026gt; \u0026lt;/result\u0026gt; \u0026lt;/action\u0026gt; \u0026lt;/package\u0026gt; \u0026lt;!-- Add packages here --\u0026gt; \u0026lt;/struts\u0026gt;  4) 整合 Spring ① 加入 Struts2 的 Spring 插件的 jar 包 struts2-spring-plugin-2.3.34.jar.\n② 在 Spring 的配置文件中正常配置 Action ,注意 Action 中需要配置 scope 属性为 prototype 不是单例的.\n\u0026lt;bean id=\u0026quot;XxxAction\u0026quot;\u0026gt; class=\u0026quot;\u0026quot; scope=\u0026quot;prototype\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;\u0026quot; ref=\u0026quot;\u0026quot; \u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 实例 --\u0026gt; \u0026lt;bean id=\u0026quot;userloginDao\u0026quot; class=\u0026quot;com.dao.userLoginDao\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;sessionFactory\u0026quot; ref=\u0026quot;sessionFactory\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026quot;userloginService\u0026quot; class=\u0026quot;com.service.userLoginService\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;userLoginDao\u0026quot; ref=\u0026quot;userloginDao\u0026quot;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026quot;userloginAction\u0026quot; class=\u0026quot;com.action.userLoginAction\u0026quot; scope=\u0026quot;prototype\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;userLoginService\u0026quot; ref=\u0026quot;userloginService\u0026quot;/\u0026gt;\t\u0026lt;/bean\u0026gt;  这里面需要注意的是：如果是在搭建初期只是为了测试是否成功，在创建对应的Package和Class后，在属性值为sessionFactory的Class下要创建sessionFactory的实例对象并设置setter方法，即\u0026lt;property name=\u0026quot;sessionFactory\u0026quot; ref=\u0026quot;sessionFactory\u0026quot;/\u0026gt;的\u0026lt;bean id=\u0026quot;userloginDao\u0026quot; class=\u0026quot;com.dao.userLoginDao\u0026quot;\u0026gt;需要在类userLoginDao下实例：private SessionFactory sessionFactory;并设置setter方法（可以带上getter方法），以下其他bean相同. （依赖注入相关知识）\n③ 在Struts2的配置文件中配置Action时,class 属性指向该 Action 在Spring IOC中的id.\n首先要定义拦截器 I. 在JSP页面如果没有采用Ajax可以直接使用以下action\n\u0026lt;action name=\u0026quot;XxxName\u0026quot; class=\u0026quot;XxxAction\u0026quot;\u0026gt; \u0026lt;result\u0026gt;/success.jsp\u0026lt;/result\u0026gt; \u0026lt;/action\u0026gt;  JSP\t页面form表单提交直接交给XxxName，即：\u0026lt;form action=\u0026quot;XxxName\u0026quot;\u0026gt; 这种情况需要接受的action中提供form表单中input的name所对应的getter和setter 然后可以直接获取到form表单中的值. II. 如果JSP页面使用了Ajax则需要使用以下action\n\u0026lt;action name=\u0026quot;userJson-*\u0026quot; class=\u0026quot;com.action.userJsonAction\u0026quot; method=\u0026quot;{1}\u0026quot;\u0026gt; \u0026lt;result name=\u0026quot;success\u0026quot; type=\u0026quot;json\u0026quot;\u0026gt; \u0026lt;param name=\u0026quot;root\u0026quot;\u0026gt;result\u0026lt;/param\u0026gt; \u0026lt;/result\u0026gt; \u0026lt;/action\u0026gt;  result为返回ajax的data数据\n这里需要注意的是在使用Ajax搭配Json实现数据的交互时，需要定义拦截器的时候继承json-default拦截器，同时继承两者也可以. 这里要是采用AJAX的方式，可能需要引入JSON的相关Jar包： 但是这里需要注意的是存在两种不同的JSON的Jar包，主要区别在于实现构造方法的变量不同.\n例如： √\nJSONObject json = new JSONObject(map);带参构造需要引入org.json.JSONObject; JSONObject json = new JSONObject(); 无参构造引入的是net.sf.json.JSONObject org.json.JSONObject类在json.jar包下—— \\Jar包文件\\JSON\\org.json net.sf.json.JSONObject其他包中—— \\Jar包文件\\JSON\\net.sf.json\n{\n commons-beanutils-1.7.0.jar commons-collections-3.2.1.jar commons-httpclient-3.1.jar commons-lang-2.3.jar commons-logging-1.1.1.jar ezmorph-1.0.3.jar json-lib-2.2.3-jdk15.jar  }\n获取ajax传过来的参数需要使用：\n// 用于获取data数据，定义request HttpServletRequest request = null; request = ServletActionContext.getRequest(); String UserID = request.getParameter(\u0026quot;UserID\u0026quot;);  实例：\n\u0026lt;struts\u0026gt;\t\u0026lt;constant name=\u0026quot;struts.i18n.encoding\u0026quot; value=\u0026quot;UTF-8\u0026quot;\u0026gt;\u0026lt;/constant\u0026gt; \u0026lt;constant name=\u0026quot;struts.enable.DynamicMethodInvocation\u0026quot; value=\u0026quot;false\u0026quot; /\u0026gt; \u0026lt;constant name=\u0026quot;struts.devMode\u0026quot; value=\u0026quot;true\u0026quot; /\u0026gt; \u0026lt;package name=\u0026quot;default\u0026quot; namespace=\u0026quot;/\u0026quot; extends=\u0026quot;json-default,struts-default\u0026quot;\u0026gt; \u0026lt;!-- 定义新的拦截器栈, 配置prepare拦截器栈的alwaysInvokePrepare参数值为false --\u0026gt; \u0026lt;interceptors\u0026gt; \u0026lt;interceptor-stack name=\u0026quot;sshStack\u0026quot;\u0026gt; \u0026lt;interceptor-ref name=\u0026quot;paramsPrepareParamsStack\u0026quot;\u0026gt; \u0026lt;param name=\u0026quot;prepare.alwaysInvokePrepare\u0026quot;\u0026gt;false\u0026lt;/param\u0026gt; \u0026lt;/interceptor-ref\u0026gt; \u0026lt;/interceptor-stack\u0026gt; \u0026lt;/interceptors\u0026gt; \u0026lt;!-- 使用新的拦截器栈 --\u0026gt; \u0026lt;default-interceptor-ref name=\u0026quot;sshStack\u0026quot;\u0026gt;\u0026lt;/default-interceptor-ref\u0026gt; \u0026lt;action name=\u0026quot;userJson-*\u0026quot; class=\u0026quot;com.action.userJsonAction\u0026quot; method=\u0026quot;{1}\u0026quot;\u0026gt; \u0026lt;result name=\u0026quot;success\u0026quot; type=\u0026quot;json\u0026quot;\u0026gt; \u0026lt;param name=\u0026quot;root\u0026quot;\u0026gt;result\u0026lt;/param\u0026gt; \u0026lt;/result\u0026gt; \u0026lt;/action\u0026gt; \u0026lt;/package\u0026gt;\t\u0026lt;/struts\u0026gt;  $.ajax({ url : \u0026quot;blogJson-readArticle\u0026quot;, type : \u0026quot;POST\u0026quot;,\tdata : { userID : \u0026quot;132\u0026quot;, artID : $(\u0026quot;input:hidden[name='artID']\u0026quot;).val() }, timeout : 30000, dataType : \u0026quot;json\u0026quot;,// 设置需要返回的数据类型 scriptCharset : 'utf-8', success : function(data) { var obj = $.parseJSON(data); var data = obj.data; }, error : function(XMLHttpRequest, textStatus, errorThrown) { alert(errorThrown + 123); } });  4. 完成功能 　具体方式可以按照自己的要求实施，大致方法： 在dao层可以直接管理有关数据库的一切方法，通过service层调用dao层的方法，在action层对service方法进行调用即可；这里需要注意一点，就是关于一些属性的设置问题，具体跟上述使用JSON时注意的事项一样.\n","date":1612051200,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1612051200,"objectID":"504fa6dda978566d8b6f66877141af40","permalink":"https://CoMath21.github.io/post/1-ssh%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88/","publishdate":"2021-01-31T00:00:00Z","relpermalink":"/post/1-ssh%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88/","section":"post","summary":"Spring+Struts+hibernate整合环境(Struts2.1.6、hibernate3.3.2、spring2.5.6)","tags":["编程语言","SSH","Java"],"title":"SSH框架整合基本步骤","type":"post"},{"authors":["Xin态好先生","CoMath"],"categories":["学习笔记","编程语言"],"content":"一、xml语法  文档声明  　用来声明xml的基本属性,用来指挥解析引擎如何去解析当前xml.通常一个xml都要包含并且只能包含一个文档声明.xml的文档必须在整个xml的最前面,在文档声明之前不能有任何内容.\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; ?\u0026gt; \u0026lt;!-- version是必须存在的属性,表明当前xml所遵循规范的版本,目前位置都写1.0就可以了. --\u0026gt; \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot; ?\u0026gt; \u0026lt;!-- encoding用来只会解析引擎在解析xml时使用的编码,一定要保证xml格式的数据在保存时使用的编码和解析时使用的编码必须一致,才不会有乱码问题. --\u0026gt; \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot; standalone=\u0026quot;yes\u0026quot; ?\u0026gt; \u0026lt;!-- standalone属性用来指明当前xml是否是一个独立的xml,默认值是yes表明当前文档不需要依赖于其他文档,如果当前文档依赖其他文档而存在则需要将此值设置为no. --\u0026gt;  元素   一个xml标签就是一个元素; 一个标签分为开始标签和结束标签; 在开始标签和结束标签之间可以包含文本内容,这样的文本内容叫做标签体; 如果标签的开始标签和结束标签之间不包含标签和子标签则可以将开始标签和结束标签进行合并,这样的标签就叫做自闭标签; 一个标签中也可以包含任意多个子标签,但是一定要注意标签一定要合理嵌套; 一个格式良好的xml要包含并且只能包含一个根标签,其他的标签都应该是这个标签的子孙标签;  注意\n 区分大小写，例如，\u0026lt;P\u0026gt;和\u0026lt;p\u0026gt;是两个不同的标记. 不能以数字或标点符号或\u0026quot;_\u0026ldquo;开头. 不能以xml(或XML、或Xml 等)开头. 不能包含空格. 名称中间不能包含冒号（:）.   属性 一个标签可以有多个属性，每个属性都有它自己的名称和取值，例如：\u0026lt;china capital=\u0026quot;beijing\u0026quot;/\u0026gt;. 属性的名在定义时要遵循和xml元素相同的命名规则;属性的值需要用单引号或双引号括起来.\n  注释\n  \u0026lt;!-- 注释内容 --\u0026gt;  注释可以出现在xml文档的任意位置除了整个文档的最前面.不能出现在文档声明之前;注释不能嵌套注释.\nCDATA区/转义字符  \u0026lt;![CDATA[转义的内容]]\u0026gt;\n 当XML中一段内容不希望被解析器解析时可以使用CDATA区将其包住; 当解析器遇到CDATA区时会将其内容当作文本对待，不会进行解析; 语法：\u0026lt;![CDATA[ 内容 ]]\u0026gt;.  转义字符:\n \u0026amp; \u0026ndash;\u0026gt; \u0026amp;amp; \u0026lt; \u0026ndash;\u0026gt; \u0026amp;lt;   \u0026ndash;\u0026gt; \u0026amp;gt;\n  \u0026quot; \u0026ndash;\u0026gt; \u0026amp;quot; ' \u0026ndash;\u0026gt; \u0026amp;apos;  处理指令  　处理指令，简称PI （processing instruction）. 处理指令用来指挥解析引擎如何解析XML文档内容.\n\u0026lt;?xml-stylesheet type=\u0026quot;text/css\u0026quot; href=\u0026quot;1.css\u0026quot;?\u0026gt;  二、dtd语法 \u0026mdash; 了解语法,看得懂dtd就可以  如何在xml中引入dtd  (1)外部引入\n　可以将dtd的约束内容写在外置的dtd文件中,这个文件后缀必须为.dtd而文件保存时必须用utf-8编码保存.　再在xml文件中使用 \u0026lt;!DOCTYPE 根元素名称 SYSTEM 文件的位置\u0026gt;\n　如果写的是SYSTEM表明当前引入的dtd在当前文件系统中,后面制定的文件位置是当前硬盘中的位置 \u0026lt;!DOCTYPE 文档根结点 PUBLIC \u0026quot;DTD名称\u0026quot; \u0026quot;DTD文件的URL\u0026quot;\u0026gt;\n　如果写的是PUBLIC表明当前引入的dtd在网络公共位置中,后面要指明dtd的名字和dtd所在网络位置URL地址.\n(2)内部引入\n　直接在xml中书写dtd\n \u0026lt;!DOCTYPE 根元素名称[ dtd约束.... ]\u0026gt;  dtd语法  (1)元素 \u0026lt;!ELEMENT 元素名称 元素约束\u0026gt;\n 元素约束: 存放类型:ANY/EMPTY. 元素约束:子元素的列表,将可以包含的子元素用小括号括起来  子元素之间可以使用逗号进行分割,表明子元素必须按照顺序出现 子元素之间可以使用竖线进行分割,表面子元素出现其中之一.    #PCDATA 表明包含标签体\n+ : 表示一次或多次;\n* : 0次或多次;\n? : 0次或一次.\n也可以使用小括号进行组的操作.\n(2)属性\n\u0026lt;!ATTLIST 元素名 属性名 属性类型 属性约束 属性名2 属性类型 属性约束 ...... \u0026gt;    属性类型:\n CDATA:表示属性的值是一个普通字符串 ENUMERATED : 属性的值是一个枚举列表中的值 ID: 表明属性的值必须在整个文档中都是唯一的,如果有重复的id则校验不通过,ID 属性的值只能由字母，下划线开始，不能使用数字，不能出现空白字符    属性约束:\n #REQUIRED \u0026mdash; 表明当前属性是一个必须存在的属性,如果这样的属性不存在则在校验时会报错 #IMPLIED \u0026mdash; 表明当前属性是一个可选的属性,可以有也可以没有 #FIXED \u0026lsquo;固定值\u0026rsquo; \u0026mdash; 表明当前属性具有一个固定值,这样的属性不需要进行赋值,自动就会取这个固定值为值.如果这样的属性指定了一个不是固定值的值则校验报错 \u0026lsquo;默认值\u0026rsquo; \u0026mdash; 表明当前属性具有一个默认值,如果给了其他的值就用其他值,如果没有给值则取这个默认值    (3)ENTITY(实体)\n\u0026lt;!ENTITY \u0026gt;,就是对一大段内容的引用,可以简化代码的复用.\n引用实体:在xml中引用的实体叫做引用实体\n\u0026lt;!ENTITY 实体名称 “实体内容” \u0026gt; \u0026amp;实体名称;  参数实体:在dtd中引用的实体叫做参数实体\n\u0026lt;!ENTITY % 实体名称 \u0026quot;实体内容\u0026quot;\u0026gt; %实体名称;  三、XML编程:利用java程序去增删改查(CRUD)xml中的数据 解析思想:\n dom解析 sax解析  基于这两种解析思想市面上就有了很多的解析api\n sun jaxp既有dom方式也有sax方式,并且这套解析api已经加入到j2se的规范中,意味这不需要导入任何第三方开发包就可以直接使用这种解析方式.但是这种解析方式效率低下,没什么人用. dom4j 可以使用dom方式高效的解析xml. pull  !!dom4j: 导入开发包,通常只需要导入核心包就可以了,如果在使用的过程中提示少什么包到lib目录下在导入缺少的包即可.\n四、Schema \u0026ndash; xml的约束技术 \u0026mdash; 需要掌握名称空间的概念,会读简单的Schema就可以了,不需要大家自己会写 　Schema是xml的约束技术,出现的目的是为了替代dtd. 本身也是一个xml,非常方便使用xml的解析引擎进行解析. 对名称空间有非常好的支持;支持更多的数据类型,并且支持用户自定义数据类型;可以进行语义级别的限定,限定能力大大强于dtd;相对于dtd不支持实体;相对于dtd复杂的多,学习成本比较的高.\n　如何在xml中引入Schema \u0026mdash; !!!!!名称空间的概念:全世界独一无二的名字,用来唯一的标识某个资源,通常是公司的域名,只是名字而已并不真的表示资源的位置.\nSchema的语法\u0026mdash;参照Schema的文档,了解即可\n","date":1612051200,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1612051200,"objectID":"960776ba8fc504faf823651334efed86","permalink":"https://CoMath21.github.io/post/1-xml%E7%AC%94%E8%AE%B0/","publishdate":"2021-01-31T00:00:00Z","relpermalink":"/post/1-xml%E7%AC%94%E8%AE%B0/","section":"post","summary":"XML的相关内容.","tags":["编程语言","XML"],"title":"XML学习笔记","type":"post"},{"authors":["Xin态好先生","CoMath"],"categories":["学习笔记","编程语言"],"content":"Ajax：Asynchronous javascript and xml （异步javascript和xml）.AJax 不是新的编程语言，而是一种使用现有标准的新方法.\n创建ajax对象：   主流浏览器方式： 火狐、Google、苹果Safari、opera包括IE7以上版本的浏览器 var xhr = new XMLHTTPRequest();\n  IE(6/7/8 )方式： var xhr = new ActiveObject(“Microsoft.XMLHTTP”);\t//最原始方式 var xhr = new ActiveObject(“Msxml2.XMLHTTP”); var xhr = new ActiveObject(“Msxml2.XMLHTTP.3.0”); var xhr = new ActiveObject(“Msxml2.XMLHTTP.5.0”); var xhr = new ActiveObject(“Msxml2.XMLHTTP.6.0”);\t//IE维护的最高版本\n  发起对服务器的请求\n  \u0026lt;script type=\u0026quot;\u0026quot;\u0026gt;\rfunction f() {\r//①创建ajax对象\rvar xhr = new XMLHttpRequest();\r//②创建新的http请求（并设置请求地址）\r//open(请求方式get/post，url请求地址)\rxhr.open(‘get’,’./xxx.php’);\r//③发送请求\r//send(get---null/post---给服务器传递的信息)\rxhr.send(null);\r}\r\u0026lt;/script\u0026gt;\r 接收服务器端返回的信息  ajax对象的成员\n 属性：   responseText：以字符串形式接收服务器端返回的信息.\n  readyState：\n刚创建ajax对象. 已经调用open方法. 已经调用send方法. 已经返回部分数据. 请求完成，数据返回完整.    onreadstatechange：事件，当ajax状态readState发生变化的时候处触发执行，为了获得较多的状态，最好在创建好阿加西对象后就设置.最多可以感知1/2/3/4 四种状态.\n   方法：  open(); 创建新的http请求. send(); 把请+ 求发送给服务器端.　    \u0026lt;script type=\u0026quot;\u0026quot;\u0026gt;\rfunction f() {\r//①创建ajax对象\rvar xhr = new XMLHttpRequest();\r//④ 给ajax设置事件\rxhr.onreadystatechange = function(){\r//console.log(xhr.readState);\rif(xhr.readyState==4){\r//console.log(xhr.responseText);\r//把服务端返回的信息显示在页面上\rdocument.getElementById(‘request’).innerHTML = xhr.responseText;\r}\r}\r//②创建新的http请求（并设置请求地址）\r//open(请求方式get/post，url请求地址)\rxhr.open(‘get’,’./xxx.php’);\r//③发送请求\r//send(get---null/post---给服务器传递的信息)\rxhr.send(null);\r}\r\u0026lt;/script\u0026gt;\r  get请求注意事项：\n①\t在url地址后面以请求字符串（传递的get参数信息）形式传递数据.\n②\t对中文、=、\u0026amp;等特殊符号处理.\n  对特殊信息的处理：\n　在浏览器里通过get参数传递一些特殊符号信息会被误解混淆，例如：=、\u0026amp;等.为了避免特殊符号被误解产生歧义，需要对其进行编码处理：在javascript里面可以通过encodeURLComponent()对特殊符号等信息进行编码;编码后的信息可以被正常接收使用，无需解码.\n post请求的注意事项：\n①\t给服务器传递数据需要调用send(请求字符串数据)方法; ②\t调用方法sentRequestHeader()把传递的数据组织为xml格式（模仿form表单传递数据）; ③\t传递的中文信息无需编码，特殊符号 \u0026amp;、=等仍需编码; ④\t该房是请求的同时也可以传递get参数信息，同样适用$_GRT 接受信息.\n  同步、异步\najax对象.open(方式get/post，url地址，[异步true]同步false);\n   异步：同一时间点允许执行多个线程. 同步：同一时间点只允许执行一个线程.   无刷新分页效果：\najax刷新无分页效果是对传统分页效果的封装;先将传统分页效果制作出来,在javascript代码块中定义函数，再创建ajax对象，创建事件，打开open，send，其中在创建事件的时候将加载后的信息显示到指定位置，为了实现分页跳转，则需要将url地址传给函数作为参数，其原因主要是因为分页效果其实就是实现的超链接，而ajax实现无刷新分页效果则是将超链接替换成定义的函数.   ajax对xml信息的接收和处理\najax负责请求xml和接收xml信息，都没负责处理xml信息;\ndom：javascript里，dom是负责javascript与html(xml)之间沟通的桥梁.\n  ajax对缓存的处理\n①\t给请求的地址设置随机数，即：保证每次请求的地址不一样； url?Math.random();\n②\t给动态程序设置header头信息，禁止浏览器对其缓存（PHP中这样设置）.\n  header(“Cache-Control:no-cache”)\rheader(“Pragma: :no-cache”)\rheader(“Expires:-1”)\r ","date":1611964800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1611964800,"objectID":"ac953194eea58abd82f41ac96f422ee3","permalink":"https://CoMath21.github.io/post/1-ajax%E7%AE%80%E4%BB%8B/","publishdate":"2021-01-30T00:00:00Z","relpermalink":"/post/1-ajax%E7%AE%80%E4%BB%8B/","section":"post","summary":"Ajax的快速入门.","tags":["Ajax"],"title":"Ajax简介","type":"post"},{"authors":["Xin态好先生","CoMath"],"categories":["学习笔记","经验分享"],"content":"","date":1611964800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1611964800,"objectID":"c58309501e24068e9525fa4fb9f6f459","permalink":"https://CoMath21.github.io/post/3-hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","publishdate":"2021-01-30T00:00:00Z","relpermalink":"/post/3-hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","section":"post","summary":"HuGo搭建个人博客心得.","tags":["HuGo","博客"],"title":"HuGo搭建个人博客","type":"post"},{"authors":["Xin态好先生","CoMath"],"categories":["学习笔记","编程语言"],"content":"为什么要JSP技术? 　开发web网站的时候，servlet做界面比较麻烦. JSP 是基于 Servlet API 的，所以拥有 Servlet 拥有的一系列好处.\n jsp运行在服务器端 jsp（java service page） jsp的基础是servlet jsp是一个综合技术 jsp=html+css+javascript+java代码+jsp标签(Servlet) jsp无需配置，可以直接使用；如果修改了jsp文件，不需要重新reload web应用 jsp访问方法：http://ip:8080/web应用名/jsp路径  特点：\n 内容的生成和显示相分离 可移植性 采用标签简化页面开发 使用可重用组件 完善的存储管理和安全性   JSP语法基础： 基本元素： 注释(JSP自带的注释规范是隐式注释,HTML/XML的注释是显示注释) HTML/XML的注释(显示注释)：\n\u0026lt;!-- 个注释 --\u0026gt; \u0026lt;!-- 个注释 ：\u0026lt;%counter++;%\u0026gt;--\u0026gt;  这里会对counter++进行编译,显示编译后的结果 隐式注释：\n\u0026lt;%-- 注释 --%\u0026gt;  JSP在编译时不会对\u0026lt;%\u0026ndash;和\u0026ndash;%\u0026gt;中的进行编译;\nScriptlets中的注释：跟java注释一致.  指令元素  页面(page)指令： 页面page指令用于定义JSP文件中的全局属性,一个JSP页面可以包含多个页面指令.除了import指令外其他的页面指令定义的属性或值只能出现一次.  \u0026lt;%@ page attribute=\u0026quot;value\u0026quot;%\u0026gt;  其中attribute的可取值为：\n language(定义使用的脚本\u0026mdash;语言默认java)、import(定义JSP网页使用的java API)、 contentType(定义MIME类型和JSP网页的编码方式—默认TYPE=text/html CHARSET=iso-8859-1)、 pageEncoding(JSP页面的字符编码\u0026mdash;默认pageEncoding=\u0026ldquo;iso-8859-1\u0026rdquo;)、 区别：contentType—pageEncoding.  contentType：只能指定网页以什么方式显示 pageEncoding：除了显示之外还可以以指定形式保存   session(定义该JSP网页是否可以使用session对象—-默认true)、 buffer(指定客户输出流的缓冲模式,如果是none,则不缓冲,如果指定数值,就定义了缓冲区的大小)、默认8K autoFlush(定义输出流的缓存区是否要自动清除-—默认true)、 isThreadSafe(定义该JSP页面是否能处理多个请求\u0026mdash;默认true)、 info(定义该JSP网页的相关信息-—默认忽略)、 errorPage(定义此页面出现意外时的调用的页面—-默认忽略)、跳转到错误页面 isErrorPage(定义该JSP网页是否为处理意外错误的网页—-默认false)、 extends().   include指令： include指令通知容器在当前JSP页面中指定位置包含另一个文件的内容. 被包含的文件内容可以被JSP引擎解析,这种解析发生在编译期间 \u0026lt;%@ include file=\u0026ldquo;filename\u0026rdquo;%\u0026gt; include只有这一个属性. 其中filename为包含的文件路径,一般来说是指相对路径. 由于被包含的内容常常是代码片断,因此代码片断的后缀名最好以“f”(表示fragment)结尾,例如.htmlf 标签库taglib指令： taglib指令允许页面使用者自定义标签. 先用户开发标签库，为标签库编写.tld配置文件，然后再JSP页面使用自定义标签. \u0026lt;%@ taglib uri=\u0026ldquo;URL\u0026rdquo; prefix=\u0026ldquo;tagPrefix\u0026rdquo;%\u0026gt; uri 用来表示标签描述符，也就是如何找到标签文件和标签库； tagPrefix 定义了子JSP页面里引用这个标签的前缀.  脚本元素  声明(Declaration) 声明就是在JSP程序中声明合法的变量和方法,用\u0026lt;%!和%\u0026gt;来表示)： 当代码只用于单一页面时：  \u0026lt;%! variable declaration; method declaration(paramType param,...) %\u0026gt; \u0026lt;%! private static int counter; public void counterInit(){ counter = 0 ; }; %\u0026gt;   表达式(Expression)—用来吧java数据直接插入到输出：  表达式是位于\u0026lt;%=和%\u0026gt;之间的代码\n\u0026lt;%= \u0026quot;你是第\u0026quot;+counter+\u0026quot;次访问\u0026quot; %\u0026gt; \u0026lt;%= \u0026quot;hello world\u0026quot; %\u0026gt;  Web服务器将其编译成Servlet后，变成：\nout.wreite(String.valueOf(\u0026quot;hello world\u0026quot;));  相当于JSP页面中的：\nout.println(\u0026quot;hello world\u0026quot;);  注：表达式结束处可以不使用省略号，表达式可以包含表达式.\n 脚本小程序(Scriptlet)\u0026mdash;可以在处理请求时间执行的java代码：  Scriptlet则位于\u0026lt;%和%\u0026gt;之间,他们是合法的java代码 \u0026lt;%counter++;%\u0026gt;\n动作元素 　JSP规范定义了一系列的标准动作. 以jsp作为前缀,例如使用JavaBean的动作元素\u0026lt;jsp:useBean\u0026gt;\n\u0026lt;!-- 格式： --\u0026gt; \u0026lt;jsp:tag attribute=value attribute=value.../\u0026gt; \u0026lt;!-- 或者 --\u0026gt; \u0026lt;jsp:tag attribute=value attribute=value...\u0026gt; ... \u0026lt;/jsp:tag\u0026gt;  动作元素是在请求处理阶段起作用的.\n 文本导入标签\u0026lt;jsp:include\u0026gt;  \u0026lt;!-- 格式： --\u0026gt; \u0026lt;jsp:include page=\u0026quot;filename\u0026quot; flush=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;!-- 或者 --\u0026gt; \u0026lt;jsp:include page=\u0026quot;filename\u0026quot; flush=\u0026quot;true\u0026quot;\u0026gt; \u0026lt;jsp:param name=\u0026quot;paramName\u0026quot; value=\u0026quot;paramValue\u0026quot;/\u0026gt; ... \u0026lt;/jsp:include\u0026gt;  　\u0026lt;jsp:param\u0026gt;用于传递一个或者多个参数给动态页面;\u0026lt;jsp:include\u0026gt;动作与\u0026lt;%@include%\u0026gt;指令的不同是：前者包含的内容可以是动态改变的，它在执行时才确定；而后者包含的内容是固定不变的，在编译阶段就已经确定而不能改变.\n案例：Login.html、Ex1.jsp、Ex2.jsp\n 页面转发标签\u0026lt;jsp:forward\u0026gt;该操作允许将请求转发到另一个JSP、Servlet或者其他静态资源文件. 请求被转至的资源必须位于同JSP发送请求相同的上下文环境之中. 每当遇到\u0026lt;jsp:forward\u0026gt;操作时，就停止执行当前的JSP，转至执行被转发的资源.  \u0026lt;!-- 格式： --\u0026gt; \u0026lt;jsp:forward page=\u0026quot;uri\u0026quot;/\u0026gt; \u0026lt;!-- 或者 --\u0026gt; \u0026lt;jsp:forward\u0026gt; \u0026lt;jsp:param name=\u0026quot;paramName\u0026quot; value=\u0026quot;paramValue\u0026quot;/\u0026gt; ... \u0026lt;/jsp:forward\u0026gt;  其中page=\u0026ldquo;uri\u0026rdquo; 指明将要定向的文件或url地址,\u0026lt;jsp:param name=\u0026quot;paramName\u0026quot; value=\u0026quot;paramValue\u0026quot;/\u0026gt;中name指定参数名，value指定参数值. 参数被发送到一个动态文件，参数可以是一个或多个值，而这个文件却必须是动态文件.\n案例：Ex3.jsp、Ex4.jsp、Ex5.jsp\n 实例化JavaBean标签jsp:useBean  \u0026lt;!-- 格式： --\u0026gt; \u0026lt;jsp:useBean id=\u0026quot;id\u0026quot; scope=\u0026quot;page|request|session|application typeSpec\u0026quot;/\u0026gt; \u0026lt;!-- id 是大小写相关的名字,用来表示这个实例;scope表示此对象作用的范围；typeSpace可以是以下四者之一：class=\u0026quot;className\u0026quot; --\u0026gt; class=\u0026quot;className\u0026quot; type=\u0026quot;typeName\u0026quot; beanName=\u0026quot;beanName\u0026quot; type=\u0026quot;typeName\u0026quot; type=\u0026quot;typeName\u0026quot;  scope表示Bean的作用域，此属性是可选的，默认是page.\n① page： 能够在包含\u0026lt;jsp:useBean\u0026gt;标签的JSP文件以及此文件中的所有静态包含文件中使用Bean，直到页面执行完毕客户端发回响应或转到另一个文件为止. 超出这个范围Bean就失效了.\n② request： 如果该Bean不是请求上下文的一部分，将在请求上下文中创建并保存该Bean.\n③ session： 从创建Bean开始，就开始在session有效范围内使用这个Bean，这个Bean对于JSP来说是共享的. 但在创建Bean的JSP文件里，page指令必须指定session=True.\n④ application： 如果此Bean尚不存在于Web应用程序上下文中，则在应用程序上下文中创建并储存此Bean. application对象在应用服务器启东市就创建了，直到应用服务器关闭. 这个Bean存在于整个application生命周期内，任何在此分享application的JSP文件都能使用同一个Bean. class=\u0026ldquo;className\u0026quot;代表的是Bean的类路径和类名. 这个class不是抽象的，必须有一个公用的、没有参数的构造器. beanName=\u0026ldquo;beanName\u0026rdquo; 表示Bean的名称，而Type=\u0026ldquo;typeName\u0026quot;则用于指定Bean的类型. type=\u0026ldquo;typeName\u0026quot;指定雷鸣，既可以是本身，也可以是一个类的父类，或者是一个类的接口. 如果没有使用class或者BeanName指定type，Bean将不会被实例化.\n 设置JavaBean属性标签\u0026lt;jsp:setProperty\u0026gt; 该动作主要用于设定JavaBean的属性，因此必须和useBean一起协作. \u0026lt;jsp:setProperty\u0026gt;标签通过JavaBean给定的setXXX()方法，在javaBean中设置一个或多个属性值. 利用此动作标签设置属性值有多种方法：  \u0026lt;!-- 格式： --\u0026gt; \u0026lt;jsp:setProperty name=\u0026quot;beanInstanceName\u0026quot; propertyDetails/\u0026gt;  其中beanInstanceName是必选属性，即JavaBean实例的名字，在使用前通过\u0026lt;jsp:useBean\u0026gt;引入. propertyDetails指可以通过三种不同的方式来指定属性信息：\n property=\u0026quot;*\u0026quot;: 这种赋值方式表示请求参数的所有值. 在Bean中的属性名字必须和Request对象中的参数名一致. property=\u0026ldquo;propertyName\u0026rdquo;[param=\u0026ldquo;parameterName\u0026rdquo;]: 这种赋值方式使用request中的一个参数值来指定Bean中的一个属性值. property指定Bean的属性名，param指定request中的参数名. 如果Bean属性和request参数的名字不同，name就必须指定property和param的值；若果同名，则需要指明property就可以了. 参数值为空，那么对应的属性值也不会被设定. property=\u0026ldquo;propertyName\u0026rdquo; value=\u0026ldquo;propertyValue\u0026rdquo;: 这种赋值方式使用指定的值来设定Bean属性. propertyValue可以是字符串也可以是表达式. 如果是字符串，那么他就会被转换成Bean属性类型. 如果是表达式，那么它的类型就必须和它将要设定的属性值类型保持一致. 注：不能在一个\u0026lt;jsp:setProperty\u0026gt;中同时使用param和value.   获取JavaBean对象属性标签\u0026lt;jsp:getproperty\u0026gt; 与\u0026lt;jsp:setproperty\u0026gt;相对应，访问一个JavaBean属性，因此使用该动作标签之前必须用\u0026lt;jsp:useBean\u0026gt;引入一个JavaBean对象.  \u0026lt;!-- 格式： --\u0026gt; \u0026lt;jdp:getProperty name=\u0026quot;beanInstanceName\u0026quot; property=\u0026quot;propertyName\u0026quot;/\u0026gt;  其中beanInstanceName对应\u0026lt;jsp:useBean\u0026gt;的id，因此name要和\u0026lt;jsp:useBean\u0026gt;的id相同. propertyName是要获得的属性值.\nc.d.e.的案例：Zhuce.jsp、Ex6.jsp、StudentBean.java\n 追加参数标签\u0026lt;jsp:param\u0026gt; ＼jsp:param标签用来提供key/value的值，与jsp:inclde、jsp:forwadrd等标签一起搭配使用.  \u0026lt;!-- 格式： --\u0026gt; \u0026lt;jsp:param name=\u0026quot;parameterName\u0026quot; value=\u0026quot;parameterValue\u0026quot;/\u0026gt;  name=\u0026ldquo;parameterName\u0026rdquo; ：该属性表示参数的名字 value=\u0026ldquo;parameterValue\u0026rdquo;：表示参数的值．\nServlet容器概念 　Servlet容器为Java_Web应用提供运行时环境,它负责管理Servlet和JSP的生命周期,以及管理他们的共享数据. Servlet容器也称为Java_Web应用容器,或者Servlet/JSP容器．\n流行的Servlet容器软件\n —Tomcat —Resin   部署tomcat服务器：  解压文件apache-tomcat 启动：startup.bat\u0026mdash;\u0026mdash;启动服务器 需要配置环境：JAVA_HOME java jdk的根目录 想在任意目录下打开服务器  设置环境CATALINA_HOME\u0026mdash;-bin/catalina.bat Tomcat的管理程(manager)：要访问manager web应用程序,需要添加具有管理员权限的账号,编辑conf目录下的tomcat-users.xml文件,添加manager角色设置用户名密码    第一个web程序：   在Eclipse新建一个Java Project\n  在Java项目下创建Web开发的目录结构   在WebContent目录下新建一个JSP文件：\n  把WebContent 目录复制到Tomcat的webapps目录下\n  最后在浏览器打开\n  JavaEEn版 Eclipse开发web  显切换到JavaEE Servers下新建一个Tomcat服务器\u0026ndash;\u0026gt;关联到Tomcat根目录 新建一个Dynamic Web Project 其中Target Runtime需选中 开发应用 可以通过run so server 来运行WEB项目  Servlet 的HelloWorld  创建一个Servlet接口的实现类  public class HelloWorld implements Servlet  在web.xml 文件中配置和映射这个Servlet  \u0026lt;!-- 配置和映射Servlet --\u0026gt; \u0026lt;Servlet\u0026gt; \u0026lt;!—Servlet 注册的名字 –\u0026gt; \u0026lt;servlet-name\u0026gt;类名\u0026lt;/servlet-name\u0026gt; \u0026lt;!—Servlet 的全类名 --\u0026gt; \u0026lt;servlet-class\u0026gt;包名\u0026lt;/servlet-class\u0026gt; \u0026lt;/Servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;!—需要和某一个Servlet 节点的servlet-name 子节点的文本节点一致–\u0026gt; \u0026lt;servlet-name\u0026gt;类名\u0026lt;/servlet-name\u0026gt; \u0026lt;!—映射具体的访问路径：/代表当前WEB应用的根目录 –\u0026gt; \u0026lt;url-pattern\u0026gt;/hello\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt;  关于servlet-mapping：  同一个Servlet可以被映射到多个URL上,即多个元素的子元素的设置值可以是同一个Servlet的注册名. 在Servlet映射到的URL中也可以使用通配符,但是只能有两种固定的格式：一种格式是“.扩展名”,另一种格式是以正斜杠（/）开头并以“/*”结尾.  Servlet 容器：  可以创建Servlet,并调用Servlet的相关生命周期 JSP,Filter,Listener  Servlet 生命周期方法：以下方法都是Servlet容器负责调用  构造器：只被调用一次,只有第一次请求Servlet时,创建Servlet的实例,调用构造器,这说明Servlet是单实例的. init方法：只被调用一次,在创建好的实例后即被调用,用于初始化当前Servlet. service：被多次调用. 每次请求都会调用service方法,实际响应请求的. destroy：只被调用一次,在当前Servlet所在的Web应用被卸载前调用,用于释放当前的Servlet所占用的资源  loda-on-start-up参数：  配置在servlet节点中  \u0026lt;Servlet\u0026gt; \u0026lt;!—Servlet 注册的名字 –\u0026gt; \u0026lt;servlet-name\u0026gt;类名1\u0026lt;/servlet-name\u0026gt; \u0026lt;!—Servlet 的全类名 --\u0026gt; \u0026lt;servlet-class\u0026gt;包名\u0026lt;/servlet-class\u0026gt; \u0026lt;!—可以指定Servlet 被创建的时机 --\u0026gt; \u0026lt;load-on-startup\u0026gt;2\u0026lt;/load-on-startup\u0026gt; \u0026lt;/Servlet\u0026gt;  load-on-startup：可以指定Servlet被创建的时机.如为负数,则在第一次请求时创建;若为0或正数,则在当前WEB应用被Servlet 容器加载时创建实例,且越小越早被创建.  ","date":1611964800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1611964800,"objectID":"6fd502dd477256f5c1ebe46e2c0c1410","permalink":"https://CoMath21.github.io/post/1-jsp%E7%AE%80%E4%BB%8B/","publishdate":"2021-01-30T00:00:00Z","relpermalink":"/post/1-jsp%E7%AE%80%E4%BB%8B/","section":"post","summary":"Java Server Pages快速入门.","tags":["Java","JSP"],"title":"JSP简介","type":"post"},{"authors":["Xin态好先生","CoMath"],"categories":["学习笔记","编程语言"],"content":"什么是node.js  node.js是一个开发平台，就像Java开发平台、.Net开发平台、PHP开发平台、Apple开发平台一样。 -何为开发平台？有对应的编程语言、有语言运行时、有能实现特定功能的API（SDK:Software Development Kit） 该平台使用的编程语言是Javascript 语言。 node.js平台是基于Chrome V8 Javascript引擎构建。 基于node.js可以开发控制台程序（命令行程序、CLI程序）、桌面应用程序（GUI）（借助 node-webkit、electron等框架实现）、Web应用程序（网站）  PHP开发技术栈：LAMP-Linux Apache MySQL PHP\nnode.js全栈开发技术栈：MEAN-MongoDB Express Angular Node.js\nnode.js有哪些特点？  事件驱动（当事件被触发时，执行传递过去的回调函数） 非阻塞I/0模型（当执行I/0操作时，不会阻塞线程） 单线程 拥有世界最大的开源库生态系统一npm。  node.js网站  [node.js官方网站]（https://nodejs.org/） [node.js中文网]（http://nodejs.cn/） [node.js中文社区]（https://cnodejs.org/）  为什么要学习Node.js？  通过学习Node.js开发深入理解服务器开发、*Web请求和响应过程、*了解服务器端如何与客户端配合 学习服务器端渲染 学习服务器端为客户端编写接口 现在前端工程师面试，对Node.js开发有要求 补充提问： -在Node.js平台开发时，能使用Dom API吗？比如：document.getElementById（\u0026lsquo;id\u0026rsquo;）；window.location等？ 复习浏览器端JavaScript 组成：ECMAscript、Dom、Bom  学习目标  了解服务器开发过程 会使用node.js开发基本的http服务程序（Web应用程序）  Node.js安装和配置  下载地址   [当前版本]（https://nodejs.org/en/download/） [历史版本]（https://nodejs.org/en/download/releases/）  官网术语解释   LTS版本：Long-term Support版本，长期支持版，即稳定版。 Current 版本：Latest Features版本，最新版本，新特性会在该版本中最先加入。  注意：   安装完毕后通过命令：node-v来确定是否安装成功【注意：打开“命令窗口”的时候建议使用“管理员方式“打开】 如果需要则配置环境变量。 ！ [配置环境变量]（imgs/env_pathpng）  通过nvm-windows管理一台计算机上的多个node版本  Node Version Manager（Node 版本管理器） nvm（Linux、Unix、OS-X）   https://github.com/creationix/nvm\n  产用命令：\n    nvm-install-node（安装最新版本的node）\n  nvm-use node-（使用指定版本的node）\n  nvm-windows·（Windows）   https://github.com/coreybutler/nvm-windows\n  常用命令：\n  nvm-version\nnvm-install-latest\nnvm-instal1-版本号\nnvm-uninstall版本号\nnvm-list\nnvm-use 版本号 #在node.js上编写程序 ##REPL介绍\n REPL全称：Read-Eval-Print-Loop（交互式解释器）   R 读取-读取用户输入，解析输入了Javascript 数据结构并存储内存中。 E 执行-执行输入的数据结构 P 打印-输出结果 L循环-循环操作以上步骤直到用户两次按下ctrl-c按钮退出。  在REPL中编写程序（类似于浏览器开发人员工具中的控制台功能）   直接在控制台输入node命令进入REPL环境  按两次Control+C退出REPL界面或者输入exit退出REPL界面   按住control键不要放开，然后按两下c键 ##创建JavaScript文件编写程序 ###编程注意事项 配置一下Sublime Text的代码缩进格式为2个空格 方式一  ！[@配置方式1]（imgs/sublimeconf1.png）\n 方式二  ！[@配置方式2-第一步]（imgs/sublimeconf21.png）\n！[配置方式2-第二步]（imgs/sublimeconf22.png） ##写入文件操作\n //执行文件操作\n//\u0026mdash;\u0026mdash;\u0026mdash;-实现文件写入操作\u0026ndash;\n//1.加载文件操作模块，fs模块。\nvar fs=require（\u0026lsquo;fs\u0026rsquo;）；\n//2.实现文件写入操作\nvar msg=\u0026lsquo;Hello world，你好世界！’；\n//调用fs.writeFile（）进行文件写入\n//fs.writeFile（file，datal，options]，callback）\nfs.writeFile（\u0026rsquo;./hello.txt'，msg，\u0026lsquo;utf8\u0026rsquo;，function（err）{\n//body..\n//如果err===null，表示写入文件成功，没有错误！\n//只要err里面不是null，就表示写入文件失败了！\nif（err）{\nconsole.1og（\u0026lsquo;写文件出错啦！具体错误：‘+err）；\n}else{\nconsole.log（\u0026lsquo;ok\u0026quot;）；\n} }）；\n ##读取文件操作\n //\u0026mdash;\u0026mdash;\u0026mdash;-实现文件写入操作\u0026ndash; //1.加载文件操作模块，fs模块。\nvar fs=require(\u0026lsquo;fs\u0026rsquo;)；\n调用fs.readFile（）方法来读取文件\n//fs.readFile（filel，options]，callback）\nfs.readFile（\u0026rsquo;./hello.txt\u0026rsquo;，function-（err，-data）-{\nif(err){ throw-err；}\n//data参数的数据类型是一个Buffer对象，里面保存的就是一个一个的字节（理解为字节数组）\n//把buffer对象转换为字符串，调用tostring（）方法\n//console.log（data）；console.log（data.toString （\u0026lsquo;utf8\u0026rsquo;））; }）;\n  注意: //此处的./相对路径，相对的是执行node命令的路径\n//而不是相对于正在执行的这个js文件来查找hello.txt\n//解决在文件读取中./相对路径的问题\n//解决：dirname、filename\n//dirname：表示，当前正在执行的js文件所在的目录\n//filename：表示，当前正在执行的js文件的完整路径\n 路径拼接：path.join('/foo',\u0026lsquo;bar\u0026rsquo;,'/ad','\u0026hellip;');  HTTP服务程序  //创建一个简单的http服务器程序\n//1.加载http模块\nvar http=require（\u0026lsquo;http\u0026rsquo;）；\n//2.创建一个http服务对象\nvar server=http.createServer（）；\n//3.监听用户的请求事件（request事件）\n//request 对象包含了用户请求报文中的所有内容，通过request对象可以获取所有用户提交过来的数据\n//response 对象用来向用户响应一些数据，当服务器要向客户端响应数据的时候必须使用response.对象\n//有了request对象和response对象，就既可以获取用户提交的数据，也可以向用户响应数据了 server.on（\u0026lsquo;request\u0026rsquo;，function（re4，res）{\n//body\u0026hellip;\n//解决乱码的思路：服务器通过设置http响应报文头，告诉浏览器使用相应的编码来解析网页res.setHeader(\u0026lsquo;Content-Type\u0026rsquo;,\u0026lsquo;text/plain;charset=utf-8\u0026rsquo;)； res.write（\u0026lsquo;Hello world！！！！'）；\n//对于每一个请求，服务器必须结束响应，否则客户端（浏览器）会一直等待服务器响应结束\nres.end（）; }）;\n  //4.启动服务\nserver.listen(8080，function(){ console.1og(\u0026lsquo;服务器启动了，请访问：http://1ocalhost：8080\u0026rsquo;； });\n 获取用户请求路径  req.url\n通过 req.url 后区用户请求的路径，根据不同请求作出不同的响应   if(req.url === \u0026lsquo;/\u0026rsquo; || req.u === \u0026lsquo;/index\u0026rsquo;){\nres.end(\u0026lsquo;Hello World\u0026rsquo;);\n}else if(\u0026rsquo;\u0026hellip;'){\n  }\n ###根据用户不同请求相应不同页面\n var http=require(\u0026lsquo;http\u0026rsquo;);\n//加载fs模块\nvar fs=require(\u0026lsquo;fs\u0026rsquo;);\n//加载path模块\nvar path=require(\u0026lsquo;path\u0026rsquo;);\n//创建http服务，并启动该服务\nhttp.createServer(function(req，res){\n//通过req.url获取用户请求的路径，根据不同的请求路径服务器做出不同的响应\nif(req.url==='/'|| req.url===\u0026quot;/index'){\n//读取index.html文件\nfs.readFile（path.join(__dirname, \u0026lsquo;htmls\u0026rsquo;, \u0026lsquo;index.html\u0026quot;), function(err, data){\nif(err){\nthrow err;\n//把读取到的index.html中的内容直接发送给浏览器\nres.end(data);\n});\n}else if(req.url-==·\u0026quot;/login)}else if(req.url-==·\u0026quot;/list)\n}else if(req.url===\u0026quot;/register\u0026rsquo;){\n}else{\n}).listen（9090，function(){\nconsole.1log(\u0026lsquo;http://1ocalhost:9090\u0026rsquo;)；\n});\n ","date":1611964800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1611964800,"objectID":"c07e9ee97bc8fff1eaf5c095f2a5e152","permalink":"https://CoMath21.github.io/post/1-node.js/","publishdate":"2021-01-30T00:00:00Z","relpermalink":"/post/1-node.js/","section":"post","summary":"node.js介绍 .","tags":["编程语言","Node"],"title":"node.js介绍(一)","type":"post"},{"authors":["Xin态好先生","CoMath"],"categories":["学习笔记","编程语言"],"content":"1、什么是Spring 　Spring是一个开源的控制反转(Inversion of Control,IoC)和面向切面(AOP)的容器框架，它的主要目的是简化企业开发. 用于配置bean,并维护bean之间关系的框架.\n　在SSH框架中spring充当了管理容器的角色. 我们都知道Hibernate用来做持久层，因为它将JDBC做了一个良好的封装，程序员在与数据库进行交互时可以不用书写大量的SQL语句. Struts是用来做应用层的，他它负责调用业务逻辑serivce层. 所以SSH框架的流程大致是：Jsp页面\u0026mdash;-Struts\u0026mdash;\u0026mdash;Service（业务逻辑处理类）\u0026mdash;Hibernate（左到右）. Struts负责控制Service（业务逻辑处理类），从而控制了Service的生命周期，这样层与层之间的依赖很强，属于耦合. 这时，使用spring框架就起到了控制Action对象（Strus中的）和Service类的作用，两者之间的关系就松散了，Spring的Ioc机制（控制反转和依赖注入）正是用在此处.\n　Spring的Ioc（控制反转和依赖注入）\n　控制反转：就是由容器控制程序之间的（依赖）关系，而非传统实现中，由程序代码直接操控. 应用本身不负责以来对象的而创建和维护，以来对象的创建和维护是由外部容器负责的. 这样控制权就有应用转到了外部容器，控制权的转移就是所谓反转.\n　依赖注入：组件之间的依赖关系由容器在运行期决定 ，由容器动态的将某种依赖关系注入到组件之中 .\n2、为什么要使用Spring（Spring的好处）  降低组建之间的耦合度，实现软件隔层之间的解耦； 可以使用容器提供的众多服务，如：事务管理服务、消息服务等等. 当我们使用容器管理服务时，开发人员就不在需要手工控制事务，也不需要处理复杂的事务传播； 容器提供单例模式支持，开发人员不需要自己编写实现代码； 容器提供AOP技术，利用这些类能够够加快应用的开发，如：JdbcTemplate、HibernateTemplate； Spring对于主流的应用框架提供了集成支持，如：集成Hibernate、JPA、Struts等，这样更便于应用开发.  轻量级与重量级概念的区分\n　主要看它使用了多少服务，使用服务越多，容器为java对象做的工作就越多，必然会影响到应用的发布时间或者运行性能.\n　对于Spring容器，它提供了很多服务，但这些服务并不是默认应用打开的，应用需要某种服务，还需要知名使用该服务，如果应用使用的服务很少，如：只是用了Spring的核心服务，那么我们可以认为此时应用属于轻量级的，如果使用了Spring提供的大部分服务，这时应用属于重量级的，目前EJB容器就因为它默认为应用提供了EJB规范中的所有功能，所以它属于重量级的.\n3、配置spring所需要的jar包 　spring.jar是包含有完整发布的单个jar 包，spring.jar中包含除了spring-mock.jar里所包含的内容外其它所有jar包的内容，因为只有在开发环境下才会用到 spring-mock.jar来进行辅助测试，正式应用系统中是用不得这些类的.\n　除了spring.jar文件，Spring还包括有其它13个独立的jar包，各自包含着对应的Spring组件，用户可以根据自己的需要来选择组合自己的jar包，而不必引入整个spring.jar的所有类文件.\n spring-core.jar：这个jar文件包含Spring框架基本的核心工具类，Spring其它组件要都要使用到这个包里的类，是其它组件的基本核心，当然你也可以在自己的应用系统中使用这些工具类. spring-beans.jar：这个jar文件是所有应用都要用到的，它包含访问配置文件、创建和管理bean以及进行Inversion of Control / Dependency Injection（IoC/DI）操作相关的所有类. 如果应用只需基本的IoC/DI支持，引入spring-core.jar及spring-beans.jar文件就可以了. spring-aop.jar：这个jar文件包含在应用中使用Spring的AOP特性时所需的类. 使用基于AOP的Spring特性，如声明型事务管理（Declarative Transaction Management），也要在应用里包含这个jar包. spring-context.jar：这个jar文件为Spring核心提供了大量扩展. 可以找到使用Spring ApplicationContext特性时所需的全部类，JDNI所需的全部类，UI方面的用来与模板（Templating）引擎如Velocity、FreeMarker、JasperReports集成的类，以及校验Validation方面的相关类. spring-dao.jar：这个jar文件包含Spring DAO、Spring Transaction进行数据访问的所有类. 为了使用声明型事务支持，还需在自己的应用里包含spring-aop.jar. spring-hibernate.jar：这个jar文件包含Spring对Hibernate 2及Hibernate 3进行封装的所有类. spring-jdbc.jar：这个jar文件包含对Spring对JDBC数据访问进行封装的所有类. spring-orm.jar：这个jar文件包含Spring对DAO特性集进行了扩展，使其支持 iBATIS、JDO、OJB、TopLink，因为Hibernate已经独立成包了，现在不包含在这个包里了. 这个jar文件里大部分的类都要依赖spring-dao.jar里的类，用这个包时你需要同时包含spring-dao.jar包. spring-remoting.jar：这个jar文件包含支持EJB、JMS、远程调用Remoting（RMI、Hessian、Burlap、Http Invoker、JAX-RPC）方面的类. spring-support.jar：这个jar文件包含支持缓存Cache（ehcache）、JCA、JMX、邮件服务（Java Mail、COS Mail）、任务计划Scheduling（Timer、Quartz）方面的类. spring-web.jar：这个jar文件包含Web应用开发时，用到Spring框架时所需的核心类，包括自动载入WebApplicationContext特性的类、Struts与JSF集成类、文件上传的支持类、Filter类和大量工具辅助类. spring-webmvc.jar：这个jar文件包含Spring MVC框架相关的所有类. 包含国际化、标签、Theme、视图展现的FreeMarker、JasperReports、Tiles、Velocity、XSLT相关类. 当然，如果你的应用使用了独立的MVC框架，则无需这个JAR文件里的任何类. spring-mock.jar：这个jar文件包含Spring一整套mock类来辅助应用的测试. Spring测试套件使用了其中大量mock类，这样测试就更加简单. 模拟HttpServletRequest和HttpServletResponse类在Web应用单元测试是很方便的.  如何选择这些发布包，决定选用哪些发布包其实相当简单.\n　如果你正在构建Web应用并将全程使用Spring，那么最好就使用单个全部的spring.jar文件； 如果你的应用仅仅用到简单的Inversion of Control / Dependency Injection（IoC/DI）容器，那么只需spring-core.jar与spring-beans.jar即可；\n　如果你对发布的大小要求很高，那么就得精挑细选了，只取包含自己所需特性的jar文件了. 采用独立的发布包你可以避免包含自己的应用不需要的全部类. 当然你可以采用其它的一些工具来设法令整个应用包变小，节省空间的重点在于准确地找出自己所需的Spring依赖类，然后合并所需的类与包就可以了.\nEclispe有个插件叫ClassPath Helper可以帮你找找所依赖的类.\n4、Spring包依赖说明:  spring-core.jar需commons-collections.jar，spring-core.jar是以下其它各个的基本. spring-beans.jar需spring-core.jar，cglib-nodep-2.1_3.jar spring-aop.jar需spring-core.jar，spring-beans.jar，cglib-nodep-2.1_3.jar，aopalliance.jar spring-context.jar需spring-core.jar，spring-beans.jar，spring-aop.jar，commons-collections.jar，aopalliance.jar spring-dao.jar需spring-core.jar，spring-beans.jar，spring-aop.jar，spring-context.jar spring-jdbc.jar需spring-core.jar，spring-beans.jar，spring-dao.jar spring-web.jar需spring-core.jar，spring-beans.jar，spring-context.jar spring-webmvc.jar需spring-core.jar/spring-beans.jar/spring-context.jar/spring-web.jar spring-hibernate.jar需spring-core.jar，spring- beans.jar，spring-aop.jar，spring-dao.jar，spring-jdbc.jar，spring- orm.jar，spring-web.jar，spring-webmvc.jar spring-orm.jar需spring-core.jar，spring-beans.jar，spring-aop.jar，spring-dao.jar，spring-jdbc.jar，spring-web.jar，spring-webmvc.jar spring-remoting.jar需spring-core.jar，spring-beans.jar，spring- aop.jar，spring-dao.jar，spring-context.jar，spring-web.jar，spring- webmvc.jar spring-support.jar需spring-core.jar，spring-beans.jar，spring-aop.jar，spring-dao.jar，spring-context.jar，spring-jdbc.jar spring-mock.jar需spring-core.jar，spring-beans.jar，spring-dao.jar，spring-context.jar，spring-jdbc.jar  一、只是使用spring框架\n  dist\\spring.jar\n  lib\\jakarta-commons\\commons-logging.jar\n  如果使用到了切面编程(AOP)，还需要下列jar文件\n  lib\\aspectj\\aspectjweaver.jsr 和 aspectjrt.jar\n  lib\\cglib\\cglib-nodep-2.1_3.jar\n    如果使用了JSR-250中的注解如@Resource/@PostConstruct/@PreDestroy,还需下列jar文件\n lib\\j2ee\\common-annotations.jar    二、只是使用spring框架若使用注解方式\n　只要加一些命名空间和开启解析器,并且@Resource需要加lib\\j2ee\\common-annotations.jar\n\u0026lt;context:annotation-config/\u0026gt;打开处理器\n三、要自动扫描\n　只要开启解析器和一些命名空间 \u0026lt;context:component-scan base-package=\u0026quot;\u0026quot;/\u0026gt;\n四、spring框架采用aop编程\n需要导入一些命名空间 xmlns:aop\u0026hellip;\u0026hellip;. \u0026lt;aop:aspectj-autoproxy/\u0026gt;开启解析器 如果使用到了切面编程(AOP)，还需要下列jar文件\n lib\\aspectj\\aspectjweaver.jsr 和 aspectjrt.jar lib\\cglib\\cglib-nodep-2.1_3.jar  五、spring+Jdbc开发\n　需要数据源文件 lib\\jakarta-commons\\commons-pool.jar、lib\\jakarta-commons\\commons-dbcp.jar\n spring文件 ： dist\\spring.jar、 lib\\jakarta-commons\\commons-logging.jar jdbc驱动文件 mysql**** sql*** ： 导入tx命名空间 \u0026lt;tx:annotation-driven transaction-manager=\u0026quot;\u0026quot;/\u0026gt; 对事务注解的解析器  六、spring2.5+hibernate3.3+struts1.3\n hibernate核心包   hibernate3.jar lib\\required*.jar lib\\optional\\ehcache-1.2.3.jar (二级缓存文件) hibernate注解包 l+ ib\\test\\slf4j-log4j12.jar  spring包   dist\\spring.jar lib\\jakarta-commons\\commons-logging.jar 和commons-pool.jar、commons-dbcp.jar(后为数据源文件) dist\\modules\\spring-webmvc-struts.jar (与struts1的集成) lib\\aspectj\\aspectjweaver.jsr 和 aspectjrt.jar (Aop文件) lib\\cglib\\cglib-nodep-2.1_3.jar (Aop文件) lib\\j2ee\\common-annotations.jar (注解文件) lib\\log4j\\log4j-1.2.15.jar  sturs1.3.8  　建议将jstl-1.0.2.jar和standard-1.0.2.jar文件更换为1.1版本，此时JSTL文件．还有spring已存在antlr-2.7.6.jar文件所以将struts中的antlr-2.7.6.jar文件删除以免冲突．\n七、spring2.5+hibernate3.3+struts2整合开发\n　struts2文件lib里面所有不带-plugin结尾的jar文件，但除了struts2-spring-plugin-2.0.11.1.jar.\n5、实例化Spring容器 5.1、实例化Spring容器的方式有两种： 方法一： 在类路径下寻找配置文件来实例化容器\nApplicationContext ctx = new ClassPathXmlApplicationContext(\u0026quot;beans.xml\u0026quot;); //1.创建Spring的IOC容器对象ApplicationContext代表IOC容器 // ClassPathXmlApplicationContext:类路径下的XML格式的配置文件 ApplicationContext ctx = new ClassPathXmlApplicationContext(\u0026quot;applicationContext.xml\u0026quot;); //2.从IOC容器对象中获取Bean实例 HelloWorld helloWorld2 = (HelloWorld) ctx.getBean(\u0026quot;helloworld\u0026quot;); //3.调用hello方法 helloWorld2.hello();  方法二： 在文件内系统路径下寻找配置文件来实现容器：\nApplicationContext ctx = new FileSystemXmlApplicationContext(\u0026quot;beans.xml\u0026quot;);  Spring配置文件可以指定多个，可以通过String数组传入. 配置Spring环境\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;beans xmlns=\u0026quot;http://www.springframework.org/schema/beans\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xmlns:context=\u0026quot;http://www.springframework.org/schema/context\u0026quot; xsi:schemaLocation=\u0026quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd\u0026quot;\u0026gt; \u0026lt;/beans\u0026gt;  测试是否搭建成功:项目右键新建Junit Test Case. 6、如何将业务bean交给Spring管理 　在Spring配置中添加\u0026lt;bean id=”名称” name=”名称” class=””\u0026gt;\u0026lt;/bean\u0026gt;，此时bean就可以由Spring容器帮助创建和维护，当我们要用到bean的时候只需要从Spring容器中获取即可，获取的时候可以用ApplicationContext.getBean(id);（返回值为 Object），可以通过bean的接口对其进行引用，之后即可调用其方法.\n注意：id中不能包含特殊字符例如“/”，而name中可以包含. 如果包含特殊字符则用name=””；其他可以用id=””.\n实例：首先创建一个业务bean\u0026ndash;PersonServiceBean，建议使用面向接口编程（要实现软件之间的解耦），所以可以抽取接口，然后交给Spring管理. 7、三种实例化bean的方式： 7.1、实用类构造器实例化 \u0026lt;bean id=\u0026quot;personService\u0026quot; class=\u0026quot;com.haibao.service.impl.PersonServiceBean\u0026quot;/\u0026gt; \u0026lt;!-- 配置bean class:bean的全类名，通过反射的方式在IOC容器中创建Bean，所以Bean中必须有无参构造器 id:表示容器中的bean唯一 --\u0026gt;  7.2、使用静态工厂方法实例化 \u0026lt;bean id=\u0026quot;personService2\u0026quot; class=\u0026quot;com.haibao.service.impl.PersonServiceFactory\u0026quot; factory-method=\u0026quot;createPersonService\u0026quot;/\u0026gt;  public class PersonServiceFactory { public static PersonServiceBean createPersonService() { return new PersonServiceBean(); } }  7.3、使用实例化工厂实例化 \u0026lt;bean id=\u0026quot;personServiceFactory\u0026quot; class=\u0026quot;com.haibao.service.impl.PersonServiceFactory\u0026quot;/\u0026gt; \u0026lt;bean id=\u0026quot;personService3\u0026quot; factory-bean=\u0026quot;personServiceFactory\u0026quot; factory-method=\u0026quot;createPersonService2\u0026quot;/\u0026gt; public class PersonServiceFactory { public PersonServiceBean createPersonService() { return new PersonServiceBean(); } }  8、Bean的作用域及bean的生命周期 　.sigleton（单例模式，Spring容器启动的时候bean就被实例化） 在每个Spring IoC容器中一个bean定义只有一个对象实例. 默认情况下会在容器启动时初始化bean，我们可以指定Bean节点的laz-init=”true”来延迟初始化bean，这时候，只有第一次获取bean才会初始化bean. 例如：\u0026lt;bean id=”XXX” class=”XXX” lazy-init=“true”/\u0026gt; , （设置lazy-init=“true”后Spring容器启动的时候bean不会被实例化）.如果想所有的应用都应用延迟初始化，可以在根节点beans设置default-lazy-init=”true”;即：\u0026lt;bean id=”XXX” class=”XXX” default-lazy-init=“true”/\u0026gt;,.prototype(调用getBean()方法的时候bean才会被实例化).每次从容器获取bean都是新对象. \u0026lt;bean id=”XXX” class=”XXX” scope=” prototype”/\u0026gt;.\n初始化：初始化方法可以在bean的配置中用init-method=\u0026quot;\u0026quot;方法调用初始化函数.\n销毁：默认情况下只有Spring容器北校关闭才会销毁. 可以在bean的配置中用destroy-method=\u0026quot;\u0026quot;方法销毁.\n9、依赖注入对象： 　所谓依赖注入是指：在运行期，外部容器动态的将以来对象注入到组件.\n基本类型对象注入：\n\u0026lt;bean id=\u0026quot;orderService\u0026quot; class=\u0026quot;orderServiceBean\u0026quot;\u0026gt; //构造器注入 \u0026lt;constructor-arg index=\u0026quot;0\u0026quot; type=\u0026quot;java.lang.String\u0026quot; value=\u0026quot;XXX\u0026quot;\u0026gt; //属性setter方法注入 \u0026lt;property name=\u0026quot;name\u0026quot; value=\u0026quot;value\u0026quot;/\u0026gt; \u0026lt;/bean\u0026gt;  方式一：\n\u0026lt;bean id=\u0026quot;orderDao\u0026quot; class=\u0026quot;PersonDaoBean\u0026quot;/\u0026gt; \u0026lt;bean id=\u0026quot;orderService\u0026quot; class=\u0026quot;PersonServiceBean\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;orderDao\u0026quot; ref=\u0026quot;orderDao\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; // ref：指向其他bean  方式二：(使用内部bean，但该bean不能被其他bean使用)\n\u0026lt;bean id=\u0026quot;orderService\u0026quot; class=\u0026quot;PersonServiceBean\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;orderDao\u0026quot; ref=\u0026quot;orderDao\u0026quot;\u0026gt; \u0026lt;bean class=\u0026quot; orderDao\u0026quot;/\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;  当我们把依赖对象注入交给外部容器负责创建，namePersonServiceBean类可以改成：\npublic class PersonServiceBean implements PersonService { private PersonDao personDao; public PersonDao getPerson(){ return personDao; } public void getPersonDao(PersonDao personDao){ this.personDao = personDao; } public void save(){ personDao.add(); } } public class PersonDaoBean implements PersonDao{ public void add(){ System.out.println(\u0026quot;add()方法\u0026quot;); } }  beans.xml配置中：\n\u0026lt;bean id=\u0026quot;personDaoname\u0026quot; class=\u0026quot;PersonDaoBean\u0026quot;/\u0026gt; \u0026lt;bean id=\u0026quot;personService\u0026quot; class=\u0026quot;PersonServiceBean\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;personDao\u0026quot; ref=\u0026quot;personDaoname \u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;   属性setter方法注入  对基本类型进行注入：\n\u0026lt;property name=\u0026quot;name\u0026quot; value=\u0026quot;value\u0026quot;/\u0026gt;  集合类型的装配\npublic calss orderServiceBean{ private Set\u0026lt;String\u0026gt; sets = new HashSet\u0026lt;Striing\u0026gt;(); private List\u0026lt;String\u0026gt; lists = new ArrayList\u0026lt;Striing\u0026gt;(); private Properties properties = new Properties (); private Map\u0026lt;String,String\u0026gt; maps = new HashMap\u0026lt;String,Striing\u0026gt;(); // 一定要生成getter、setter方法 } \u0026lt;property name=\u0026quot;sets\u0026quot;\u0026gt; \u0026lt;set\u0026gt; \u0026lt;value\u0026gt;值1\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;值2\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;值3\u0026lt;/value\u0026gt;. \u0026lt;/set\u0026gt; \u0026lt;property/\u0026gt; \u0026lt;property name=\u0026quot;lists\u0026quot;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;值1\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;值2\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;值3\u0026lt;/value\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;property/\u0026gt; \u0026lt;property name=\u0026quot;properties\u0026quot;\u0026gt; \u0026lt;props\u0026gt; \u0026lt;prop key=\u0026quot;key1\u0026quot;\u0026gt;值1\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026quot;key2\u0026quot;\u0026gt;值2\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026quot;key3\u0026quot;\u0026gt;值3\u0026lt;/prop\u0026gt;. \u0026lt;/props\u0026gt; \u0026lt;property/\u0026gt; \u0026lt;property name=\u0026quot;maps\u0026quot;\u0026gt; \u0026lt;map\u0026gt; \u0026lt;entry key=\u0026quot;key1\u0026quot; value=\u0026quot;1\u0026quot;/\u0026gt; \u0026lt;entry key=\u0026quot;key2\u0026quot; value=\u0026quot;2\u0026quot;/\u0026gt; \u0026lt;entry key=\u0026quot;key3\u0026quot; value=\u0026quot;3\u0026quot;/\u0026gt;. \u0026lt;/map\u0026gt; \u0026lt;property/\u0026gt;   构造器参数注入  \u0026lt;constructor-arg index=\u0026quot;0\u0026quot; type=\u0026quot;java.lang.String\u0026quot; value=\u0026quot;XXX\u0026quot;/\u0026gt; \u0026lt;constructor-arg index=\u0026quot;1\u0026quot; type=\u0026quot;java.lang.String\u0026quot; value=\u0026quot;XXX\u0026quot;/\u0026gt;   使用Field注入（用于注解方式） 注入以来对象可以采用手工装配或自动装配，在实际应用中建议使用手工装配，因为自动装配会产生未知情况，开发人员无法预见最终结果.  9.1、依赖注入\u0026mdash;手工装配 手工装配依赖对象，在这种方式中有两种变成方式\n 在xml配置文件中通过bean节点下配置. 如：  \u0026lt;bean id=\u0026quot;orderDao\u0026quot; class=\u0026quot;PersonDaoBean\u0026quot;/\u0026gt; \u0026lt;bean id=\u0026quot;orderService\u0026quot; class=\u0026quot;PersonServiceBean\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;orderDao\u0026quot; ref=\u0026quot;orderDao\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;  在java代码中使用@Autowire或@Resource注解方式进行装配. 但我们需要在xml配置文件中配置以下信息：  \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;beans xmlns=\u0026quot;http://www.springframework.org/schema/beans\u0026quot;\txmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xmlns:context=http://www.springframework.org/schema/context xsi:schemaLocation=\u0026quot;http://www. springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd\u0026quot;\u0026gt; \u0026lt;context:annotation-config/\u0026gt; \u0026lt;/beans\u0026gt;  这个配置也是注册了多个对注释进行解析处理的处理器：\n AutwiredAnnotationBeanProcessor CommonAnnotationBeanPostProcessor PersistenceAnnotationBeanPostProcessor RequiredAnnotationBeanProcessor  注：@Resource注解在Spring安装目录下的lib\\j2ee\\common-annotation.jar 在java代码中使用@Autowire或@Resource注解方式进行装配，这两个注解的区别是：@Autowire默认按类型装配，@Resource，默认按名称装配，当找不到与名称匹配的bean才会按类型装配.\n@Autowire private PersonDao personDao;//用于字段上 @Autowire public void setOrderDao(PersonDao personDao){ //用于属性的setter方法上 this.orderDao = orderDao； }  @Autowire注解是按类型装配依赖对象，默认情况下他要求对象必须存在，如果允许为null值，可以设置它的required属性为false. 如果想使用按名称装配，可以结合@Qualifier注解一起使用. 如下：\n@Autowire @Qualifier(“personDaoBean”) private PersonDao personDao；  @Resource注解和@Autowire一样，也可以标注在字段或属性的setter方法上，但他默认按名称装配. 名称可以通过@Resource的name属性指定，如果没有指定name属性，当注解标注在字段上，即默认取字段的名称作为bean名称寻找依赖对象，当注解标注在属性的setter方法上，即默认取属性名作为bean名称寻找依赖对象.\n@Resource(name=”personDaoBean”) private PersonDao personDao;//用于字段上  注意：如果没有指定name属性，并且按照默认名称仍然找不到依赖对象时，@Resource注解会回退到安类型装配，但一旦指定了name属性，就只能按名称装配了.\n10、AOP\u0026ndash;代理对象（主要用在权限）  环绕通知 前置通知 后置通知 例外通知 最终通知  public Object invoke(Object proxy, Method method,Object[] args) throws Throwable { PersonServiceBean bean = (PersonServiceBean) this.targetObject; Object result = null;//环绕通知 if(bean.getUser () != null { // ..... advice ( )--\u0026gt;前置通知 try { result = method.invoke (targetObject, args); //afteradvice() --\u0026gt;后置通知 } catch(RuntimeException e){ // exceptionadvice ()--\u0026gt;例外通知 }finally{ // tinallyadvice () : --\u0026gt;最终通知 } } return result; }  10.1、AOP中的概念：（基于注解方式声明切面）  Aspect(切面)：指横切性关注点的抽象即为切面，它与类相似，只是两者的关注点不一样，类是对物体特征的抽象，而切面是横切性关注点的抽象. joinpoint(连接点)：所谓连接点是指那些被拦截到的点. 在spring中，这些点指的是方法，因为spring只支持方法类型的连接点，实际上joinpoint还可以是field或类构造器. Pointcut(切入点)：所为切入点是我们要对那些joinpoint进行拦截的定义.  注解：\n@Pointcut (“execution(* com.haibao.service.*.*(..))”) private void anyMethod(){}//声明一个切入点  说明\n\u0026lt;!-- 配置事务拦截器拦截哪些类的哪些方法,一般设置成拦截Service --\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;aop:pointcut expression=\u0026quot;execution(* com.xy.service.*.*(..))\u0026quot; id=\u0026quot;allDaoMethod\u0026quot; /\u0026gt; \u0026lt;aop:advisor advice-ref=\u0026quot;txAdvice\u0026quot; pointcut-ref=\u0026quot;allDaoMethod\u0026quot; /\u0026gt; \u0026lt;/aop:config\u0026gt;  表示com.xy.service包下的所有方法为为事务管理.\nexecution(* com.aptech.jb.epet.dao.hibimpl.*.*(..)) 这是com.aptech.jb.epet.dao.hibimpl包下所有的类的所有方法.\n 第一个*代表所有的返回值类型 第二个*代表所有的类 第三个*代表类所有方法 最后一个..代表所有的参数.  一些常见切入点表达式的例子：\n 任意公共方法的执行：execution(public * *(..)) 任何一个以“set”开始的方法的执行：execution(* set*(..)) AccountService 接口的任意方法的执行： execution(* com.xyz.service.AccountService.*(..)) 定义在service包里的任意方法的执行： execution(* com.xyz.service.*.*(..)) 定义在service包或者子包里的任意类的任意方法的执行： execution(* com.xyz.service..*.*(..))  Advice(通知)：所谓通知是指拦截到joinpoint之后所做的事情，通知分为前置通知（@Before(“anyMethod()”)）、   后置通知（@AfterReturning(“anyMethod()”)）、 最终通知（@After(“anyMethod()”)）、 例外通知（@AfterThrowing(“anyMethod()”)）、 环绕通知（@Around(“anyMethod()”)）.  public Object doBasicProfiling(ProceedingJoinPoint p) throws Throwable{ Object result = p.proceed();//必须执行该方法 return result; }  Target(目标对象)：代理的目标对象.\nWeave(织入)：指将aspects应用到target对象并导致proxy对象创建的过程称为织入.\nIntroduction(引入)：在不修改代码的前提下，Introduction可以在运行期间为类动态的添加一些方法或Field.\n10.2、基于XML配置方式声明切面 \u0026lt;aop:aspectj-autoproxy /\u0026gt; \u0026lt;bean id=\u0026quot;aspetbean\u0026quot; class=\u0026quot;...\u0026quot;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;aop:aspect id=\u0026quot;asp\u0026quot; ref=\u0026quot;aspetbean\u0026quot;\u0026gt; \u0026lt;!-- 定义切入点 id=名称 expression 表示拦截... --\u0026gt; \u0026lt;aop:pointcut id=\u0026quot;mycut\u0026quot; expression= \u0026quot;execution(* com.xy.service.*.*(..))\u0026quot;/\u0026gt; \u0026lt;!-- 前置通知 --\u0026gt; \u0026lt;aop:before pointcut-ref=\u0026quot;mycut\u0026quot; method=\u0026quot;\u0026quot;/\u0026gt; \u0026lt;!-- 后置通知 --\u0026gt; \u0026lt;aop:after-returning pointcut-ref= \u0026quot;mycut\u0026quot; method=\u0026quot;\u0026quot;/\u0026gt; \u0026lt;!-- 例外通知 --\u0026gt; \u0026lt;aop:after-throwing pointcut-ref=\u0026quot;mycut\u0026quot; method=\u0026quot;\u0026quot;/\u0026gt; \u0026lt;!-- 最终通知 --\u0026gt; \u0026lt;aop:after pointcut-ref=\u0026quot;mycut\u0026quot; method=\u0026quot;\u0026quot;/\u0026gt; \u0026lt;!-- 环绕通知 --\u0026gt; \u0026lt;aop:around pointcut-ref=\u0026quot;mycut\u0026quot; method=\u0026quot;\u0026quot;/\u0026gt; \u0026lt;/aop:aspect\u0026gt; \u0026lt;/aop:config\u0026gt;  11、Spring+JDBC组合开发 步骤：\n 配置数据源，如： 依赖的jar文件： commons-dbcp.jar、 commons-logging.jar、 commons-pool.jar  \u0026lt;bean id=\u0026quot;dataSource\u0026quot; class=\u0026quot;org.apach.commons.dbcp.BasicDataSource\u0026quot; destroy-method=\u0026quot;close\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;driveClassName\u0026quot; value=\u0026quot;org.gjt.mm.mysql.Driver\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;url\u0026quot; value=\u0026quot;jdbc:mysql://localhost:3306/dbname?useUnicode=true 转义\u0026amp;←\u0026amp;amp;characterEncoding=UTF-8\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;username\u0026quot; value=\u0026quot;root\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;password\u0026quot; value=\u0026quot;root\u0026quot;/\u0026gt; \u0026lt;!-- 连接池启动时的初始值 --\u0026gt; \u0026lt;property name=\u0026quot;initialSize\u0026quot; value=\u0026quot;1\u0026quot;/\u0026gt; \u0026lt;!-- 连接池最大值 --\u0026gt; \u0026lt;property name=\u0026quot;maxActive\u0026quot; value=\u0026quot;500\u0026quot;/\u0026gt; \u0026lt;!-- 最大空闲值，当经历过一个高峰时间后，连接池可以慢慢将已经用不到的连接慢慢释放一部分，一直减少到maxIdle为止 --\u0026gt; \u0026lt;property name=\u0026quot;maxIdle\u0026quot; value=\u0026quot;2\u0026quot;/\u0026gt; \u0026lt;!-- 最小空闲值，当空闲的连接数少于阙值时，连接池会预申请去一些连接，以免洪峰来时不及申请 --\u0026gt; \u0026lt;property name=\u0026quot;minIdle\u0026quot; value=\u0026quot;1\u0026quot;/\u0026gt; \u0026lt;/bean\u0026gt; 或者使用属性文件保存参数值 \u0026lt;context:property-placeholder location=\u0026quot;classpath.properties\u0026quot;/\u0026gt; classpath:在类路径下 \u0026lt;bean id=\u0026quot;dataSource\u0026quot; class=\u0026quot;org.apach.commons.dbcp.BasicDataSource\u0026quot; destroy-method=\u0026quot;close\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;driveClassName\u0026quot; value=\u0026quot;${ driveClassName}\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;url\u0026quot;value=\u0026quot;${ url }\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;username\u0026quot; value=\u0026quot;${ username}\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;password\u0026quot; value=\u0026quot;${ password }\u0026quot;/\u0026gt; \u0026lt;!-- 连接池启动时的初始值 --\u0026gt; \u0026lt;property name=\u0026quot;initialSize\u0026quot; value=\u0026quot;${ initialSize }\u0026quot;/\u0026gt; \u0026lt;!-- 连接池最大值 --\u0026gt; \u0026lt;property name=\u0026quot;maxActive\u0026quot; value=\u0026quot;${ maxActive }\u0026quot;/\u0026gt; \u0026lt;!-- 最大空闲值，当经历过一个高峰时间后，连接池可以慢慢将已经用不到的连接慢慢释放一部分，一直减少到maxIdle为止 --\u0026gt; \u0026lt;property name=\u0026quot;maxIdle\u0026quot; value=\u0026quot;${ maxIdle }\u0026quot;/\u0026gt; \u0026lt;!-- 最小空闲值，当空闲的连接数少于阙值时，连接池会预申请去一些连接，以免洪峰来时不及申请 --\u0026gt; \u0026lt;property name=\u0026quot;minIdle\u0026quot; value=\u0026quot;${ minIdle }\u0026quot;/\u0026gt; \u0026lt;/bean\u0026gt;  配置事务：配置事务时，需要在XML配置文件中引入声明事务的tx命名空间，事务的配置方式有两种：注解方式和基于XML配置方式.  11.1、采用注解方式配置事务：在XML文件中配置事务管理器 \u0026lt;bean id=\u0026quot;txManager\u0026quot; class=\u0026quot;org.springframework.jdbc.datasource.DataSourceTranszctionManager\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;dataSource\u0026quot; ref=\u0026quot;dataSource\u0026quot;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 采用@Transactional注解方式使用事务 --\u0026gt; \u0026lt;tx:annotation-driven transaction-manager=\u0026quot;txManager\u0026quot;\u0026gt;  tx命名空间.\nxmlns:tx=\u0026ldquo;http://www.springframework.org/schema/tx\u0026quot; http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd\n12、采用基于XML方式配置事务 \u0026lt;bean id=\u0026quot;txManager\u0026quot; class=\u0026quot;org.springframework.jdbc.datasource.DatasourceTransactionManager\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;dataSource\u0026quot; ref=\u0026quot;dataSource\u0026quot;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;aop:pointcut id=\u0026quot;transactionPointcut\u0026quot; expression=\u0026quot;execute()…\u0026quot;/\u0026gt; \u0026lt;aop:advisor advice=\u0026quot;txAdvice\u0026quot; point-ref=\u0026quot;transactionPointcut\u0026quot;/\u0026gt; \u0026lt;/aop:config\u0026gt; \u0026lt;tx:advice id=\u0026quot;txAdvice\u0026quot; transaction-manager=\u0026quot;txManager\u0026quot;\u0026gt; \u0026lt;tx:attributes\u0026gt; \u0026lt;tx:method name=\u0026quot;get*\u0026quot; read-only=\u0026quot;true\u0026quot; proportion=\u0026quot;NOT_SUPPORTED\u0026quot;/\u0026gt; \u0026lt;tx:method name=\u0026quot;*\u0026quot;/\u0026gt; \u0026lt;/tx:attributes\u0026gt; \u0026lt;/tx:advice\u0026gt;  13、Spring管理事务提交的规则：  遇到unckecked（运行期例外）事物会发生回滚，即：执行无效. 遇到checked事物不会发生回滚. 要求回滚：@Transcation(rollbackFor=Exception.class) 事物传播属性：@Transcation(propagation=Propagation. NOT_SUPPORTED) REQUIRED:（默认）业务方法需要在一个事务中运行. 如果方法运行时，已经处在一个事务中，那么加入到该事务中，否则自己创建一个新事务. NOT_SUPPORTED:声明方法不需要事务. 如果方法没有关联一个事务，容器不会为它开启事务；如果方法在一个事务中被调用，该事务会挂起，在方法调用结束后，原先的事务便会恢复执行. REQUIRESNEW:属性表明不管是否存在事务，业务方法总会为自己发起一个新的事务. 如果方法已经运行在一个事务中，则原事务会被挂起，新事务会被日创建，直到方法结束，新事务才算结束，原先的事务才会恢复. MANDATORY:该属性指定业务方法在某个事务范围，业务方法不能发起自己的事务. 如果业务方法在事务范围外被调用，则方法在没有事务的环境下执行. SUPPORKTS：这一事务属性表明，如果业务方法在某个事务范围内被调用，则方法成为该事务的一部分. 如果业务方法在没有事务的环境下调用，则方法在没有事务的环境下执行. Never:指定业务方法绝对不能在事务范围内执行. 若果业务方法在某个事务中执行，容器会抛出例外，只有业务方法没有关联到任何事务，才能正常执行. NESTED:如果一个活动的事务存在，则运行在一个嵌套的事务中，如果没有活动事务，则按REQUIRED属性执行，它使用了一个人单独的事务，这个事务拥有多个可以回滚的保存点. 内部事务的回滚不会对外部事务造成影响. 他只对DataSourceTransactionManager事务管理器起效.  14、数据库系统提供了四种事务隔离级 　数据库系统提供了四级事务隔离级别供用户选择. 不同的隔离级别采用不同的所类型实现，在四级隔离级别中，Serislixstion的隔离级别最高，Read Uncommited的隔离级别最低. 大多数据库默认的隔离级别为Read Commited，如SQLServer 2000 \u0026hellip;\n Read Uncommited：读未提交数据（会出现脏读，不可重复读和幻读） Read Commited：读已提交数据（会出现不可重复读和幻读） Repeatable Read：可重复读（会出现幻读） Serializable：串行化 脏读：一个事务读取到另一个事务未提交的更新数据. 可重复读：在同一个事务中多次读取数据时，能够保证所读数据一样，也就是，后续读取不能读到另外一个事务已提交的更新数据. 不可重复读：在同一个事务中多次读取同一数据返回的结果有所不同，也就是，后续读取能读到另外一个事务已提交的更新数据. 幻读：一个事务读取到另一事务已提交的insert数据.  ","date":1611964800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1611964800,"objectID":"9226e139b2d30f2cbf1e37cc4f3ba49e","permalink":"https://CoMath21.github.io/post/1-spring2.5/","publishdate":"2021-01-30T00:00:00Z","relpermalink":"/post/1-spring2.5/","section":"post","summary":"具体介绍Spring2.5的相关内容.","tags":["编程语言","Java","Spring"],"title":"Spring2.5学习笔记","type":"post"},{"authors":["Xin态好先生","CoMath"],"categories":["学习笔记","编程语言"],"content":"Hibernate 是什么？  hibernate是一个轻量级JavaEE应用的持久层框架（framework） hibernate是一个ORM（object relation mapping对象关系映射）框架  o object -\u0026gt; 业务层(只对对象操作) r relation-\u0026gt; 关系数据库，关系型数据库中二维表 m mapping 对象关系映射文件  java类\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-\u0026gt;表 java对象\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;\u0026gt;表中记录 java对象属性\u0026mdash;\u0026mdash;-\u0026gt;表中字段     hibernate 处于我们项目的持久层位置(正因为如此，所以有人又把hibernate称为 持久层框架) hibernate 实际上就是对jdbc进行了轻量级的封装. hibernate 的基础还是我们java反射机制  手动配置hibernate方式完成crud操作 　首先创建项目，再引入jar包. hibernate开发的三种方式：\n 由domain object –\u0026gt; mapping -\u0026gt; db (官方推荐). 由DB开始，用工具生成mapping和domain object (使用较多). 由映射开始.  Employee.hbml.xml配置文件 \u0026lt;!DOCTYPE hibernate-mapping PUBLIC \u0026quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN\u0026quot; \u0026quot;http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\u0026quot;\u0026gt; \u0026lt;hibernate-mapping package=\u0026quot;com.hsp.domain\u0026quot;\u0026gt; \u0026lt;class name=\u0026quot;Employee\u0026quot; table=\u0026quot;employee\u0026quot;\u0026gt; \u0026lt;!-- id元素用于指定主键属性 --\u0026gt; \u0026lt;id name=\u0026quot;id\u0026quot; column=\u0026quot;id\u0026quot; type=\u0026quot;java.lang.Integer\u0026quot;\u0026gt; \u0026lt;!-- 该元素用于指定主键值生成策略hilo native increment sequence uuid --\u0026gt; \u0026lt;generator class=\u0026quot;sequence\u0026quot;\u0026gt; \u0026lt;param name=\u0026quot;sequence\u0026quot;\u0026gt;emp_seq\u0026lt;/param\u0026gt; \u0026lt;/generator\u0026gt; \u0026lt;/id\u0026gt; \u0026lt;!-- 对其它属性还有配置 --\u0026gt; \u0026lt;property name=\u0026quot;name\u0026quot; type=\u0026quot;java.lang.String\u0026quot;\u0026gt; \u0026lt;column name=\u0026quot;name\u0026quot; not-null=\u0026quot;false\u0026quot; /\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;email\u0026quot; type=\u0026quot;java.lang.String\u0026quot; \u0026gt; \u0026lt;column name=\u0026quot;email\u0026quot; not-null=\u0026quot;false\u0026quot;/\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;hiredate\u0026quot; type=\u0026quot;java.util.Date\u0026quot;\u0026gt; \u0026lt;column name=\u0026quot;hiredate\u0026quot; not-null=\u0026quot;false\u0026quot; /\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/class\u0026gt;\t\u0026lt;/hibernate-mapping\u0026gt;  hibernate.cfg.xml配置文件 \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt; \u0026lt;!DOCTYPE hibernate-configuration PUBLIC \u0026quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN\u0026quot; \u0026quot;http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd\u0026quot;\u0026gt; \u0026lt;hibernate-configuration\u0026gt; \u0026lt;session-factory\u0026gt; \u0026lt;!-- hibernate 设计者，给我们提供了一写常用的配置 --\u0026gt; \u0026lt;!-- 配置使用的driver --\u0026gt; \u0026lt;property name=\u0026quot;connection.driver_class\u0026quot;\u0026gt;oracle.jdbc.driver.OracleDriver\u0026lt;/property\u0026gt; \u0026lt;!-- 配置使用的账户密码 --\u0026gt; \u0026lt;property name=\u0026quot;connection.username\u0026quot;\u0026gt;scott\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;connection.password\u0026quot;\u0026gt;tiger\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;connection.url\u0026quot;\u0026gt;jdbc:oracle:thin:@127.0.0.1:1521:orclhsp\u0026lt;/property\u0026gt; \u0026lt;!-- 配置dialect方言,明确告诉hibernate连接是哪种数据库 --\u0026gt; \u0026lt;property name=\u0026quot;dialect\u0026quot;\u0026gt;org.hibernate.dialect.OracleDialect\u0026lt;/property\u0026gt; \u0026lt;!-- 显示出对于sql语句 --\u0026gt; \u0026lt;property name=\u0026quot;show_sql\u0026quot;\u0026gt;true\u0026lt;/property\u0026gt; \u0026lt;!-- 指定管理的对象映射文件 --\u0026gt; \u0026lt;mapping resource=\u0026quot;com/hsp/domain/Employee.hbm.xml\u0026quot;/\u0026gt; \u0026lt;/session-factory\u0026gt; \u0026lt;/hibernate-configuration\u0026gt;  说明：\n connection.driver_class:在etc下可以找到； hibernate.cfg.xml文件可以不写，但要在spring中配置.  测试文件TestMain.java package com.hsp.view; import com.hsp.util.*; import java.util.Date; import org.hibernate.Session; import org.hibernate.SessionFactory; import org.hibernate.Transaction; import org.hibernate.cfg.*; import com.hsp.domain.Employee; public class TestMain { public static void main(String[] args) { //查询[load]-\u0026gt;hql语句(hibernate query language) } public static void delEmp() { //删除 //获取一个session Session session=MySessionFactory.getSessionFactory().openSession(); Transaction ts=session.beginTransaction(); //删除1.先获取该雇员，然后删除 Employee emp=(Employee) session.load(Employee.class, 3); session.delete(emp); ts.commit(); session.close(); } public static void updateEmp() { // TODO Auto-generated method stub //修改用户 //获取一个会话 Session session=MySessionFactory.getSessionFactory().openSession(); Transaction ts=session.beginTransaction(); //修改用户1. 获取要修改的用户，2.修改 //load是通过主键属性，获取该对象实例.\u0026lt;---\u0026gt;表的记录对应 Employee emp=(Employee) session.load(Employee.class, 3); emp.setName(\u0026quot;韩顺平8\u0026quot;);//update... emp.setEmail(\u0026quot;abc@sohu.com\u0026quot;); ts.commit(); session.close(); } public static void addEmployee() { //我们使用hibernate完成crud操作[这里我们只见对象，不见表] //现在我们不是用service ,直接测试. //1. 创建Configuration,该对象用于读取hibernate.cfg.xml,并完成初始化 Configuration configuration=new Configuration().configure(); //2.创建SessoinFactory[这是一个会话工厂，是一个重量级的对象] SessionFactory sessionFactory=configuration.buildSessionFactory(); //3.创建Sessoin 相当于jdbc Connection[ servelt HttpSession ,也不是 jsp session] Session session=sessionFactory.openSession(); //4.对hiberate而言，要求在进行 增加，删除，修改的时候使用事务提交， Transaction transaction = session.beginTransaction(); //添加一个雇员 Employee employee=new Employee(); employee.setName(\u0026quot;shunping\u0026quot;); employee.setEmail(\u0026quot;shunping@sohu.com\u0026quot;); employee.setHiredate(new Date()); //insert ............. //保存 session.save(employee);//save employee就是持久化该对象 (把对象保存到了数据库中称为一条记录) //==\u0026gt;insert into ....[被hiberante封装] //提交 transaction.commit(); session.close(); } }  　\u0026lt;Hibernate-mapping\u0026gt;标签的属性如下：\n package：指定一个包前缀，如果在映射文档中(就是在class标签的那么属性里没有指定全类名)没有指定全限定的类名，就使用这个作为包名. schema：数据库schema的名称. catalog：数据库catalog的名称. default-cascade：默认的级联风格,默认为none. default-access：Hibernate用来访问属性的策略. default-lazy：指定了此属性，未明确注明lazy属性的Java属性和集合类，Hibernate会采取的默认使用这个属性加载风格,默认为true. auto-import：指定我们是否可以在查询语言中使用非全限定的类名,默认为true,如果项目中有两个同名的持久化类,则最好在这两个类的对应的映射文件中配置为false.  　Hibernate的子标签class标签：\n class 元素用于指定类和表的映射 . name:指定该持久化类映射的持久化类的类名.  example:\u0026lt;class name=\u0026quot;com.jeremy.hibernate.example.News\u0026quot; table=\u0026quot;NEWS\u0026quot;\u0026gt;.   table:指定该持久化类映射的表名, Hibernate 默认以持久化类的类名作为表名 .  example:\u0026lt;class name=\u0026quot;com.jeremy.hibernate.example.News\u0026quot; table=\u0026quot;NEWS\u0026quot;\u0026gt;.   dynamic-insert: 若设置为 true, 表示当（调用Session的save()方法时）保存一个对象时, 会动态生成 insert 语句, insert 语句中仅包含所有取值不为 null 的字段. 默认值为 false. Example:这个跟dynamic-update一个意思. dynamic-update: 若设置为 true, 表示当(调用对象的set()方法)更新一个对象时, 会动态生成 update 语句, update 语句中仅包含所有取值需要更新的字段. 默认值为 false.  　Hibernate映射文件主要内容:\n 映射内容的定义: Hibernate映射文件由\u0026lt;hibernate-mapping package=\u0026quot;JavaBean所在包的全路径\u0026quot;\u0026gt;节点定义映射内容并指定所对应的JavaBean的位置(也可以不在该节点中用package属性指定对应的JavaBean位置,而在该节点下的class节点中的name属性中指定). 数据库和JavaBean的关联: Hibernate映射文件中用\u0026lt;hibernate-mapping\u0026gt;节点下的 \u0026lt;class name=\u0026quot;JavaBean名称\u0026quot; table=\u0026quot;对应数据库中的表名\u0026quot;\u0026gt;节点指定数据库表和JavaBean的关联. ( 该节点的父节点中用package属性指定了JavaBean的包名时用)/全路径(该节点的父节点中没用package属性指定JavaBean的包名时用). 主键映射: 在\u0026lt;class \u0026gt;节点下用\u0026lt;id name=\u0026quot;数据库中主键在JavaBean中的属性名称\u0026quot; column=\u0026quot;数据库中主键名\u0026quot; type=\u0026quot;string\u0026quot;\u0026gt;节点映射对应的主键,该节点必须有且只有一个(因为主键只有一个),同时必须放在\u0026lt;property ...\u0026gt;节点前. 普通字段映射: 在\u0026lt;class ...\u0026gt;节点下用\u0026lt;property name=\u0026quot;数据库中字段在JavaBean中的属性名称\u0026quot; column=\u0026quot;数据库中的字段名\u0026quot; type=\u0026quot;string\u0026quot;/\u0026gt;节点映射普通字段,该节点可有多个(一个字段用一个该节点来映射).  　Heibernate的主键映射方式：\n　在\u0026lt;id ...\u0026gt;节点下用\u0026lt;generator class=\u0026quot;映射方式\u0026quot;/\u0026gt;节点指定Hibernate向数据库插入数据时主键的生成方式.\n assigned：应用程序自身对id赋值. 当设置\u0026lt;generator class=\u0026quot;assigned\u0026quot;/\u0026gt;时，应用程序自身需要负责主键id的赋值，由外部程序负责生成(在session.save()之前为对象的主键设置值),无需Hibernate参与，一般应用在主键为自然主键时. 例如XH为主键时，当添加一个学生信息时，就需要程序员自己设置学号的值，这时就需要应用该id生成器. native：由数据库对id赋值. 当设置\u0026lt;generator class=\u0026quot;native\u0026quot;/\u0026gt;时，数据库负责主键id的赋值，最常见的是int型的自增型主键. 例如，在SQLServer中建立表的id字段为identity，配置了该生成器，程序员就不用为该主键设置值，它会自动设置. identity：采用数据库提供的主键生成机制，为long/short/int型列生成唯一标识如SQL Server、MySQL中的自增主键生成机制. hilo：通过hi/lo算法实现的主键生成机制，需要额外的数据库表保存主键生成历史状态. seqhilo：与hi/lo类似，通过hi/lo算法实现的主键生成机制，只是主键历史状态保存在sequence中，适用于支持sequence的数据库，如Oracle. increment：主键按数值顺序递增. 此方式的实现机制为在当前应用实例中维持一个变量，以保存当前的最大值，之后每次需要生成主键的时候将此值加1作为主键. 这种方式可能产生的问题是：如果当前有多个实例访问同一个数据库，由于各个实例各自维护主键状态，不同实例可能生成同样的主键，从而造成主键重复异常. 因此，如果同一个数据库有多个实例访问，这种方式应该避免使用. sequence：采用数据库提供的sequence机制生成主键，用于用序列方式产生主键的数据库(如:Oracle、DB2等的Sequence),用于为long/short/int型列生成唯一标识,如:\u0026lt;generator class=\u0026quot;sequence\u0026quot;\u0026gt;\u0026lt;param name=\u0026quot;sequence\u0026quot;\u0026gt;序列名\u0026lt;/param\u0026gt;\u0026lt;/generator\u0026gt;如Oracle sequence. uuid.hex：由Hibernate基于128位唯一值产生算法，根据当前设备IP、时间、JVM启动时间、内部自增量等4个参数生成十六进制数值（编码后长度为32位的字符串表示）作为主键. 即使是在多实例并发运行的情况下，这种算法在最大程度上保证了产生id的唯一性. 当然，重复的概率在理论上依然存在，只是概率比较小. 一般而言，利用uuid.hex方式生成主键将提供最好的数据插入性能和数据平台适应性. uuid.string：与uuid.hex类似，只是对生成的主键进行编码（长度为16位）. 在某些数据库中可能出现问题. foreign：使用外部表的字段作为主键. 该主键一般应用在表与表之间的关系上，会在后面的表对应关系上进一步讲解. select：Hibernate 3新引入的主键生成机制，主要针对遗留系统的改造工程. 由于常用的数据库，如SQLServer、MySQL等，都提供了易用的主键生成机制（如auto-increase字段），可以在数据库提供的主键生成机制上，采用native生成器来配置主键生成方式.  Hibernate的核心类和接口 1、Configuration类 它的作用是：\n 负责管理hibernate的配置信息； 读取hibernate.cfg.xml文件； 加载hibernate.cfg.xml配置文件中配置的驱动文件，url，用户名，密码，连接池； 管理 *.hbm.xml对象关系文件.  2、hibernate.cfg.xml文件  该文件主要用于制定各个参数，值hibernate核心文件； 默认放在src目录下，也可以在别的目录下； 指定连接数据库的驱动、用户名、url、密码、连接池； 制定对象关系映射文件位置； 也可以使用hibernate,properties文件来替代该文件.  3、SessionFactory 接口  可以缓存SQL语句或者数据（称为）. 在应用程序化的时候创建，是一个重量级的类，一般用单例模式保证一个应用只需要一个SessionFactory实例. 如果某个应用访问多个数据库，则要创建多个回话工厂实例，一般一个数据库一个会话工厂实例. 通过SessionFactory接口可以获得Session实例.  Configuration cf = new Configuration().configure(); SessionFactory sf = cf.buildSessionFactory(); Session s = sf.getCurrentSession(); //或者：Session s = sf.openSession();  3.1 openSession()和getCurrentSession()区别  采用getCurrentSession()创建的session会绑定到当前线程中，而采用openSession()创建的Session则不会； 采用getCurrentSession()创建的session在commit或rollback时会自动关闭，而采用openSession()创建的session必须手动关闭（建议不管是用哪个，最好都要手动关闭）； 使用getCurrentSession()需要在hibernate.cfg.xml文件中加入如下配置：  * 如果使用的是本地事务（jdbc事务：针对一个数据库的事务）* \u0026lt;property name=\u0026quot;hibernate.current_session_context_class\u0026quot;\u0026gt;thread\u0026lt;/property\u0026gt; * 如果使用的是全局事务（jta事务：卷数据库的事务）* \u0026lt;property name=\u0026quot;hibernate.current_session_context_class\u0026quot;\u0026gt;jta\u0026lt;/property\u0026gt;  如何选择openSession()和getCurrentSession()\n原则：\n 如果需要在同一线程中，保证使用同一个Session，则使用getCurrentSession(). 如果在一个线程中，需要使用不同的Session，则使用openSession().  3.2\tget vs load 　可以使用session.get(Student.class,i)/session.load(…)获取值\n 如果查询不到数据，get会返回 null,但是不会报错, load如果查询不到数据，则报错ObjectNotFoundException 使用get 去查询数据，(先到一级/二级)会立即向db发出查询请求(select \u0026hellip;), 如果你使用的是 load查询数据，(先到一级、二级))即使查询到对象，返回的是一个代理对象,如果后面没有使用查询结果，它不会真的向数据库发select ,当程序员使用查询结果的时候才真的发出select ,这个现象我们称为“懒加载”(lazy) 通过修改配置文件，我们可以取消“懒加载”；  \u0026lt;class name=\u0026quot;Employee\u0026quot; lazy=\u0026quot;false\u0026quot; table=\u0026quot;employee\u0026quot;\u0026gt;  如何选择使用哪个: 如果你确定DB中有这个对象就用load(),不确定就用get()（这样效率高）.  4、Transaction（事务）接口 　事务简单地说就是一组对数据库的操作集合，他们要么全部成功，要么全部失败，这个可以保证数据的一致性，事务具有原子性.\n Transaction是底层的事物实现中抽取出来的接口； 可能是一个jdbc或者jta的事务，这样有利于hibernate在不同执行环境的移植； Hibernate要求显示的调用事务（如果仅仅是查询可以不调用）.  //增加删除修改如果发生异常要tx.rollback()回滚 Session sess = factory.openSession(); Transaction tx; try { tx = sess.beginTransaction(); //do some work ... tx.commit(); } catch (Exception e) { if (tx!=null) tx.rollback(); throw e; } finally { sess.close(); }  5、Query 接口 　Query接口类型的对象可以对数据库操作，他可以使用Hql，Qbc，Qbe和原生SQL（native Sql）对数据库操作，官方推荐使用Hql语句.\n//获取query引用[这里Employee不是表名，而是domain类名]，where后面的条件最好使用类下的属性名 Query query = session.createQuery(\u0026quot;from Employee where id=10\u0026quot;); //通过list方法获取结果，这个list会自动封装成对应的domain对象 List\u0026lt;Employee\u0026gt; list = query.list(); for(Employee e:list) ...  6、Criteria接口 　什么是QBC： QBC（Query By Criteria）按条件查询，通过Criteria构造查询条件，即通过调用Criteria的api实现各种查询.\n　通过Criteria对象拼装 查询条件，调用Criteria的add方法拼接查询条件，最终hibernate通过criteria对象自动生成sql语句.\n（了解）纯面向对象的检索方式\nSession session=HibernateUtil.getCurrentSession(); Transaction ts=null;\ttry {\tts=session.beginTransaction();\tCriteria cri = session.createCriteria(Employee.class). setMaxResults(2).addOrder(Order.desc(\u0026quot;id\u0026quot;) );//按照升序 List\u0026lt;Employee\u0026gt; list=cri.list(); for(Employee e: list){ System.out.println(e.getAaaid()); }\tts.commit();\t} catch (Exception e) {\tif(ts!=null){ ts.rollback(); } throw new RuntimeException(e.getMessage()); }finally{ //关闭session if(session!=null\u0026amp;\u0026amp;session.isOpen()){ session.close(); } }  MySQL记录总数查询  分页查询  投影查询方法  记录总数查询   DetachedCriteria  DetachedCriteria是什么？离线的Criteria. DetachedCriteria和Criteria区别：  Criteria创建方法：session.createCriteria DetachedCriteria创建方法：不需要session．   DetachedCriteria和Criteria相同点：实现查询条件拼装.  　建议使用DetachedCriteria，因为DetachedCriteria创建不需要session，在任何代码中通过DetachedCriteria 拼接查询条件. 这里的HibernateUtil为打开SessionFactory.\nservice 　接收servlet传入查询条件，将查询条件拼装成DetachedCritriea. @Override public Long findCustomerCount(CstCustomer cstCustomer) { //创建DetachedCriteria DetachedCriteria detachedCriteria = DetachedCriteria.forClass(CstCustomer.class); //根据cstCustomer中数据动态拼接查询条件 if(cstCustomer!=null){ //拼接客户名称查询条件，使用like if(cstCustomer.getCustName()!=null \u0026amp;\u0026amp; !cstCustomer.getCustName().equals(\u0026quot;\u0026quot;)){ detachedCriteria.add(Restrictions.like(\u0026quot;custName\u0026quot;, \u0026quot;%\u0026quot;+cstCustomer.getCustName()+\u0026quot;%\u0026quot;)); } //拼接联系人查询条件 if(cstCustomer.getCustLinkman()!=null \u0026amp;\u0026amp; !cstCustomer.getCustLinkman().equals(\u0026quot;\u0026quot;)){ detachedCriteria.add(Restrictions.eq(\u0026quot;custLinkman\u0026quot;,cstCustomer.getCustLinkman())); } } CstCustomerDao cstCustomerDao = new CstCustomerDaoImpl(); return cstCustomerDao.findCustomerCount(detachedCriteria); } @Override public List\u0026lt;CstCustomer\u0026gt; findCustomerList(CstCustomer cstCustomer, int firstResult, int maxResults) { CstCustomerDao cstCustomerDao = new CstCustomerDaoImpl(); //创建DetachedCriteria DetachedCriteria detachedCriteria = DetachedCriteria.forClass(CstCustomer.class); //拼接查询条件 //根据cstCustomer中数据动态拼接查询条件 if(cstCustomer!=null){ //拼接客户名称查询条件，使用like if(cstCustomer.getCustName()!=null \u0026amp;\u0026amp; !cstCustomer.getCustName().equals(\u0026quot;\u0026quot;)){ detachedCriteria.add(Restrictions.like(\u0026quot;custName\u0026quot;, \u0026quot;%\u0026quot;+cstCustomer.getCustName()+\u0026quot;%\u0026quot;)); } //拼接联系人查询条件 if(cstCustomer.getCustLinkman()!=null \u0026amp;\u0026amp; !cstCustomer.getCustLinkman().equals(\u0026quot;\u0026quot;)){ detachedCriteria.add(Restrictions.eq(\u0026quot;custLinkman\u0026quot;,cstCustomer.getCustLinkman())); } } return cstCustomerDao.findCustomerList(detachedCriteria, firstResult, maxResults); }  log4j学习 目标：学会使用log4j自定义输出日志信息.\nhibernate默认使用slf4j框架.\n slf4j：提供了一套日志记录接口规范. log4j：日志接口的实现类.  　如果 使用log4j需要以classpath下添加log4j.properties文件.\nLog4j包括三个主要部件，分别是：\n 记录器（Loggers）：配置日志在哪记录. 输出源（Appenders）：配置日志输出到哪里.  布局（Layouts），指定日志输出格式 记录器：  log4j.rootLogger=debug,A log4j.appender.A=org.apache.log4j.ConsoleAppender log4j.appender.A.layout=org.apache.log4j.PatternLayout  日志级别\n  日志级别由低到高为：ALL \u0026lt; TRACE \u0026lt; DEBUG \u0026lt; INFO \u0026lt; WARN \u0026lt; ERROR \u0026lt; FATAL \u0026lt; OFF.\n  日志级别越低输出日志越多，因为将系统调试信息设置级别低，系统的错误信息级别要高，设置成error.\n  根据log4j.properties中级别设置，将级别高的日志输出.\n在开发阶段设置为debug，在生产环境设置info或error.\n用MyEclipse进行hibernate快速开发 　手动配置:\ndb(table )-\u0026gt; 手写domain对象-\u0026gt;对象关系映射文件.\n现在我们希望用工具完成Domain对象和关系映射文件的工作. 错误信息\njava.lang.AbstractMethodError: com.microsoft.jdbc.base.BaseDatabaseMetaData.supportsGetGeneratedKeys()Z\n解决：microsoft提供的数据库驱动存在bug. 需要换一种驱动连接，使用jtds（下载地址）下载jtds1.2版，解压得到jtds-1.2.jar，引用到eclipse中项目目录下（去除原驱动引用），更改hibernate配置文件.\n原驱动连接配置：\n\u0026lt;property name=\u0026quot;connection.driver_class\u0026quot;\u0026gt;com.microsoft.jdbc.sqlserver.SQLServerDriver\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;connection.url\u0026quot;\u0026gt;jdbc:microsoft:sqlserver://127.0.0.1:1433;DatabaseName=hibernate\u0026lt;/property\u0026gt;  更改jtds连接：\n\u0026lt;property name=\u0026quot;connection.driver_class\u0026quot;\u0026gt;net.sourceforge.jtds.jdbc.Driver\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;connection.url\u0026quot;\u0026gt;jdbc:jtds:sqlserver://127.0.0.1:1433;DatabaseName=hibernate\u0026lt;/property\u0026gt;  问题得到解决.\n补充：java代码调原驱动连接数据库是没有问题的，搭配hibernate会有此问题.\n# HibernateUtil工具类： package com.haibao.util; import javax.persistence.Entity; import org.hibernate.Session; import org.hibernate.SessionFactory; import org.hibernate.cfg.Configuration; @Entity final public class HibernateUtil { private static SessionFactory sessionFactory = null; private static ThreadLocal\u0026lt;Session\u0026gt; threadLocal = new ThreadLocal\u0026lt;Session\u0026gt;(); private HibernateUtil(){}; static{ sessionFactory = new Configuration().configure().buildSessionFactory(); } public static Session openSession(){ return sessionFactory.openSession(); } public static Session getCurrentSession(){ Session session = threadLocal.get(); if(session==null){ session = sessionFactory.openSession(); threadLocal.set(session); } return session; } } # 实现类： package com.haibao.view; import javax.persistence.Entity; import org.hibernate.Session; import org.hibernate.Transaction; import com.haibao.bean.Person; import com.haibao.util.HibernateUtil; @Entity public class Main { public static void main(String[] args) { Session session = null; Transaction ts = null; try { session = HibernateUtil.getCurrentSession(); ts = session.beginTransaction(); Person p = new Person(); p.setName(\u0026quot;asd\u0026quot;); p.setSex(\u0026quot;男\u0026quot;); session.persist(p); ts.commit(); } catch (Exception e) { if(ts!=null){ ts.rollback(); } throw new RuntimeException(e.getMessage()); }finally{ if(session!=null \u0026amp;\u0026amp; session.isOpen()){ session.close(); } } } }  HQL语句（Hibernate Query Language） 　面向对象的查询语句，与SQL不同，HQl中的对象是区分大小写的（除了JAVA类和属性其他部分不区分大小写）；在HQL中查的是对象而不是表，并且支持多态；HQL主要通过Query来操作，Query的创建方式：\nQuery query = session.createQuery(hql);  　现在使用hibernate工具，自动生成 domain 对象 和映射文件,如果我们的表有主外键的关系，则应当先映射主表，再映射从表.\nuniqueResult方法 　如果我们检索一个对象，明确知道最多只有一个对象，则建议使用该方法，简单高效. 具体用法如下:\nStudent s=(Student) session.createQuery(\u0026quot;from Student where sid='20050003'\u0026quot;).uniqueResult(); System.out.println(s.getSname());  distinct的用法 过滤重复的记录\n//比如，显示所有学生的性别和年龄. List list=session.createQuery(\u0026quot;select distinct sage,ssex from Student\u0026quot;).list(); for(int i=0;i\u0026lt;list.size();i++){ Object [] objs=(Object[]) list.get(i); System.out.println(objs[0].toString()+\u0026quot; \u0026quot;+objs[1].toString()); }  between and.. List list=session.createQuery(\u0026quot;select distinct sage,ssex,sname from Student where sage between 20 and 22\u0026quot;).list(); for(int i=0;i\u0026lt;list.size();i++){ Object [] objs=(Object[]) list.get(i); System.out.println(objs[0].toString()+\u0026quot; \u0026quot;+objs[1].toString()+objs[2].toString()); }  in/not in //查询计算机系和外语系的学生信息 List\u0026lt;Student\u0026gt; list=session.createQuery(\u0026quot;from Student where sdept in ('计算机系','外语系')\u0026quot;).list(); //取出1. for 增强 for(Student s:list){ System.out.println(s.getSname()+\u0026quot; \u0026quot;+s.getSaddress()+\u0026quot; \u0026quot;+s.getSdept()); }  group by使用 //显示各个系的学生的平均年龄 List\u0026lt;Object[]\u0026gt; list=session.createQuery(\u0026quot;select avg(sage),sdept from Student group by sdept\u0026quot;).list(); //取出1. for 增强 for(Object[] obj:list){ System.out.println(obj[0].toString()+\u0026quot; \u0026quot;+obj[1].toString()); }  having的使用 //1.对分组查询后的结果，进行筛选:比如请显示人数大于3的系名称 //a. 查询各个系分别有多少学生. List\u0026lt;Object[]\u0026gt; list=session.createQuery(\u0026quot;select count(*) as c1,sdept from Student group by sdept having count(*)\u0026gt;3\u0026quot;).list(); //取出1. for 增强 for(Object[] obj:list){ System.out.println(obj[0].toString()+\u0026quot; \u0026quot;+obj[1].toString()); } //2查询女生少于200人的系 //a.查询各个系的女生有多个个 List\u0026lt;Object[]\u0026gt; list=session. createQuery(\u0026quot;select count(*) as c1,sdept from Student where ssex='F' group by sdept\u0026quot;).list(); //取出1. for 增强 for(Object[] obj:list){ System.out.println(obj[0].toString()+\u0026quot; \u0026quot;+obj[1].toString()); } //1.查询计算机系共多少人?-\u0026gt;如果我们返回的是一列数据 //这时我们的取法是直接取出list-\u0026gt;object 而不是 list-\u0026gt;Object[] List\u0026lt;Object[]\u0026gt; list=session.createQuery(\u0026quot;select sage from Student where sdept='计算机系'\u0026quot;).list(); //取出1. for 增强 for(Object obj:list){ System.out.println(obj.toString()); } //3.查询选修11号课程的最高分和最低分. List\u0026lt;Object[]\u0026gt; list=session. createQuery(\u0026quot;select 11,max(grade),min(grade) from Studcourse where course.cid=11\u0026quot;).list(); //取出1. for 增强 for(Object[] obj:list){ System.out.println(obj[0].toString()+\u0026quot; max=\u0026quot;+obj[1].toString()+\u0026quot; min=\u0026quot;+obj[2].toString()); } //4.计算各个科目不及格的学生数量. List\u0026lt;Object[]\u0026gt; list=session. createQuery(\u0026quot;select count(*),student.sdept from StudCourse where grade\u0026lt;60 group by student.sdept\u0026quot;).list(); //取出1. for 增强 for(Object[] obj:list){ System.out.println(obj[0].toString()+\u0026quot; \u0026quot;+obj[1].toString()); }  分页显示对象： 　根据用户输入的pageNow和pageSize现实对象\nQuery query = session.createQuery(hql); query.setFirdtRequest(从第几条取//从0开始计算); query.setMaxRequest(取出几条); List list = query.list(); //list就是结果 query = session.createQuery(得到count(*)的查询语句); int pageRow = (Integer)query.list().get(0).intValue();  参数绑定 　可以用setParameter()方法来确定变量的值：\nQuery query = session.createQuery(\u0026quot;from Student where sdept = :dept and sage\u0026gt;:age\u0026quot;); query.setParameter(参数名，值);  使用绑定参数的好处：\n 可读性好 性能提高 防止SQL注入（where 1=1）  提示：也可以使用setInteger().setString()…来指定值.\n另外：hql语句也可以用“?”来指定带绑定的参数.\nQuery query = session.createQuery(“from Student where sdept = ? and sage\u0026gt;?”); query.setParameter(0，值); query.setParameter(1，值);  在映射文件中得到hql语句 　可以从某些映射文件中得到hql语句，执行查询语句，这样可以更加灵活，在某种情况下，可以考虑使用. 比如：在Student.hbm.xml中.\n\u0026lt;query name=”myquerytest”\u0026gt; \u0026lt;![CDATA[select sname,ssex from Student where sage\u0026gt;22]]\u0026gt; \u0026lt;/query\u0026gt; 如何使用： List list = session.getNameQuery(“myQuerytest”).lise(); System.out.println(list.size()); Iterator iterator = list.iterator(); while(iterator.hasNext()){ Object obj[] = (Object[])iterator.next(); System.out.println(“N=”+obj[0]); }  使用子查询 hibernate中的对象存在三种关系  one-to-one：身份证←→人 one-to-many【many-to-one】部门←→员工 many-to-many：老师←→学生（尽量化简） 实际开发中，如果出现了many-to-many关系，用将其装换成两个one-to-many或者many-to-one，这样程序好控制，同时不会冗余.  criterial使用:\n//查询年龄大于10岁的学生 criteria Session s=HibernateUtil.getCurrentSession(); Transaction tx=s.beginTransaction(); Criteria cri=s.createCriteria(Student.class); //添加检索条件 cri.add(Restrictions.gt(\u0026quot;sage\u0026quot;, new Long(10))); List\u0026lt;Student\u0026gt; list=cri.list(); for(Student s1: list){ System.out.println(s1.getSname()); } tx.commit();  hibernate开发的三种方式中的 　编写domain object + 映射文件 \u0026mdash;\u0026mdash;\u0026gt; 创建出对应的数据库,这里我们说明如果要自动的创建出对应的数据库，需要做配置(hibernate.cfg.xml).\n\u0026lt;property name=\u0026quot;hbm2ddl.auto\u0026quot;\u0026gt;create\u0026lt;/property\u0026gt;  这里有四个配置值: create , update , create-drop, validate\n create:当我们的应用程序加载hibernate.cfg.xml[new Configuration().config();]就会根据映射文件，创建出数据库, 每次都会重新创建， 原来表中的数据就没有!!! update: 如果数据库中没有该表，则创建，如果有表，则看有没有变化，如果有变化，则更新. create-drop: 在显示关闭 sessionFactory时，将drop掉数据库的schema validate: 相当于每次插入数据之前都会验证数据库中的表结构和hbm文件的结构是否一致  　在开发测试中，我们配置哪个都可以测试，但是如果项目发布后，最好自己配置一次，让对应的数据库生成，完后取消配置.\ndomain对象的细节:\n 需要一个无参的构造函数(用于hibernate反射该对象) 应当有一个无业务逻辑的主键属性. 给每个属性提供 get/set方法. 在domian对象中的属性，只有配置到了对象映射文件xxx.hbm.xml后，才会被hiberante管理. 属性一般是private范围  对象关系映射文件的说明：\n　对象关系文件中，有些属性是可以不配，hibernate会采用默认机制，比如\u0026lt;class table=\u0026quot;?\u0026quot; \u0026gt; table 值不配，则以类的小写做表名；\u0026lt;property type=\u0026quot;?\u0026quot;\u0026gt; type不配置，则hibernate会根据类的属性类型，选择一个适当的类型.\nHibernate的三种状态：\n 瞬时态：对象刚刚被创建，没有处于session的管理下，同时在数据库没有记录； 持久态：既处于session的管理下，同时又被保存到数据库中（在数据库中有记录）； 脱管/游离态：没有在session管理下，但在数据库中有记录. 如何判断一个对象处于怎样的状态？  主要的依据是:\n 看该对象是否处于session管理； 看在数据库中有没有对应的记录.    瞬时态: 没有session管理,同时数据库没有对应记录;new了一个对象，此时对象就是瞬时态;瞬时态对象和数据库记录没有对关系，和session没有关系.\n  持久态: 有session管理，同时在数据库中有记录; 瞬时态对象执行save变化持久层;持久态对象和数据库记录存在对应关系，和session有关系.修改对象的属性，直接将数据保证到数据库.\n  管态/游离态： 没有session管理，但是在数据库中有记录.当session关闭后，持久态对象变为托管态;\t托管态对象和session没有关系，可能和数据库存在对象也可能不对应.\n  托管态和瞬时态区别\n 托管态对象:\t和session没有关联，可能和数据库存在对应关系，托管态对象中存在主键的值. 持久态对象:\t和session有状态 瞬时态对象:\t和session没有关联，和数据库记录没有对象关系，没有主键.  将瞬时态对象设置一个主键值，它就变为了托管态对象！！！\nsaveOrUpdate方法测试：  对瞬时态对象执行insert操作 对持久态对象执行update操作 对托管态对象执行update操作  懒加载: 　简述: 当我们查询一个对象的时候，在默认情况下,返回的只是该对象的普通属性（直接属性，不需要通过外键等查询得到）,当用户去使用对象属性时，才会向数据库发出再一次的查询.这种现象我们称为 lazy现象. 解决方法可以这样:\n 显示初始化代理对象： Hibernate.initized(student.getDepart())；与直接属性相连的对象. 修改对象关系文件 lazy 改写 lazy=false（说明：不要再one-to-many的one中设置false，在many中设置可以提高效率） 以上两种方法 不能直接解决懒加载问题. 通过过滤器(web项目) openSessionInView 添加一个过滤器  懒加载详解： 　懒加载（Load On Demand）是一种独特而又强大的数据获取方法，是指程序推迟访问数据库，这样可以保证有时候不必要的访问数据库，因为一次访问数据库是比较耗时的. 懒加载的几种情况： 首先明确一点：Domain Object是非finally的，才能实现懒加载. 解决方法：（因为要重写集合Set…）\n 明确初始化 在session还没有关闭时，访问一次xxx.getXxx()，强制访问数据库. 或者Hibernate.initialize(xxx)； openSessionView 这个往往需要过滤器配合使用(web程序)； 在ssh中，可以实现在service层，标准方式解决懒加载； 在映射文件中配置，lazy=false.  Hibernate的关系映射： mang-to-one： \u0026lt;!-- 对于private Department depart就不能用property many-to-one 的name=“变量名” column name=“将来生成表的名” --\u0026gt; \u0026lt;many-to-one name=\u0026quot;depart\u0026quot;\u0026gt; \u0026lt;column name=\u0026quot;depart_id\u0026quot;\u0026gt;\u0026lt;/column\u0026gt; \u0026lt;/many-to-one\u0026gt;  one-to-many 需求：查询所有一号部门的学生.\n常规思维：String hql = “from Student where dept.id=1”;\n还可以采用一对多：\n 现在Department中添加一个Set集合，并生成get/set方法； private Set stu;//一个部门可以对应多个学生 在Department.hbm.xml文件中添加  \u0026lt;set name=“集合对象属性名”\u0026gt; \u0026lt;key column=“外键名”\u0026gt; \u0026lt;one-to-many class=“集合存放的类名”\u0026gt; \u0026lt;/set\u0026gt; \u0026lt;!-- 配置onne-to-many关系 --\u0026gt; \u0026lt;set name=“stus” cascade=“联级”\u0026gt; \u0026lt;key column=“depart_id”\u0026gt; \u0026lt;one-to-many class=“Student”\u0026gt;  one-to-one 一对一有两种方式：\n 基于主键的一对一:   主键关联映射：其中一个表的主键依赖于另一张表的主键而建立起的一对一的关系，这两张互相关联的表的主键一致. 必须为one-to-one元素增加constrained=\u0026ldquo;true\u0026quot;属性，表明该类的主键由关联类生成.  【要点】Person - IdCard\n\u0026lt;id name=”id”\u0026gt; \u0026lt;generator class=”foreign”\u0026gt; \u0026lt;param name=”property”\u0026gt;idCard\u0026lt;/param\u0026gt; \u0026lt;/generator\u0026gt; \u0026lt;/id\u0026gt; \u0026lt;one-to-one name=”idCard” constrained=”true”/\u0026gt;  基于外键的一对一 和N-1相同，多添加一个unique=\u0026ldquo;true\u0026rdquo; 属性，用以表示N的一端必须唯一，加了唯一约束，即成了1-1  【举例】\n\u0026lt;one-to-one name=”idCard” property-ref=“person”/\u0026gt; \u0026lt;many-to-one name=”person” unique=”true” /\u0026gt; # property-ref：用于指定关联类的一个属性，这个属性将会和本外键相对应  many-to-many 　学生←→课程 顾客←→商品 student:one-to-mangy class Student{ private Integer id; private String name; private Set\u0026lt;StuCourse\u0026gt; stuCourses; }  从stucourse的角度看是 many-to-one class StuCourse{ private Integer id; private Student student; private Course course; private Integer grade; }  courset:one-to-mangy class Course{ private Integer id; private String name; private Set\u0026lt;StuCourse\u0026gt; stuCourses; }  cascade（Employee-Department、bbs项目等） 所谓级联操作就是说，当进行某个操作（添加/删除/修改…），就有hibernate自动完成. 例如：Department←→Employee当某个部门被删除后，员工也不会存在. 常用的cascade：none、all、save-update、delete、lock、refresh、evict、replic、persist、merge、delete-orphan(one-to-many). 一般对many-to-many，many-to-one不设置联级，在one-to-many和one-to-one中设置联级.\n在JSP页面中获取项目名称： \u0026lt;%=this.getServletContext().getContextPath()%\u0026gt; //java片段 ${ pageContext.request.contextPath } //通过标签  缓存 　缓存的作用主要用来提高性能，可以简单的理解成一个Map；使缓存涉及到三个操作：把数据放入缓存、从缓存获取数据、删除缓存中的无效数据.\n一级缓存（Session级共享） 一级缓存是 session对象中一块内存. 在同一个session中，查询一个对象是不会发出sql语句. session关闭一级缓存不存在了，再查询对象，会发出sql.\nsave，update，saveOrUpdate，load，get，list，iterator，lock这些方法都会将对象放在一级缓存中，一级缓存不能控制缓存的数量，所以要注意将大批量操作数据时可能造成内存溢出；可以用evict(清楚一个对象)，clear(清除所有对象)方法清除缓存的内容. 用HashMap来模拟一个Session缓存，加深对缓存的深入.\npackage com.hsp.view; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; public class MyCache { //使用map来模拟缓存 static Map\u0026lt;Integer,Student\u0026gt; maps=new HashMap\u0026lt;Integer,Student\u0026gt;(); public static void main(String[] args) { // TODO Auto-generated method stub getStudent(1); getStudent(1); getStudent(1); getStudent(1); getStudent(3); getStudent(3); } public static Student getStudent(Integer id){ //s.get() //先到缓存去 if(maps.containsKey(id)){ //在缓存有 System.out.println(\u0026quot;从缓存取出\u0026quot;); return maps.get(id); }else{ System.out.println(\u0026quot;从数据库中取\u0026quot;); //到数据库取 Student stu=MyDB.getStudentFromDB(id); //放入缓存 maps.put(id, stu); return stu; } } } //我的数据库 class MyDB{\tstatic List\u0026lt;Student\u0026gt; lists=new ArrayList\u0026lt;Student\u0026gt;(); //初始化数据库,假设有三个学生 static{ Student s1=new Student(); s1.setId(1); s1.setName(\u0026quot;aaa\u0026quot;); Student s2=new Student(); s2.setId(2); s2.setName(\u0026quot;bbb\u0026quot;); Student s3=new Student(); s3.setId(3); s3.setName(\u0026quot;ccc\u0026quot;); lists.add(s1); lists.add(s2); lists.add(s3); } public static Student getStudentFromDB(Integer id){ for(Student s: lists){ if(s.getId().equals(id)){ return s; } } return null;// 在数据库中没有. } } class Student{ private Integer id; private String name; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } }  二级缓存（SessionFactory级共享） 为什么需要二级缓存?\n　因为一级缓存有限(生命周期短),所以我们需要二级缓存(SessionFactory缓存)来弥补这个问题\n 需要配置 二级缓存是交给第三方去处理,常见的Hashtable , OSCache , EHCache 二级缓存的原理； 二级缓存的对象可能放在内存，也可能放在磁盘.  使用OsCache来演示二级缓存的使用.\n 配置二级缓存  对配置说明:\n\u0026lt;property name=\u0026quot;hbm2ddl.auto\u0026quot;\u0026gt;update\u0026lt;/property\u0026gt; \u0026lt;!-- 启动二级缓存 --\u0026gt; \u0026lt;property name=\u0026quot;cache.use_second_level_cache\u0026quot;\u0026gt;true\u0026lt;/property\u0026gt; \u0026lt;!-- 指定使用哪种二级缓存 --\u0026gt; \u0026lt;property name=\u0026quot;cache.provider_class\u0026quot;\u0026gt;org.hibernate.cache.OSCacheProvider\u0026lt;/property\u0026gt; \u0026lt;mapping resource=\u0026quot;com/hsp/domain/Department.hbm.xml\u0026quot; /\u0026gt; \u0026lt;mapping resource=\u0026quot;com/hsp/domain/Student.hbm.xml\u0026quot; /\u0026gt; \u0026lt;!-- 指定哪个domain启用二级缓存 特别说明二级缓存策略: 1. read-only 2. read-write 3. nonstrict-read-write 4. transcational --\u0026gt; \u0026lt;class-cache class=\u0026quot;com.hsp.domain.Student\u0026quot; usage=\u0026quot;read-write\u0026quot;/\u0026gt;  可以把oscache.properties文件放在 src目录下，这样你可以指定放入二级缓存的对象capacity 大小. 默认1000. 使用  // TODO Auto-generated method stub //通过获取一个sesion,让hibernate框架运行(config-\u0026gt;加载hibernate.cfg.xml) Session s=null; Transaction tx=null;\ttry { //我们使用基础模板来讲解. s=HibernateUtil.openSession(); tx=s.beginTransaction();\t//查询45号学生\tStudent stu1=(Student) s.get(Student.class, 45);//45-\u0026gt;一级缓存\tSystem.out.println(stu1.getName()); tx.commit();\t} catch (Exception e) { e.printStackTrace(); if(tx!=null){ tx.rollback(); } }finally{\tif(s!=null \u0026amp;\u0026amp; s.isOpen()){ s.close(); } }\tSystem.out.println(\u0026quot;*********************************\u0026quot;); try { //我们使用基础模板来讲解. s=HibernateUtil.openSession(); tx=s.beginTransaction();\t//查询45号学生\tStudent stu1=(Student) s.get(Student.class, 45);\tSystem.out.println(stu1.getName());\tStudent stu3=(Student) s.get(Student.class, 46);\tSystem.out.println(stu3.getName()); tx.commit();\t} catch (Exception e) { e.printStackTrace(); if(tx!=null){ tx.rollback(); } }finally{ if(s!=null \u0026amp;\u0026amp; s.isOpen()){ s.close(); } } //完成一个统计，统计的信息在Sessfactory //SessionFactory对象. Statistics statistics= HibernateUtil.getSessionFactory().getStatistics(); System.out.println(statistics); System.out.println(\u0026quot;放入\u0026quot;+statistics.getSecondLevelCachePutCount()); System.out.println(\u0026quot;命中\u0026quot;+statistics.getSecondLevelCacheHitCount()); System.out.println(\u0026quot;错过\u0026quot;+statistics.getSecondLevelCacheMissCount());  在配置了二级缓存后，请大家要注意可以通过 Statistics,查看你的配置命中率高不高.  事务管理  在hibernate设置隔离级别 在hibernate.cfg.xml中设置隔离级别：  \u0026lt;!-- 事务隔离级别 --\u0026gt; \u0026lt;property name=\u0026quot;hibernate.connection.isolation\u0026quot;\u0026gt;4\u0026lt;/property\u0026gt;  事务控制在哪里进行？  service(){ session.beginTransaction;//开启事务 try{ 调用dao方法1 调用dao方法2 ..... session.getTransaction().commit();//提交事务 }catch(Exception ex){ session.getTransaction().rollback();//回滚事务 } }  session如何管理 　在service接口中，每个dao请求中使用同一个session即使用同一个数据库连接，保证多个dao调用在一个事务中. 在service执行开始处开启一个新session，将session和当前线程绑定，在每个dao调用中获取当前线程绑定的session，实现每个dao获取到的session是同一个session. 主键增长策略  increment: 自增，每次增长1, 适用于所有数据库. 但是不要使用在多进程,主键类型是数值型 select max(id) from Student identity : 自增，每次增长1, 适用于支持identity的数据(mysql,sql server), 主键类型是数值 sequence native:会根据数据类型来选择，使用identity,sequence ,hilo select hibernate_sequence.nextval from dual.主键类型是数值long , short ,int  \u0026lt;id name=\u0026quot;id\u0026quot; type=\u0026quot;java.lang.Integer\u0026quot;\u0026gt; \u0026lt;generator class=\u0026quot;native\u0026quot;/\u0026gt; \u0026lt;/id\u0026gt;  hilo:hilo标识符生成器由Hibernate按照一种high/low算法生成标识符.  用法:\n\u0026lt;id name=”id” type=”java.lang.Integer” column=”ID”\u0026gt; \u0026lt;generator class=”hilo”\u0026gt; \u0026lt;param name=”table”\u0026gt;my_hi_value\u0026lt;/param\u0026gt; \u0026lt;param name=”column”\u0026gt;next_value\u0026lt;/param\u0026gt; \u0026lt;/generator\u0026gt; \u0026lt;/id\u0026gt;  uuid: 会根据uuid算法，生成128-bit的字串 主键属性类型不能是数值型，而是字串型 assigned: 用户自己设置主键值，所以主键属性类型可以是数值，字串 映射复合主键 foreign: 在one-to-one的关系中，有另一张表的主键(Person) 来决定 自己主键/外键( IdCard)  给出一个简单原则:\n 针对oracle [主键是int/long/short 建议使用 sequence] 主键是String 使用uuid或者assinged 针对 mysql [主键是 int/long/short 建议使用increment/assigend ,如果是字串 UUId/assigned] 针对 sql server [主键是 int/long/short 建议使用identity/native/assinged ,如果主键是字串，使用uuid/assigned ] one-to-one 又是基于主键的则使用foreign  Hibernate不适合的场景 　不适合OLAP（On-Line-Analytical Processing联机分析处理），已查询分析数据为主流的系统，适合OLTP（On-line transaction Processing联机事务处理）\n    OLTP OLAP     用户 操作人员，底层管理人员 决策人员，高级管理人员   功能 日常操作管理 分析决策   DB设计 面向应用 面向主题   数据 当前的，最新的，细节的，二维的分立的 历史的、聚集的、多维的集成的，统一的   存取 读/写数十条记录 读/写上百万 条记录   工作单位 简单事务 复杂查询   用户 上千个 上百个   DB大小 100M-GB 100GB-TB    ","date":1611878400,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1611878400,"objectID":"fe1a2ed54399c32bb0a8893cc5ff6170","permalink":"https://CoMath21.github.io/post/1-hibernate/","publishdate":"2021-01-29T00:00:00Z","relpermalink":"/post/1-hibernate/","section":"post","summary":"具体介绍Hibernate的相关内容.","tags":["编程语言","Java","Hibernate"],"title":"Hibernate学习笔记","type":"post"},{"authors":["Xin态好先生","CoMath"],"categories":["学习笔记","编程语言"],"content":"1、什么是Struts2: 　Struts2是一个基于MVC设计模式的Web应用框架，它本质上相当于一个servlet，在MVC设计模式中，Struts2作为控制器(Controller)来建立模型与视图的数据交互. Struts2是WebWork2基础发展而来的.\n2、Struts2优点：  Struts2的应用可以不依赖于Servlet API（request,response）和struts API；这种设计属于无侵入式设计. Struts2提供了拦截器,利用拦截器可以进行AOP编程,实现如权限拦截等功能. Struts2提供类型转换器,可以把特殊类型参数转换程序要的类型. Struts2提供支持多种表现层技术,如JSP,freeMarker,Velocity等. Struts2的输入校验可以对指定的方法进行校验. Struts2提供了全局范围、包范围、和Action范围的国际换资源文件管理实现.  3、搭建Struts2开发环境 3.1、开发Struts2应用依赖的jar文件 开发Struts2应用需要依赖的jar文件在解压目录的lib文件夹下,不同的应用需要的JAR包是不同的. 开发Struts2程序最少需要的JAR.\n struts2-core-2.x.x.jar ：Struts2框架的核心类库. xwork-2.x.x jar ：XWork类库,Struts2在其上构建. ognl-2.6.x.jar ：对象图导航语言(Object Graph Navigation Language),struts2框架通过其读写对象的属性. freemarker-2.3.x.jar ：Struts 2的UI标签的模板使用FreeMarker编写. commons-logging-1.1.x jar ：ASF出品的日志包,Struts2框架使用这个日志包来支持Log4J和JDK1.4+的日志记录. commons-fileupload-12 .1.jar ：文件上传组件,2 .1.6版本后必须加入此文件.   3.2、搭建Struts2开发环境  找到Struts2需要的几个jar包； 编写配置struts2的配置文件：src下创建struts.xml文件； 在web.xml中加入struts2 MVC框架启动配置  \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;struts2\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.apache.struts2.dispatcher.ng.filter. StrutsPrepareAndExecuteFilter\u0026lt;/filter-class\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;struts2\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt;  4、Struts.xml配置中的包介绍  配置包时必须指定name属性： 该属性名字可以任意,但是必须唯一,主要作用在于：如果其他包要继承该包就必须通过该属性(name属性)进行引用. 包的namespace属性： 用于定义该包的命名空间,命名空间作为访问该包下Action路径的一部分. 如果不配置,默认为””(空字符串). 继承方法extends： 通常每个包都应该继承struts-default包,因为Struts2很多核心的功能都是拦截器来实现的. struts-default定义了这些拦截器和Result类型；struts-default包是在struts2-core-2.jar文件中的struts-default.xml中定义的,struts-default.xml也是Struts2默认配置文件. Struts2每次都会自动加载struts-default.xml文件.\n  4.1、Action配置中的各种默认值  如果没有为action指定class,默认是ActionSupport. 如果没有为action指定method,默认执行action中的execute()方法. 如果没有指定action的name属性,默认值为success.  Action中的result的各种转发类型 　Struts2常用的结果类型有：dispathcher(默认值)、redirect(重定向)、redirectAction、plainText 在result中可以使用${属性名}表达式访问action中的属性,表达式里的属性名对应action中的属性.\n dispathcher(默认值)：内部请求转发 redirect(重定向)：  // 格式： \u0026lt;result type=\u0026quot;redirect\u0026quot;\u0026gt;/hello.jsp\u0026lt;/result\u0026gt; // 如果重定向需要带参数,则用： \u0026lt;result type=\u0026quot;redirect\u0026quot;\u0026gt;/hello.jsp?id=${id}\u0026lt;/result\u0026gt;  此时,需要在对应的Action下有对应的变量,并且提供get属性. 注意：重定向不能访问WEB-INF下的文件.\n redirectAction(在其他*Action下)：  // 格式： \u0026lt;action name=\u0026quot; redirectActionName\u0026quot;\u0026gt; \u0026lt;result type=\u0026quot; redirectAction\u0026quot;\u0026gt;重定向的name\u0026lt;/result\u0026gt; \u0026lt;/action\u0026gt; // 如果不不在同一个包下需配置项 \u0026lt;result type=\u0026quot; redirectAction\u0026quot;\u0026gt; \u0026lt;param name=\u0026quot; actionName\u0026quot;\u0026gt;xxx\u0026lt;/param\u0026gt; \u0026lt;param name=\u0026quot; namespace\u0026quot;\u0026gt;/…/…\u0026lt;/param\u0026gt; \u0026lt;/result\u0026gt;  补充.\n中文字符编码、解码\n 编码(java.net.URLEncoder)：URLEncoder.encode(\u0026quot;字符串\u0026quot;,\u0026quot;UTF-8\u0026quot;); 解码(java.net.URLDecoder)：URLDecoder.encode(new String (request.getParameter(\u0026quot;属性名\u0026quot;).getBytes(\u0026quot;ISO8859-1\u0026quot;),\u0026quot;UTF-8\u0026quot;),\u0026quot;UTF-8\u0026quot;); JSP文件中可以用$(param.属性名)访问Action中的属性(会乱码)  　plaintext(显示原始文件内容的重定向)：例如某功能需要查看源代码\n\u0026lt;action name=\u0026quot; plainText\u0026quot;\u0026gt; \u0026lt;result type=\u0026quot; plainText\u0026quot;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;/action\u0026gt;  注意：当该JSP文件存在中文的时候,会乱码！  需要加入：\n\u0026lt;param name=\u0026quot; location\u0026quot;\u0026gt;/xxx.jsp\u0026lt;/param\u0026gt;\u0026lt;!—定向的路径--\u0026gt; \u0026lt;param name=\u0026quot; charSet\u0026quot;\u0026gt;UTF-8\u0026lt;/param\u0026gt;\u0026lt;!--指定读取文件的编码--\u0026gt;  附：Struts2的全视图 单个包下：\n\u0026lt;package name=\u0026quot; xxx\u0026quot; namespace=\u0026quot; /…/…\u0026quot; extends=\u0026quot; struts-default\u0026quot;\u0026gt; \u0026lt;global-results\u0026gt;\t\u0026lt;result type=\u0026quot; mess…\u0026quot;\u0026gt;/…/…\u0026lt;/result\u0026gt; \u0026lt;/global-results\u0026gt; \u0026lt;/package\u0026gt;  全局：(在一个包中写,然后其他包继承该包)\n4.2、为Action属性注入值 \u0026lt;package name=\u0026quot; xxx\u0026quot; namespace=\u0026quot; /…/…\u0026quot; extends=\u0026quot; struts-default\u0026quot;\u0026gt; \u0026lt;action name=\u0026quot; list\u0026quot; class=\u0026quot;com.haibao.HelloWorldAction\u0026quot; method=\u0026quot;execute\u0026quot;\u0026gt; \u0026lt;param name=\u0026quot;path \u0026quot;\u0026gt;/image\u0026lt;/param\u0026gt; \u0026lt;result name=\u0026quot;success \u0026quot;\u0026gt;/xxx.jsp \u0026lt;/result\u0026gt; \u0026lt;/action\u0026gt; \u0026lt;/package\u0026gt;  附：在HelloWorldAction下必须存在“path”属性的get方法 ,访问xxx.jsp得到的是“/image”\n5、指定struts2处理的请求后缀 5.1、默认后缀及修改 默认后缀：.action 默认后缀可以通过常量\u0026quot;struts.action.extension\u0026quot;进行修改\n\u0026lt;constant name=\u0026quot; struts.action.extension\u0026quot; value=\u0026quot;do\u0026quot;/\u0026gt;  如果用户指定多个请求后缀,则多个后缀之间以英文逗号( , )隔开\n\u0026lt;constant name=\u0026quot; struts.action.extension\u0026quot; value=\u0026quot;do,action\u0026quot;/\u0026gt;  5.2、常用的常量 \u0026lt;!--指定默认编码集,作用于HTTPServletRequest的setCharacterEncoding方法和freemarker、velocity的输出--\u0026gt; \u0026lt;constant name=\u0026quot; struts.i18n.encoding\u0026quot; value=\u0026quot;UTF-8\u0026quot;/\u0026gt; \u0026lt;!-- 该属性指定需要的struts2处理的后缀请求如果用户指定多个请求后缀,则多个后缀之间以英文逗号(,)隔开--\u0026gt; \u0026lt;constant name=\u0026quot; struts.action.extension\u0026quot; value=\u0026quot;do,action\u0026quot;/\u0026gt; \u0026lt;!-- 设置浏览器是否缓存静态内容. 默认值为true(生产环境下使用)--\u0026gt; \u0026lt;constant name=\u0026quot;struts.serve.static.browserCache\u0026quot; value=\u0026quot;false\u0026quot;/\u0026gt; \u0026lt;!-- 当struts的配置文件修改后,系统是否自动重新加载该文件,默认false(生产环境下使用) --\u0026gt; \u0026lt;constant name=\u0026quot; struts.configuration.xml.reload\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;!-- 开发模式下使用,这样可以打印出更详细的错误信息 --\u0026gt; \u0026lt;constant name=\u0026quot; struts.devMode\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;!-- 默认的视图主题 --\u0026gt; \u0026lt;constant name=\u0026quot; struts.ui.theme\u0026quot; value=\u0026quot;smple\u0026quot;/\u0026gt; \u0026lt;!-- 与Spring集成时,指定有Spring负责action对象的创建 --\u0026gt; \u0026lt;constant name=\u0026quot; struts.objectFactory\u0026quot; value=\u0026quot;spring\u0026quot;/\u0026gt; \u0026lt;!-- 该属性设置Struts2是否支持动态方法调用,默认为true --\u0026gt; \u0026lt;constant name=\u0026quot; struts.enable.DynamicMethodlnvocation\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;!-- 上传文件的大小限制 --\u0026gt; \u0026lt;constant name=\u0026quot; struts.multipart.maxSize\u0026quot; value=\u0026quot;10701096\u0026quot;/\u0026gt;  5.3、常量的定义 常量可以在struts.xml或struts.propreties中配置,建议在struts.xml中配置 在struts.xml文件中配置常量：\n\u0026lt;struts\u0026gt; \u0026lt;constant name=\u0026quot;struts.action.extension\u0026quot; value=\u0026quot;do\u0026quot;\u0026gt; \u0026lt;/struts\u0026gt;  在struts.propreties中配置常量：\nstruts.action.extension=do  常量可以在下面多个配置文件中定义,加载常量的搜索顺序为：\n struts-default.xml struts-plugin.xml struts.xml struts.propreties web.xml  多个文件中配置了同一个常量,则后一个文件中配置的常量值会覆盖前面文件中配置的常量值.\n6、Struts2的处理流程 StrutsPrepareAndExecuteFilter是Struts的核心控制器,他负责拦截由/*指定的所有用户请求,当用户请求到达时,给Filter会过滤用户的请求. 默认情况下,如果用户请求路径不带后缀或者以.action结尾,这时请求被转入Struts2框架处理,否则Struts2框架将略过该请求的处理. 当请求转入Struts2框架处理时会经过一系列的拦截器,然后到Action. 与Struts1不同,Struts2对用户的每一次请求都会创建一个Action,所以Struts2中的Action是线程安全的.\n为应用指定多个Struts配置文件\n　在大部分应用里,随着应用规模的增加,系统中Action的数量也会大大增加,导致struts.xml配置文件变得臃肿,为了避免struts.xml文件过于庞大,提高struts.xml文件的可读性,可以将一个struts.xml配置文件分解成多个配置文件,然后在struts.xml文件中包含其他配置文件(通过元素指定多个配置文件)\n\u0026lt;struts\u0026gt; \u0026lt;include file=\u0026quot;struts-user.xml\u0026quot;/\u0026gt; \u0026lt;include file=\u0026quot;struts-order.xml\u0026quot;/\u0026gt; \u0026lt;/struts\u0026gt;  7、动态方法调用：  动态方法调用DMI（动态指定）,可以在url地址中动态指定action执行哪个方法,可以通过action+!+方法名. (注：只要Action对象中有这个方法,并且返回类型为String就可以调用,这样struts.xml文件配置文件就可以不需要配置method属性)： 设置Struts2是否支持动态方法调用,如果没有这一行要加上去,要不然会报错误,如果你加上这一行,但是你把value值改成false,也会报错！   8、使用通配符定义action 　其中*匹配所有,在method=\u0026quot;{数字}\u0026ldquo;中用{数字}表示匹配第几个*,其中跳转页面的命名也是根据第一个*的值进行的. 9、请求参数的接收 　在Action中必须存在该属性并且存在该属性的set方法,这样在url中赋值才能接收到get方法直接在url后面加入“?属性名=属性值\u0026amp;属性名=属性值”\n9.1、基本类型 9.2、复合类型 （为了减少复杂度,尽量用复合类型） 原理：Struts2首先通过反射技术调用Person的默认构造器创建product对象,然后再通过反射技术调用product中与请求参数同名的属性的setter方法来获取请求参数的值.\n10、关于Struts2.1.6接收中文请求参数乱码问题 　Struts2.1.6版本中存在一个Bug,即接收到的中文请求参数为乱码（以post方法提交）,原因是struts2.1.6在获取并使用了请求参数后才调用HttpServletRequest的setCharacterEncoding()方法进行编码设置,导致应用使用的就是乱码请求参数.\n解决方法：新建一个Filter,把这个Filter放置在Struts2的Filter之前,然后在doFilter()方法里添加一下代码：\npublic void doFilter(…){ HttpServletRequest req = (HttpServletRequest)request; req.setCharacterEncoding(\u0026quot;UTF-8\u0026quot;); filterchain.doFilter(request,response); }  11、自定义类型转换器 11.1、局部类型转换器：  首先需要定义类并继承DefaultTypeConverter类; 在Action类所在的包下放置ActionClassName-conversion.properties文件；其中ActionClassName是Action的类名,后面的-conversion.properties是固定写法; 在.properties文件中内容为：属性名称=类型转换器的全类名. 以出生年月为例：   11.2、全局类型转换器： 在src(根目录)下放置xwork-conversion.properties. 文件中的内容为： 带转换的类型=类型转换器的全类名 例如：java.util.Date=com.haibao.… 11.3、访问或添加属性 仅仅是为了访问添加：\npublic String scope() throws Exception{//方法 ActionContext ctx = ActionContext.getContext(); ctx.getApplication().put(\u0026quot;app\u0026quot;,\u0026quot;应用范围\u0026quot;);//往ServletContext里放入app ctx.getSession().put(\u0026quot;ses\u0026quot;,\u0026quot;session范围\u0026quot;)；//往ServletContext里放入ses ctx.put(\u0026quot;req\u0026quot;,\u0026quot;request范围\u0026quot;)；//往ServletContext里放入req return \u0026quot;scope\u0026quot;;// }  JSP中：\n\u0026lt;body\u0026gt; ${applicationScope.app}\u0026lt;br\u0026gt; ${sessionScope.ses}\u0026lt;br\u0026gt; ${requestScope.ses}\u0026lt;br\u0026gt; \u0026lt;body\u0026gt;  要是想得到对象：\n// 方法一：通过ServletActionContext类直接实现 public String rsa() throws Exception{//方法 HttpServletRequest request = ServletActionContext.getRequest(); ServletContext servletContext = ServletActionContext.getServletContest(); request.setAttribute(\u0026quot;req\u0026quot;,\u0026quot;应用范围\u0026quot;); request.getSession().setAttribute(\u0026quot;ses\u0026quot;,\u0026quot;session范围\u0026quot;)； servletContext.setAttribute(\u0026quot;app\u0026quot;,\u0026quot;应用范围\u0026quot;); return \u0026quot;scope\u0026quot;;// } // 方法二：通过指定接口,有Struts框架运行时注入 public class HelloWorldAction implements ServletRequestAware, ServletResponseAware,ServletContextAware{ private HttpServletRequest requesr; private ServletContextResponse Context; private HttpServletResponse response; public void setServletRequest(HttoServletRequest req){ this.request = req; } public void setServletResponse(){ } public void setServletContext(){ }  12、文件上传 12.1、单文件上传 步骤\n 第一步：在WEB-INF/lib下加入commons-fileupload-1.2.1.jar（2.1版本之后必须添加）、commons-io.jar（需要用到里面的工具类） 第二步：把form表的enctype设置为：“multipart/form-data”  \u0026lt;form action=\u0026quot;${pageContext.request.contextPath}/uploadAction_execute.action\u0026quot; enctype=\u0026quot;multipart/form-data\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; 文件：\u0026lt;input type=\u0026quot;file\u0026quot; name=\u0026quot;image\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;上传\u0026quot;\u0026gt; \u0026lt;/form\u0026gt;  第三步：在Action类中添加以下属性  public class UploadAction { private File image;// 文件名称 // 如果想得到上传文件的名称,则定义文件名. 格式：文件名称+FileName private String imageFileName;// 得到上传文件名称 // 如果想得到文件的类型,则定义文件名. 格式：文件名称+ContextType private String imageContextType; public String getImageFileName() { return imageFileName; } public void setImageFileName(String imageFileName) { this.imageFileName = imageFileName; } // 提供与字段名称相符的get、set属性,以便得到上传的文件 public File getImage() { return image; } public void setImage(File image) { this.image = image; } public String execute() throws Exception { // 在该方法下进行保存 String realPath = ServletActionContext.getServletContext().getRealPath( \u0026quot;/images\u0026quot;);// 得到根目录 System.out.println(\u0026quot;*****\u0026quot; + realPath + \u0026quot;****\u0026quot;); if (image != null) { File savefile = new File(new File(realPath), imageFileName);// 保存到... if (!savefile.getParentFile().exists()) savefile.getParentFile().mkdirs(); FileUtils.copyFile(image, savefile);// 调用commons-io.jar下的工具类Copy文件到指定位置 ActionContext.getContext().put(\u0026quot;message\u0026quot;, \u0026quot;上传成功\u0026quot;);// 返回信息 } return \u0026quot;success\u0026quot;; } }  12.2、多文件上传 　只需要将单文件上传的第三步：在Action类中添加以下属性中把单个文件变成数组.\npublic class moreUploadAction { private File[] image;// 文件名称 // 如果想得到上传文件的名称,则定义文件名. 格式：文件名称+FileName private String[] imageFileName;// 得到上传文件名称 // 如果想得到文件的类型,则定义文件名. 格式：文件名称+ContextType private String[] imageContextType; public File[] getImage() { return image; } public void setImage(File[] image) { this.image = image; } public String[] getImageFileName() { return imageFileName; } public void setImageFileName(String[] imageFileName) { this.imageFileName = imageFileName; } public String[] getImageContextType() { return imageContextType; } public void setImageContextType(String[] imageContextType) { this.imageContextType = imageContextType; } public String execute() throws Exception { // 在该方法下进行保存 String realPath = ServletActionContext.getServletContext().getRealPath( \u0026quot;/images\u0026quot;);// 得到根目录 System.out.println(\u0026quot;*****\u0026quot; + realPath + \u0026quot;****\u0026quot;); if (image != null) { File savedir = new File(realPath); if (!savedir.exists()) savedir.mkdirs(); for (int i = 0; i \u0026lt; image.length; i++) { File savefile = new File(savedir, imageFileName[i]);// 保存到... FileUtils.copyFile(image[i], savefile);// 调用commons-io.jar下的工具类Copy文件到指定位置 } ActionContext.getContext().put(\u0026quot;message\u0026quot;, \u0026quot;上传成功\u0026quot;);// 返回信息 } return \u0026quot;success\u0026quot;; } }  13、自定义拦截器 需求：对于登陆的用户可以访问Action中的所有方法,而没有登录的用户则不可以访问任何方法.\n方法：添加自定义拦截器. 实现com.opensymphony.xwork2.interceptor.interceptor接口\n@Override public String intercept(ActionInvocation arg0) throws Exception { // 当拦截到Action时执行该方法 // 得到session中存在的对象 Object user = ActionContext.getContext() .getSession().get(\u0026quot;user\u0026quot;); // 如果希望被拦截的的方法执行,调用arg0.invoke(); if (user != null) return arg0.invoke();//如果User不为null,代表合法用户,允许访问方法 // 返回的是Action中对应方法的返回值String ActionContext.getContext().put(\u0026quot;message\u0026quot;, \u0026quot;请先登录\u0026quot;); return \u0026quot;success\u0026quot;; }  在struts.xml中定义拦截器\n\u0026lt;!-- 定义拦截器 --\u0026gt; \u0026lt;interceptors\u0026gt; \u0026lt;!-- 自定义拦截器 --\u0026gt; \u0026lt;interceptor name=\u0026quot;permission\u0026quot; class=\u0026quot;com.haibao.interceptor.PermissionInterceptor\u0026quot; /\u0026gt; \u0026lt;!-- 定义拦截器栈 目的：使得Struts2自带的拦截器有效 --\u0026gt; \u0026lt;interceptor-stack name=\u0026quot;permissionStack\u0026quot;\u0026gt; \u0026lt;interceptor-ref name=\u0026quot;defaultStack\u0026quot;/\u0026gt; \u0026lt;interceptor-ref name=\u0026quot;permission\u0026quot;/\u0026gt; \u0026lt;/interceptor-stack\u0026gt; \u0026lt;/interceptors\u0026gt; \u0026lt;action name=\u0026quot;loginAction_*\u0026quot; class=\u0026quot;com.haibao.action.LoginAction\u0026quot;\tmethod=\u0026quot;{1}\u0026quot;\u0026gt; \u0026lt;result name=\u0026quot;success\u0026quot;\u0026gt;/WEB-INF/page/LoginPage.jsp\u0026lt;/result\u0026gt; \u0026lt;interceptor-ref name=\u0026quot;permissionStack\u0026quot;/\u0026gt; \u0026lt;/action\u0026gt;  注意： 如果直接在action中定义使用拦截器,则不会在使用Struts自带拦截器！这样Struts2的优势就没有了，所以引入拦截器栈的概念，在拦截器栈中要把Struts的拦截器写在前面，以保证web项目会首先执行Struts再带的拦截器. 如果想所有的程序都是用自定义的拦截器，可以使用：\n\u0026lt;default-interceptor-ref name=\u0026quot;permissionStack\u0026quot;/\u0026gt;  效果演示：\n直接访问会被拦截： 登录后访问 14、输入校验 　Struts2中可以实现对action的所有方法进行校验或者对action的指定方法进项校验，实现方法有两种：\n 采用手工编写代码实现   对所有方法进行校验 重写validate()方法实现，validate()方法会校验action中所有的与execute方法签名相同的方法. 当某个数据校验失败时，调用addFieldError()方法往系统的fieldErrors添加校验失败信息，（为了使用addFieldError()方法，action可以继承ActionSupport），如果系统的fieldError包含失败信息，struts2会将请求转发到名为input的result. 在input视图中可以通过\u0026lt;s:fielderror/\u0026gt;显示失败信息. 需要引入标签  \u0026lt;%@ taglab url=\u0026quot;/struts-tags\u0026quot; prefix=\u0026quot;s\u0026quot;%\u0026gt;  public void validate(){ if(this.mobile==null||\u0026quot;\u0026quot;.equals(this.mobile.trim())){ this.addFieldError(\u0026quot;username\u0026quot;,\u0026quot;用户名不能为空\u0026quot;); } if(this.mobile==null||\u0026quot;\u0026quot;.equals(this.mobile.trim())){ this.addFieldError(\u0026quot;mobile\u0026quot;,\u0026quot;手机号不能为空\u0026quot;); }else{ if(!Pattern.compile(\u0026quot;^1[358]\\\\d{9}\u0026quot;).matcher(this.mobile.trim()).matches()){ this.addFieldError(\u0026quot;mobile\u0026quot;,\u0026quot;手机号格式不正确\u0026quot;); } }\t}   对指定方法进行校验  　重写validateXxx()方法实现，validate()方法会校验action中所有的与execute方法签名相同的方法. 当某个数据校验失败时，调用addFieldError()方法往系统的fieldErrors添加校验失败信息，（为了使用addFieldError()方法，action可以继承ActionSupport），如果系统的fieldError包含失败信息，struts2会将请求转发到名为input的result. 在input视图中可以通过\u0026lt;s:fielderror/\u0026gt;显示失败信息. 需要引入标签\n\u0026lt;%@ taglab url=\u0026quot;/struts-tags\u0026quot; prefix=\u0026quot;s\u0026quot;%\u0026gt;  public void validateUpdata(){ if(this.mobile==null||\u0026quot;\u0026quot;.equals(this.mobile.trim())){ this.addFieldError(\u0026quot;username\u0026quot;,\u0026quot;用户名不能为空\u0026quot;); } if(this.mobile==null||\u0026quot;\u0026quot;.equals(this.mobile.trim())){ this.addFieldError(\u0026quot;mobile\u0026quot;,\u0026quot;手机号不能为空\u0026quot;); }else{ if(!Patten.compile(\u0026quot;^1[358]\\\\d{9}\u0026quot;).matcher(this.mobile.trim()).matches()){ this.addFieldError(\u0026quot;mobile\u0026quot;,\u0026quot;手机号格式不正确\u0026quot;); } } }   输入校验的流程  类型转换器队请求参数执行类型转换，并把转换后的赋值给action中的属性. 如果在执行类型转换的过程中出现异常，系统会将异常信息保存到ActionContext，conversionError拦截器将异常信息封装到fieldErrors里. 不管类型转换是否出现异常，都会进入第3步. 系统通过反射技术先调用action中的validateXxx()方法，Xxx为方法名. 在调用action中的validate()方法. 经过上面4步，如果系统中的fieldErrors存在错误信息（即存放错误信息的集合的size\u0026gt;0），系统自动将请求转发至名称为input视图. 如果系统中的fieldErrors没有任何错误信息，系统将执行action中的处理方法.    基于XML配置方式实现  　a) 对所有方法进行校验\n　在Action相同包下创建ActionClassName-validation.xml文件. Struts2 的验证规则大概有以下数种：\n required:必填校验器，要求field的值不能为null requiredstring:必填字符串校验器，要求field的值不能为null,并且长度大于0，默 认情况下会对字符串去掉前后空格 int:整数校验器，要求field的值必须在整数范围内，min指定最小值，max指定最大值 double:双精度浮点数校验器 date:日期校验器 expression:表达式校验器 fieldexpression:字段表达式校验器 email:电子邮件校验器，要求如果field的值非空，则必须是合法的邮件地址 url:网址校验器，要求如果field的值非空，则必须是合法的url地址 visitor:Visitor校验器，用于校验action的复合属性，它指定一个校验文件用于校验复合属性中的属性 conversion:转换校验器 stringlength:字符串长度校验器 regex:正则表达式校验器  常用的验证规则：  必填检验  \u0026lt;validators\u0026gt; \u0026lt;field name=\u0026quot;username\u0026quot;\u0026gt; \u0026lt;field-validator type=\u0026quot;required\u0026quot;\u0026gt; \u0026lt;message\u0026gt;指定检验失败的提示信息\u0026lt;/message\u0026gt; \u0026lt;/field-validator\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/validators\u0026gt;  必填字符串检验  \u0026lt;validators\u0026gt; \u0026lt;field name=\u0026quot;username\u0026quot;\u0026gt; \u0026lt;field-validator type=\u0026quot;requiredstring\u0026quot;\u0026gt; \u0026lt;param name=\u0026quot;trim\u0026quot;\u0026gt;true\u0026lt;/param\u0026gt; \u0026lt;message\u0026gt;指定检验失败的提示信息\u0026lt;/message\u0026gt; \u0026lt;/field-validator\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/validators\u0026gt;  整数检验器/浮点检验  \u0026lt;validators\u0026gt; \u0026lt;field name=\u0026quot;age\u0026quot;\u0026gt; \u0026lt;field-validator type=\u0026quot;int\u0026quot;\u0026gt; \u0026lt;param name=\u0026quot;min\u0026quot;\u0026gt;1\u0026lt;/param\u0026gt; \u0026lt;param name=\u0026quot;max\u0026quot;\u0026gt;150\u0026lt;/param\u0026gt; \u0026lt;message\u0026gt;年纪必须在1到150之间\u0026lt;/message\u0026gt; \u0026lt;/field-validator\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/validators\u0026gt;  日期检验  \u0026lt;validators\u0026gt; \u0026lt;field name=\u0026quot;birth\u0026quot;\u0026gt; \u0026lt;field-validator type=\u0026quot;date\u0026quot;\u0026gt; \u0026lt;param name=\u0026quot;min\u0026quot;\u0026gt;1900-01-01\u0026lt;/param\u0026gt; \u0026lt;param name=\u0026quot;max\u0026quot;\u0026gt;2050-02-21\u0026lt;/param\u0026gt; \u0026lt;message key=\u0026quot;birth.range\u0026quot;/\u0026gt; \u0026lt;/field-validator\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/validators\u0026gt;  字段表达式检验器(要求指定字段满足一个逻辑表达式)  \u0026lt;validators\u0026gt; \u0026lt;field name=\u0026quot;re_pass\u0026quot;\u0026gt; \u0026lt;field-validator type=\u0026quot;fieldexpression\u0026quot;\u0026gt; \u0026lt;!--指定逻辑表达式 --\u0026gt; \u0026lt;param name=\u0026quot;expression\u0026quot;\u0026gt; (pass eq re_pass)\u0026lt;/param\u0026gt; \u0026lt;message\u0026gt;密码必须和确认密码相等\u0026lt;/message\u0026gt; \u0026lt;/field-validator\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/validators\u0026gt;  邮件地址校验  \u0026lt;validators\u0026gt; \u0026lt;field name=\u0026quot;email\u0026quot;\u0026gt; \u0026lt;field-validator type=\u0026quot;email\u0026quot;\u0026gt; \u0026lt;message\u0026gt;你的电子邮件地址必须是一个有效的电邮地址\u0026lt;/message\u0026gt; \u0026lt;/field-validator\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/validators\u0026gt;  网址检验  \u0026lt;validators\u0026gt; \u0026lt;field name=\u0026quot;url\u0026quot;\u0026gt; \u0026lt;field-validator type=\u0026quot;url\u0026quot;\u0026gt; \u0026lt;message\u0026gt;你的主页地址必须是一个有效的网址\u0026lt;/message\u0026gt; \u0026lt;/field-validator\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/validators\u0026gt;  字符串长度检验  \u0026lt;validators\u0026gt; \u0026lt;field name=\u0026quot;user\u0026quot;\u0026gt; \u0026lt;field-validator type=\u0026quot;stringlength\u0026quot;\u0026gt; \u0026lt;param name=\u0026quot;minlength\u0026quot;\u0026gt;4\u0026lt;/param\u0026gt; \u0026lt;param name=\u0026quot;maxlength\u0026quot;\u0026gt;20\u0026lt;/param\u0026gt; \u0026lt;message\u0026gt;你的用户名长度必须在4到20之间\u0026lt;/message\u0026gt; \u0026lt;/field-validator\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/validators\u0026gt;  正则表达式检验  \u0026lt;validators\u0026gt; \u0026lt;field name=\u0026quot;user\u0026quot;\u0026gt; \u0026lt;field-validator type=\u0026quot;regex\u0026quot;\u0026gt; \u0026lt;param name=\u0026quot;regex\u0026quot;\u0026gt;\u0026lt;![CDATA[(\\w{4,25})]]\u0026gt;\u0026lt;/param\u0026gt; \u0026lt;message\u0026gt;您输入的用户名只能是字母和数组，且长度必须在4到25之间\u0026lt;/message\u0026gt; \u0026lt;/field-validator\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/validators  　b) 对指定方法进行校验\n　取名更改为ActionClassName-ActionName-validation.xml\n注意\n 当action同时提供了两个校验方法，则按照“所有方法”，“指定方法”的顺序汇总后执行；如果后面的文件包含前面文件的方法发生冲突，则只是用后面文件中的校验规则. 当action继承了另外一个action，父类action的校验文件会先被搜索到.  15、国际化 准备资源文件，资源文件的命名格式如下：\nbaseName_language_country.propeties baseName_language.propeties baseName.propeties  其中baseName是资源文件的基本名，可以自定义，但language和country必须是java支持的语言和国家.\n 中国：baseName_zh_CN.properties 美国：baseName_en_US.properties  如果没有使用开发工具，对于中文的属性文件，应该使用JDK提供的native2ascii命令把文件转换为Unicode编码的文件. 命令使用如下： native2ascii 源文件.properties 目标文件.properties\n15.1、配置全局资源与输出国际化信息 当准备好资源文件之后，可以在struts.xml中通过struts.custom.i18n.resources常量把资源文件定义为全局变量：\n\u0026lt;constant name=\u0026quot;struts.custom.i18n.resources\u0026quot; value=\u0026quot;baseName\u0026quot;/ \u0026gt;  其中baseName为资源的基本名. 之后就可以在页面或者action中访问国际化信息：\n 在JSP页面中使用\u0026lt;s:text name=\u0026quot;\u0026quot;/\u0026gt;标签输出国际化信息；\u0026lt;s:text name=\u0026quot;user\u0026quot;/\u0026gt;,name为资源文件中的Key. 在Action类中，可以继承ActionSupport，使用getText()方法得到国际化信息，该方法的第一个参数用于指定资源文件中的Key. 在表单标签中，通过Key属性指定资源文件中的Key，如：  \u0026lt;s:textfield name=\u0026quot;realname\u0026quot; key=\u0026quot;use\u0026quot;/\u0026gt;  输出带占位符的国际化信息 资源文件中的内容如下： welcome={0},你好{1}\n15.2、JSP页面中输出占位符的国际化信息 \u0026lt;s:text name=\u0026quot;welcome\u0026quot;\u0026gt; \u0026lt;s:param\u0026gt;熊大\u0026lt;/s:param\u0026gt; \u0026lt;s:param\u0026gt;学习\u0026lt;/s:param\u0026gt; \u0026lt;s:text/\u0026gt;  　在Action类中获取带占位符的国际化信息，可以使用getText(String Key，String[] args)或者getText(String Key，List args)方法\n15.3、包范围资源文件 　在一个大型应用中，整个应用有大量的内容需要实现国际化，如果把国际化的内容放置在全局资源属性文件中，显然会导致资源文件变的庞大、臃肿、不便于维护，支个时候可以针对不同末班，使用包范围来组织国际化文件.\n方法：在java的包下放置package_language_country.properties资源文件，package为固定写法，处于该包及子包下的action都可以访问该资源，当查到指定Key的消息时，系统会先从package资源文件查找，当不存在对应的Key时，才会从常量struts.custom.i18n.resources指定的资源文件中寻找.\n15.4、Action范围资源文件 　在Action类所在的路径，放置ActionClassName_languaage_country.properties资源文件，ActionClassName为action类的简单名称；当指定key的消息时，系统会先从ActionClassName_languaage_country.properties资源文件中查找.\n15.5、JSP中直接访问某个资源文件 struts2提供了\u0026lt;s:i18n\u0026gt;标签，使用\u0026lt;s:i18n\u0026gt;标签可以在类路径下直接从某个资源文件中获取国际化数据，无需任何配置：\n\u0026lt;s:i18n name=\u0026quot;realname\u0026quot;\u0026gt; \u0026lt;s:text name=\u0026quot;realname\u0026quot;/\u0026gt; \u0026lt;s:i18n\u0026gt;  realname为要访问的资源文件的基本名\n如果要访问的资源文件在类路径的某个包下，可以访问：\n\u0026lt;s:i18n name=\u0026quot;com/haibao/action/package\u0026quot;\u0026gt; \u0026lt;s:text name=\u0026quot;realname\u0026quot;\u0026gt; \u0026lt;s:param\u0026gt;熊大\u0026lt;/s:param\u0026gt; \u0026lt;/s:text/\u0026gt; \u0026lt;s:i18n\u0026gt;  上面访问com.haibao.action包下基本名为package的资源文件.\n16、OGNL表达式语言 　OGNL是Object Graphic Navigation Language（对象图导航语言）的缩写，是一个开源的项目. Struts2框架采用OGNL作为默认的表达式语言.\n相对于EL表达式，OGNL提供了：\n 支持对象方法调用：如xxx.sayHello()； 支持类静态方法调用和值访问，表达式的格式为@[类全名（包括路径）]@[方法名|值名] 例如：@java.lang.String@format('foo %s'，bar) 或者 @com.haibao.Constant@APP_NAME 操作集合对象.  　Ognl有一个上下文（Context）概念，它实现了了java.utils.Map接口，Struts2中说明：\n 上下文（Context）的实现为ActionContext. 当Struts2接受一个请求时，会迅速创建ActionContext，ValueStack，action. 然后把action存进ValueStack，所以action的实例变量可以被OGNL访问. 访问上下文（Context）中的对象需要使用#符号标注命名空间. 如#application、#session. 如：#application['userName']==#application.userName//获得application中userName值.  （#session对象、#request对象、#paramete对象、attr对象—按照page—request—session—application顺序访问其属性）. OGNL设定了一个跟对象（root）对象，在Struts2中根对象就是ValueStack（值栈）. 如果访问根对象中的属性，则可以省略#命名空间，直接访问该对象的属性即可. 如：${foo}//获得栈值中某个对象的foo属性.  注意：Struts2中，OGNL表达式需要配合Struts标签使用. 如：\u0026lt;s:property value=\u0026quot;name\u0026quot;\u0026gt;；使用EL表达式能够访问valueStack中对象的属性，原因是：Struts2对HTTPServletRequest作了进一步的封装.\n17、采用OGNL表达式创建List/Map集合对象 17.1、试用如下直接生成一个List对象： \u0026lt;s:set name=\u0026quot;list\u0026quot; value=\u0026quot;{'zhangsan','lisi','wangwu'}\u0026quot;/\u0026gt; \u0026lt;s:iterator value=\u0026quot;#list\u0026quot;\u0026gt;\u0026lt;!-- 迭代器 --\u0026gt; \u0026lt;s:property/\u0026gt;\u0026lt;br\u0026gt; \u0026lt;/s:iterator\u0026gt;  Set标签用于将某个值放入指定范围\n scope：指定变量被放置的范围，该属性可以接受application、session、request、page或action. 如果没有设置该属性，则默认放置在OGNL Context中. value：赋给变量的值，如果没有设置该属性，则将ValueStack栈顶的值赋值给变量.  生成一个Map对象：(Key\u0026ndash;Value)\n\u0026lt;s:set name=\u0026quot;foobar\u0026quot; value=\u0026quot;#{'k1': 'value1','k2':'value2'}\u0026quot;/\u0026gt; \u0026lt;s:iterator value=\u0026quot;# foobar \u0026quot;\u0026gt;\u0026lt;!-- 迭代器 --\u0026gt; \u0026lt;s:property value=\u0026quot;key\u0026quot;/\u0026gt;=\u0026lt;s:property value=\u0026quot;value\u0026quot;/\u0026gt;\u0026lt;br\u0026gt; \u0026lt;/s:iterator\u0026gt;  java 迭代方法：\nfor(Map.Entry\u0026lt;String,Integer\u0026gt;entry:maps.entrySet){ System.out.println(entry.getKey()+\u0026quot;=\u0026quot;+entry.getValue()); }  18、采用OGNL表达式判断对象是否存在于集合中 使用in和not in in表达式\n\u0026lt;s:if test=\u0026quot;foor\u0026quot; in {'foo', 'bar'}\u0026gt; 在 \u0026lt;/s:if\u0026gt; \u0026lt;s:else\u0026gt; 不在 \u0026lt;/s:else\u0026gt; not in 表达式 \u0026lt;s:if test=\u0026quot;foor\u0026quot; not in {'foo','bar'}\u0026gt; 不在 \u0026lt;/s:if\u0026gt; \u0026lt;s:else\u0026gt; 在 \u0026lt;/s:else\u0026gt;  附加： 除了in和not in之外OGNL还允许使用某个规则获得集合对象的子集\n ?:获得所有符合逻辑的元素. ^:获得符合逻辑的第一个元素. $:获得符合逻辑的最后一个元素.  例如：\n\u0026lt;s:iterator value=\u0026quot;books.{?#this.price}35}\u0026quot;\t/\u0026gt;  19、常用标签 19.1、propert标签： 用于输出指定值：\n\u0026lt;s:set name=\u0026quot;name\u0026quot; value=\u0026quot;kk\u0026quot;/\u0026gt; \u0026lt;s:property value=\u0026quot;#name\u0026quot;/\u0026gt;   default:可选属性，如果需要输出指定的属性值为null，则显示该属性指定的值. value：可选属性，指定需要输出的属性值，如果没有指定该属性，则默认输出ValueStack栈顶的值. escape：可选属性，指定是否格式化HTML代码. id：可选属性，指定还元素的标识.  19.2、iterator标签 iterator标签用于对集合进行迭代，治理的集合包含List、Set和数组\n\u0026lt;s:set name=\u0026quot;list\u0026quot; value=\u0026quot;{'foo','bar'}\u0026quot;/\u0026gt; \u0026lt;s:iterator value=\u0026quot;#list\u0026quot; status=\u0026quot;st\u0026quot;\u0026gt; \u0026lt;s:color=\u0026lt;s:if test=\u0026quot;#st.odd\u0026quot;\u0026gt;red\u0026lt;/s:if\u0026gt;\u0026lt;s:else\u0026gt;blue\u0026lt;/s:else\u0026gt;\u0026gt; \u0026lt;s:property/\u0026gt;\u0026lt;/font\u0026gt;\u0026lt;br\u0026gt; \u0026lt;/s:iterator\u0026gt;   value:可选属性，指定被迭代的集合，如果没有设置该属性，则使用ValueStack栈顶的集合 id:可选属性，指定即合理元素的id. （过时） status：该属性指定迭代时的IteratorStatus实例. 该实例包含以下几个方法：  int getCount()，返回当前迭代了几个元素 int getIndex()，返回当前迭代元素的索引 boolean isEven()，返回当前被迭代元素的索引是否为偶数 boolean isOdd()，返回当前被迭代元素的索引是否为奇数 boolean isFirst()，返回当前被迭代元素的索引是否是第一个元素 boolean isLast()，返回当前被迭代元素的索引是否最后一个元素    19.3、url标签 \u0026lt;s:url value=\u0026quot;hellowoeld_add\u0026quot; namespace=\u0026quot;/test\u0026quot;\u0026gt;\u0026lt;s:param name=\u0026quot;person\u0026quot; value=\u0026quot;23\u0026quot;/\u0026gt;\u0026lt;/s:url\u0026gt;  生成类似如下路径： /struts/test/helloworld_add.adtion?persom=23 红色部分为内容路径\n当标签的属性作为字符串类型处理时，“%”符号的用途试计算OGNL表达式的值\n\u0026lt;s:set value=\u0026quot;myurl\u0026quot; value='\u0026quot;http://www.sohu.com\u0026quot;'/\u0026gt; \u0026lt;s:url value=\u0026quot;myurl\u0026quot;/\u0026gt;\u0026lt;/br\u0026gt; \u0026lt;s:url value=\u0026quot;%{#myurl}\u0026quot;/\u0026gt;  输出结果：\n# myurl http://www.sohu.com  19.4、表单标签：checkboxlist复选框 如果集合为list\n\u0026lt;s:checkboxlist name=\u0026quot;list\u0026quot; list=\u0026quot;{'Java','.Net','Ror','PHP'}\u0026quot; value=\u0026quot;{'Java','.Net'}\u0026quot;/\u0026gt;  生成如下html代码：\n\u0026lt;input type=\u0026quot;checkbox\u0026quot; name=\u0026quot;list\u0026quot; value=\u0026quot;Java\u0026quot; checked=\u0026quot;checked\u0026quot;/\u0026gt;\u0026lt;lable\u0026gt;Java\u0026lt;/lable\u0026gt; \u0026lt;input type=\u0026quot;checkbox\u0026quot; name=\u0026quot;list\u0026quot; value=\u0026quot;.Net\u0026quot; checked=\u0026quot;checked\u0026quot;/\u0026gt;\u0026lt;lable\u0026gt;.Net\u0026lt;/lable\u0026gt; \u0026lt;input type=\u0026quot;checkbox\u0026quot; name=\u0026quot;list\u0026quot; value=\u0026quot; Ror\u0026quot;/\u0026gt;\u0026lt;lable\u0026gt;Ror\u0026lt;/lable\u0026gt; \u0026lt;input type=\u0026quot;checkbox\u0026quot; name=\u0026quot;list\u0026quot; value=\u0026quot; PHP\u0026quot;/\u0026gt;\u0026lt;lable\u0026gt;PHP\u0026lt;/lable\u0026gt;  如果集合为Map\n\u0026lt;s:checkboxlist name=\u0026quot;map\u0026quot; list=\u0026quot;#{1:'Java',2:'.Net',3:'Ror',4:'PHP'}\u0026quot; listKey=\u0026quot;key\u0026quot; listValue=\u0026quot;value\u0026quot; value=\u0026quot;{1,2,3}\u0026quot;/\u0026gt;  生成如下html代码：\n\u0026lt;input type=\u0026quot;checkbox\u0026quot; name=\u0026quot;map\u0026quot; value=\u0026quot;1\u0026quot; checked=\u0026quot;checked\u0026quot;/\u0026gt;\u0026lt;lable\u0026gt;Java\u0026lt;/lable\u0026gt; \u0026lt;input type=\u0026quot;checkbox\u0026quot; name=\u0026quot;map\u0026quot; value=\u0026quot;2\u0026quot; checked=\u0026quot;checked\u0026quot;/\u0026gt;\u0026lt;lable\u0026gt;.Net\u0026lt;/lable\u0026gt; \u0026lt;input type=\u0026quot;checkbox\u0026quot; name=\u0026quot;map\u0026quot; value=\u0026quot;3\u0026quot; checked=\u0026quot;checked\u0026quot;/\u0026gt;\u0026lt;lable\u0026gt;Ror\u0026lt;/lable\u0026gt; \u0026lt;input type=\u0026quot;checkbox\u0026quot; name=\u0026quot;map\u0026quot; value=\u0026quot;4\u0026quot;/\u0026gt;\u0026lt;lable\u0026gt;PHP\u0026lt;/lable\u0026gt;  如果集合里存放的是javabean\n\u0026lt;% Person p1 = new Person(1,\u0026quot;第一个\u0026quot;); Person p1 = new Person(2,\u0026quot;第一个\u0026quot;); List\u0026lt;Person\u0026gt; list = new ArrayList\u0026lt;Person\u0026gt;(); list.add(p1); list.add(p2); request.setAttribute(\u0026quot;person\u0026quot;, list); %\u0026gt; \u0026lt;s:checkboxlist list=\u0026quot;#request.persons\u0026quot; listKey=\u0026quot;personid\u0026quot; listValue=\u0026quot;name\u0026quot;\u0026gt;\u0026lt;/s:checkboxlist\u0026gt;  personid和name为Person的属性 生成如下代码：\n\u0026lt;input type=\u0026quot;checkbox\u0026quot; name=\u0026quot;beans\u0026quot; value=\u0026quot;1\u0026quot;/\u0026gt;\u0026lt;lable\u0026gt;第一个\u0026lt;/lable\u0026gt; \u0026lt;input type=\u0026quot;checkbox\u0026quot; name=\u0026quot;beans\u0026quot; value=\u0026quot;2\u0026quot;/\u0026gt;\u0026lt;lable\u0026gt;第二个\u0026lt;/lable\u0026gt;  19.5、表单标签：radio单选框 如果集合为list\n\u0026lt;s:radio name=\u0026quot;list\u0026quot; list=\u0026quot;{'Java','.Net','Ror','PHP'}\u0026quot; value=\u0026quot;'Java'\u0026quot;/\u0026gt;  生成如下html代码：\n\u0026lt;input type=\u0026quot;radio\u0026quot; name=\u0026quot;list\u0026quot; value=\u0026quot;Java\u0026quot; checked=\u0026quot;checked\u0026quot;/\u0026gt;\u0026lt;lable\u0026gt;Java\u0026lt;/lable\u0026gt; \u0026lt;input type=\u0026quot;radio\u0026quot; name=\u0026quot;list\u0026quot; value=\u0026quot;.Net\u0026quot;/\u0026gt; \u0026lt;input type=\u0026quot;radio\u0026quot; name=\u0026quot;list\u0026quot; value=\u0026quot;Ror\u0026quot;/\u0026gt; \u0026lt;input type=\u0026quot;radio\u0026quot; name=\u0026quot;list\u0026quot; value=\u0026quot;PHP\u0026quot;/\u0026gt;  如果集合为Map\n\u0026lt;s:radio name=\u0026quot;map\u0026quot; list=\u0026quot;#{1:'Java',2:'.Net'3:,'Ror',4:'PHP'}\u0026quot; listKey=\u0026quot;key\u0026quot; listValue=\u0026quot;value\u0026quot; value=\u0026quot;1\u0026quot;/\u0026gt;  生成如下html代码：\n\u0026lt;input type=\u0026quot;radio\u0026quot; name=\u0026quot;map\u0026quot; value=\u0026quot;1\u0026quot; checked=\u0026quot;checked\u0026quot;/\u0026gt;\u0026lt;lable\u0026gt;Java\u0026lt;/lable\u0026gt; \u0026lt;input type=\u0026quot;radio\u0026quot; name=\u0026quot;map\u0026quot; value=\u0026quot;2\u0026quot;/\u0026gt;\u0026lt;lable\u0026gt;.Net\u0026lt;/lable\u0026gt; \u0026lt;input type=\u0026quot;radio\u0026quot; name=\u0026quot;map\u0026quot; value=\u0026quot;3\u0026quot;/\u0026gt;\u0026lt;lable\u0026gt;Ror\u0026lt;/lable\u0026gt; \u0026lt;input type=\u0026quot;radio\u0026quot; name=\u0026quot;map\u0026quot; value=\u0026quot;4\u0026quot;/\u0026gt;\u0026lt;lable\u0026gt;PHP\u0026lt;/lable\u0026gt;  如果集合里存放的是javabean\n\u0026lt;% Person p1 = new Person(1,\u0026quot;第一个\u0026quot;); Person p1 = new Person(2,\u0026quot;第一个\u0026quot;); List\u0026lt;Person\u0026gt; list = new ArrayList\u0026lt;Person\u0026gt;(); list.add(p1); list.add(p2); request.setAttribute(\u0026quot;person\u0026quot;, list); %\u0026gt; \u0026lt;s:radio name=\u0026quot;beans\u0026quot; list=\u0026quot;#request.persons\u0026quot; listKey=\u0026quot;personid\u0026quot; listValue=\u0026quot;name\u0026quot;/\u0026gt;  personid和name为Person的属性 生成如下代码：\n\u0026lt;input type=\u0026quot;radio\u0026quot; name=\u0026quot;beans\u0026quot; value=\u0026quot;1\u0026quot;/\u0026gt;\u0026lt;lable\u0026gt;第一个\u0026lt;/lable\u0026gt; \u0026lt;input type=\u0026quot;radio\u0026quot; name=\u0026quot;beans\u0026quot; value=\u0026quot;2\u0026quot;/\u0026gt;\u0026lt;lable\u0026gt;第二个\u0026lt;/lable\u0026gt;  19.6、表单标签select下拉选择框 \u0026lt;s:select name=\u0026quot;list\u0026quot; list=\u0026quot;{'Java','.Net'}\u0026quot; value=\u0026quot;'Java'\u0026quot;/\u0026gt;  生成如下html代码：\n\u0026lt;s:select name=\u0026quot;list\u0026quot; id=\u0026quot;list\u0026quot;\u0026gt; \u0026lt;option value=\u0026quot;Java\u0026quot; selected=\u0026quot;selected\u0026quot;\u0026gt;Java\u0026lt;option/\u0026gt; \u0026lt;option value=\u0026quot;.Net\u0026quot;\u0026gt;.Net \u0026lt;option/\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;s:select name=\u0026quot;map\u0026quot; list=\u0026quot;#{1:'Java',2:'.Net'3:,'Ror',4:'PHP'}\u0026quot; listKey=\u0026quot;key\u0026quot; listValue=\u0026quot;value\u0026quot; value=\u0026quot;1\u0026quot;/\u0026gt;  生成如下html代码：\n\u0026lt;s:select name=\u0026quot;list\u0026quot; id=\u0026quot;list\u0026quot;\u0026gt; \u0026lt;option value=\u0026quot;1\u0026quot; selected=\u0026quot;selected\u0026quot;\u0026gt;Java\u0026lt;option/\u0026gt; \u0026lt;option value=\u0026quot;2\u0026quot;\u0026gt;.Net\u0026lt;option/\u0026gt; \u0026lt;/select\u0026gt;  20、\u0026lt;s:token/\u0026gt;标签放置重复提交 \u0026lt;s:token/\u0026gt;标签放置重复提交用法如下： 第一步：在表单中加入\u0026lt;s:token/\u0026gt;\n\u0026lt;s:form action=\u0026quot;Action_execute()\u0026quot; method=\u0026quot;post\u0026quot; \u0026gt; 姓名\u0026lt;s:textfield name=\u0026quot;name\u0026quot;/\u0026gt;\u0026lt;s:token/\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;发送\u0026quot;/\u0026gt; \u0026lt;/s:form\u0026gt;  第二步：\n\u0026lt;action name=\u0026quot;Action_*\u0026quot; class=\u0026quot;com.haibao.action.XMLvalidate\u0026quot; method=\u0026quot;{1}\u0026quot;\u0026gt; \u0026lt;interceptor-ref name=\u0026quot;defaultStack\u0026quot;/\u0026gt; \u0026lt;interceptor-ref name=\u0026quot;token\u0026quot;/\u0026gt; \u0026lt;result name=\u0026quot;ivalid.token\u0026quot;\u0026gt;/message.jsp\u0026lt;/result\u0026gt; \u0026lt;result name=\u0026quot;success\u0026quot;\u0026gt;/WEB-INF/page/message.jsp\u0026lt;/result\u0026gt; \u0026lt;/action\u0026gt;  以上配置加入了“token”拦截器和“ivalid.token”结果，因为“token”拦截器在会话的token与请求的token不一致时，将会直接返回“ivalid.token”结果.\n","date":1611878400,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1611878400,"objectID":"97fdddcd9bf62e2f6e54ff9f344cbe06","permalink":"https://CoMath21.github.io/post/1-struts2/","publishdate":"2021-01-29T00:00:00Z","relpermalink":"/post/1-struts2/","section":"post","summary":"具体介绍Strust2的相关内容.","tags":["编程语言","Java","Struts2"],"title":"Struts2学习笔记","type":"post"},{"authors":["Xin态好先生","CoMath"],"categories":["学习笔记","编程语言"],"content":"　对于这一组电影数据，如果我们想runtime的分布情况.\n# coding=utf-8 import pandas as pd from matplotlib import pyplot as plt file_path = \u0026quot;./IMDB-Movie-Data.csv\u0026quot; df = pd.read_csv(file_path) # print(temp_list.tolist()) # nums = set([i for j in temp_list for i in j]) # print(len(nums)) time_list = df[\u0026quot;Runtime (Minutes)\u0026quot;].values max_time = time_list.max() min_time = time_list.min() dis = (max_time - min_time)//5 plt.figure(figsize=(20,8),dpi=80) plt.hist(time_list,dis) plt.xticks(range(min_time,max_time,5)) plt.show()  对于这一组电影数据，如果我们希望统计电影分类(genre)的情况，应该如何处理数据？\n思路：重新构造一个全为0的数组，列名为分类，如果某一条数据中分类出现过，就让0变为1.\n# coding=utf-8 import pandas as pd from matplotlib import pyplot as plt import numpy as np file_path = \u0026quot;./IMDB-Movie-Data.csv\u0026quot; # 读取CSV文件 df = pd.read_csv(file_path) print(df[\u0026quot;Genre\u0026quot;].head(3)) # 统计分类的列表 temp_list = df[\u0026quot;Genre\u0026quot;].str.split(\u0026quot;,\u0026quot;).tolist() #[[],[],[]] genre_list = list(set([i for j in temp_list for i in j])) # 等价于 genre_list = [] # for i in temp_genre_list: # genre_list.extend(i) # genre_list = list(set(genre_list)) # 构造全为0的数组 zeros_df = pd.DataFrame(np.zeros((df.shape[0],len(genre_list))),columns=genre_list) # 给每个电影出现分类的位置赋值1 for i in range(df.shape[0]): #zeros_df.loc[0,[\u0026quot;Sci-fi\u0026quot;,\u0026quot;Mucical\u0026quot;]] = 1 zeros_df.loc[i,temp_list[i]] = 1 # 统计每个分类的电影的数量和 genre_count = zeros_df.sum(axis=0) # 排序 genre_count = genre_count.sort_values() _x = genre_count.index _y = genre_count.values #画图 plt.figure(figsize=(20,8),dpi=80) plt.bar(range(len(_x)),_y,width=0.4,color=\u0026quot;orange\u0026quot;) plt.xticks(range(len(_x)),_x) plt.show()  数据合并之join 　join:默认情况下他是把行索引相同的数据合并到一起. 数据合并之merge 　merge:按照指定的列把数据按照一定的方式合并到一起\nmerge(left, right, how='inner', on=None, left_on=None, right_on=None, left_index=False, right_index=False, sort=False, suffixes=('_x', '_y'), copy=True, indicator=False, validate=None) import pandas as pd df1=pd.DataFrame({'key':['a','b','a','b','b'],'value1':range(5)}) df2=pd.DataFrame({'key':['a','c','c','c','c'],'value2':range(5)}) display(df1,df2,pd.merge(df1,df2))   默认的合并方式inner，交集; merge outer，并集，NaN补全; merge left，左边为准，NaN补全; merge right，右边为准，NaN补全.  分组和聚合 　在pandas中类似的分组的操作有很简单的方式来完成\ngrouped = df.groupby(by=\u0026quot;columns_name\u0026quot;)  grouped是一个DataFrameGroupBy对象，是可迭代的;grouped中的每一个元素是一个元组，元组里面是（索引(分组的值)，分组之后的DataFrame）.\n那么，分组之后的每个DataFrame的长度？ 长度是一个思路，但更多的方法(聚合方法)来解决这个问题. DataFrameGroupBy对象有很多经过优化的方法. 如果需要对国家和省份进行分组统计\ngrouped = df.groupby(by=[df[\u0026quot;Country\u0026quot;],df[\u0026quot;State/Province\u0026quot;]])  很多时候我们只希望对获取分组之后的某一部分数据，或者说我们只希望对某几列数据进行分组，这个时候我们应该怎么办呢？ 获取分组之后的某一部分数据：\ndf.groupby(by=[\u0026quot;Country\u0026quot;,\u0026quot;State/Province\u0026quot;])[\u0026quot;Country\u0026quot;].count()  对某几列数据进行分组：\ndf[\u0026quot;Country\u0026quot;].groupby(by=[df[\u0026quot;Country\u0026quot;],df[\u0026quot;State/Province\u0026quot;]]).count()  观察结果，由于只选择了一列数据，所以结果是一个Series类型.\n如果我想返回一个DataFrame类型呢？\nt1 = df[[\u0026quot;Country\u0026quot;]].groupby(by=[df[\u0026quot;Country\u0026quot;],df[\u0026quot;State/Province\u0026quot;]]).count() t2 = df.groupby(by=[\u0026quot;Country\u0026quot;,\u0026quot;State/Province\u0026quot;])[[\u0026quot;Country\u0026quot;]].count()  以上的两条命令结果一样，和之前的结果的区别在于当前返回的是一个DataFrame类型.\n索引和复合索引 简单的索引操作：  获取index：df.index 指定index ：df.index = ['x','y'] 重新设置index : df.reindex(list(\u0026quot;abcedf\u0026quot;)) 指定某一列作为index ：df.set_index(\u0026quot;Country\u0026quot;,drop=False) 返回index的唯一值：df.set_index(\u0026quot;Country\u0026quot;).index.unique()  　假设a为一个DataFrame,那么当a.set_index([\u0026quot;c\u0026quot;,\u0026quot;d\u0026quot;])即设置两个索引的时候是什么样子的结果呢？\na = pd.DataFrame({'a': range(7),'b': range(7, 0, -1),'c': ['one','one','one','two','two','two', 'two'],'d': list(\u0026quot;hjklmno\u0026quot;)})  Series复合索引 DataFrame复合索引 例.现在有2015到2017年25万条911的紧急电话的数据，请统计出出这些数据中不同类型的紧急情况的次数.\nimport pandas as pd import numpy as np from matplotlib import pyplot as plt df = pd.read_csv(\u0026quot;./911.csv\u0026quot;) # print(df.info()) temp_list = df[\u0026quot;title\u0026quot;].str.split(\u0026quot;:\u0026quot;).tolist() cate_list = [i[0] for i in temp_list] cate_set_list = list(set(cate_list)) df[\u0026quot;type\u0026quot;] = pd.DataFrame(np.array(cate_list).reshape((df.shape[0],1))) # print(df.head()) cate_zeros = pd.DataFrame(np.zeros((df.shape[0],len(cate_set_list))),columns=cate_set_list) for cate in cate_set_list: cate_zeros[cate][df[\u0026quot;type\u0026quot;].str.contains(cate)] = 1 zeros_sum = cate_zeros.sum(axis=0) sum_values = zeros_sum.values plt.figure(figsize=(8, 6),dpi=80) plt.bar(cate_set_list,sum_values,color=\u0026quot;orange\u0026quot;,width=0.4) plt.show()  统计出不同月份不同类型紧急电话的次数的变化情况，应该怎么做可以按照上面的方法将时间戳按照右边“-”进行切割，然后将前面的字符串定义为原数组的最后一列，在进行其他操作. 也可以使用pandas的时间序列.\npandas中的时间序列 　不管在什么行业，时间序列都是一种非常重要的数据形式，很多统计数据以及数据的规律也都和时间序列有着非常重要的联系,而且在pandas中处理时间序列是非常简单的生成一段时间范围.\npd.date_range(start=None, end=None, periods=None, freq='D')  start和end以及freq配合能够生成start和end范围内以频率freq的一组时间索引. start和periods以及freq配合能够生成从start开始的频率为freq的periods个时间索引. 在DataFrame中使用时间序列 index=pd.date_range(\u0026quot;20170101\u0026quot;,periods=10) df = pd.DataFrame(np.random.rand(10),index=index)  回到最开始的911数据的案例中，我们可以使用pandas提供的方法把时间字符串转化为时间序列.\ndf[\u0026quot;timeStamp\u0026quot;] = pd.to_datetime(df[\u0026quot;timeStamp\u0026quot;],format=\u0026quot;\u0026quot;)  format参数大部分情况下可以不用写，但是对于pandas无法格式化的时间字符串，我们可以使用该参数，比如包含中文.\npandas重采样 　重采样：指的是将时间序列从一个频率转化为另一个频率进行处理的过程，将高频率数据转化为低频率数据为降采样，低频率转化为高频率为升采样.pandas提供了一个resample的方法来帮助我们实现频率转化. PeriodIndex 　之前所学习的DatetimeIndex可以理解为时间戳，那么现在我们要学习的PeriodIndex可以理解为时间段．\nperiods = pd.PeriodIndex(year=data[\u0026quot;year\u0026quot;],month=data[\u0026quot;month\u0026quot;],day=data[\u0026quot;day\u0026quot;],hour=data[\u0026quot;hour\u0026quot;],freq=\u0026quot;H\u0026quot;)  那么如果给这个时间段降采样呢？\ndata = df.set_index(periods).resample(\u0026quot;10D\u0026quot;).mean()  ","date":1611792000,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1611792000,"objectID":"25241c6db9aa838d1b87741feaee85e3","permalink":"https://CoMath21.github.io/post/0-python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%904/","publishdate":"2021-01-28T00:00:00Z","relpermalink":"/post/0-python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%904/","section":"post","summary":"Python数据分析之常用统计方法.","tags":["编程语言","Python","数据分析"],"title":"Python数据分析（四）","type":"post"},{"authors":["Xin态好先生","CoMath"],"categories":["学习笔记","编程语言"],"content":"　Numpy能够帮助我们处理数值，pandas除了处理数值之外(基于numpy)，还能够帮助我们处理其他类型的数据.\npandas的常用数据类型 Series 一维，带标签数组 t = pd.Series(np.arange(10),index=list(string.ascoo_uppercase[:10]))  Series切片和索引 Series的索引和值 对于一个陌生的series类型，可以通过t.index获取其索引值 pandas读取外部数据：  直接使用pd. read_csv()即可. 如果待数据的数据没有列名，则需要补充，即在读取文件时给定参数names的值.  pd.read_csv(“’’,names=column_names)   column_names：指定类别名字,[\u0026lsquo;Sample code number\u0026rsquo;,\u0026lsquo;Clump Thickness\u0026rsquo;, \u0026lsquo;Uniformity of Cell Size\u0026rsquo;,\u0026lsquo;Uniformity of Cell Shape\u0026rsquo;,\u0026lsquo;Marginal Adhesion\u0026rsquo;, \u0026lsquo;Single Epithelial Cell Size\u0026rsquo;,\u0026lsquo;Bare Nuclei\u0026rsquo;,\u0026lsquo;Bland Chromatin\u0026rsquo;,\u0026lsquo;Normal Nucleoli\u0026rsquo;,\u0026lsquo;Mitoses\u0026rsquo;,\u0026lsquo;Class\u0026rsquo;] return:数据. replace(to_replace=’’,value=)：返回数据. dropna():返回数据. 注：读取文件只要是.CSV文件就可以使用load_csv()方法，即使文件地址是网站.  DataFrame 二维，Series容器 DataFrame对象既有行索引，又有列索引 行索引，表明不同行，横向索引，叫index，0轴，axis=0； 列索引，表名不同列，纵向索引，叫columns，1轴，axis=1． 和一个ndarray一样，通过ndim，shape，dtype了解这个ndarray的基本信息． 获得使用次数最高的前几个名字是什么？\nimport pandas as pd df = pd.read_csv(\u0026quot;./dogNames.csv\u0026quot;) # print(df.head()) # print(df.info()) # dataFrame 中排序的方法 df = df.sort_values(\u0026quot;Count_AnimalName\u0026quot;,ascending=False) print(df.head())  def sort_values(self, by, axis=0, ascending=True, inplace=False, kind='quicksort', na_position='last') # ascending：升序：True\t# 降序：False  问题：数据有10列，我想按照其中的第1，第3，第8列排序？\n# pandas取行或者列的注意点 # - 方括号写数组,表示取行,对行进行操作 # - 写字符串,表示的去列索引,对列进行操作 print(df[:20]) print(df[\u0026quot;Row_Labels\u0026quot;]) print(type(df[\u0026quot;Row_Labels\u0026quot;]))  还有更多的经过pandas优化过的选择方式：\n df.loc 通过标签索引行数据（行列的名字）  df.loc[“a”,”w”] # a行w列 df.loc[“a”,:] # a行 df.loc[:,”w”] # w列 df.loc[[“a”,”c”],:] # a，c行 df.loc[:,[“w”,”z”]] # w，z列 df.loc[[“a”,”c” ,[“w”,”z”]] # a,c行，w,z列 df.loc[[“a”:”c” ,[“w”,”z”]] # a到c行，w,z列  df.iloc 通过位置获取行数据（行列号-1）  df.iloc[1,:] # 第二行 df.iloc[:,2] # 第三列 df.iloc[:,[2,1]] # 第三列第二列 df.iloc[[0,2], [2,1]]\t# 第1,3行, 第3,2列  赋值更改数据的过程： 布尔索引 　找到所有的使用次数超过800的狗的名字. 找到所有的使用次数超过700并且名字的字符串的长度大于4的狗的名字 字符串方法 Pandas缺失数据的处理 数据缺失通常有两种情况： 　一种就是空，None等，在pandas是NaN(和np.nan一样);另一种是我们让其为0，蓝色框中对于NaN的数据，在numpy中我们是如何处理的？\n　在pandas中我们处理起来非常容易.\n判断数据是否为NaN：pd.isnull(df),pd.notnull(df)\n 处理方式1：删除NaN所在的行列dropna (axis=0, how=\u0026lsquo;any\u0026rsquo;, inplace=False)# 是否原地修改 处理方式2：填充数据，t.fillna(t.mean()),t.fiallna(t.median()),t.fillna(0) 处理为0的数据：t[t==0]=np.nan  当然并不是每次为0的数据都需要处理计算平均值等情况，nan是不参与计算的，但0会.\n数据变形：  处理重复数据  判断数据是否重复，duplicated() 去除重复数据，drop_dumplicates()，可指定列及如何保留数据   使用函数或map转化数据，通常根据字典进行数据转化  data = pd.DataFrame({'food': ['bacon', 'pulled pork', 'bacon', 'Pastrami', 'corned beef', 'Bacon', 'pastrami', 'honey ham', 'nova lox'], 'ounces': [4, 3, 12, 6, 7.5, 8, 3, 5, 6]})  # 添加一列，用于指定食物的来源 meat_to_animal = { 'bacon': 'pig', 'pulled pork': 'pig', 'pastrami': 'cow', 'corned beef': 'cow', 'honey ham': 'pig', 'nova lox': 'salmon' } # 使用map() lowercased = data['food'].str.lower() data['animal'] = lowercased.map(meat_to_animal)   替换值，replace() 离散化和分享操作，pd.cut()，返回Categorical对象  哑变量操作，pd.get_dummies() 向量化字符串操作  字符串列越苏中是否包含子字符串，ser_obj.str.contains() 字符串列切片操作，ser_obj.str[a:b]    ","date":1611705600,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1611705600,"objectID":"160ed39b47e3b45a7d11a8d243db6c3c","permalink":"https://CoMath21.github.io/post/0-python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%903/","publishdate":"2021-01-27T00:00:00Z","relpermalink":"/post/0-python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%903/","section":"post","summary":"Python数据分析之Pandas.","tags":["编程语言","Python","数据分析","Pandas"],"title":"Python数据分析（三）","type":"post"},{"authors":["Xin态好先生","CoMath"],"categories":["学习笔记","编程语言"],"content":"Numpy 　Numpy是一个在Python中做科学计算的基础库，重在数值计算，也是大部分PYTHON科学计算库的基础库，多用于在大型、多维数组上执行数值运算.\nNumpy简单创建数组 import numpy as np # 创建简单的列表 a = [1, 2, 3, 4]\t此处输出a的话是[1,2,3,4] # 将列表转换为数组 b = np.array(a)\t此处b输出的话是[1 2 3 4] np.array(a) = np.array(range(1,4)) = np.arange(1,4) np,arrange([start, ] stop[, step,], ftype=None) # 去小数 np.round(x,保留位数)  Numpy查看数组属性 数组元素个数：b.size\n数组形状：b.shape\n一维：列数(8,)；二维：行列(2, 4)；三维：块行列(2, 2, 4)\n重塑reshape：数组一个新的形状而不改变其数据.\n# 具有返回值的，不会改变原数组 numpy.reshape(a, newshape, order='C')\torder : {‘C’, ‘F’, ‘A’} # C:横着读横着写; E:竖着的竖着写; A:竖着度横着写  例.\na = np.array([[1,2,3], [4,5,6]]) print(a) [[1 2 3] [4 5 6]] print(np.reshape(a, (3,2))) [[1 2] [3 4] [5 6]]  数组维度：b.ndim\n数组元素类型：b.dtype\n快速创建N维数组的api函数\n#创建10行10列的数值为浮点1的矩阵 array_one = np.ones([10, 10]) #创建10行10列的数值为浮点0的矩阵 array_zero = np.zeros([10, 10]) #降到一维： b.flatten(order='C') # 把a降到一维，默认是按横的方向降order:{‘C’, ‘F’,‘A’,‘K’} b.flatten('F') # 按竖的方向降  轴(axis) 　在numpy中可以理解为方向,使用0,1,2\u0026hellip;数字表示,对于一个一维数组,只有一个0轴,对于2维数组(shape(2,2)),有0轴和1轴,对于三维数组(shape(2,2, 3)),有0,1,2轴. Numpy读取数据 （以后结合框架之类的读取文件大多数是从CSV文件中读取）\n　CSV（Comma-Separated Value,逗号分隔值文件）：由于csv便于展示,读取和写入,所以很多地方也是用csv的格式存储和传输中小型的数据,为了方便教学,我们会经常操作csv格式的文件,但是操作数据库中的数据也是很容易的实现的.\n方法\nnp.loadtxt(fname,dtype=np.float,delimiter=None,skiprows=0,usecols=None,unpack=False)  注意 其中添加的delimiter和dtype以及unpack效果.\n delimiter：指定边界符号是什么，不指定会导致每行数据为一个整体法人字符串而报错 dtype：默认情况下对于较大的数据将变为科学计数法的方式 upack：默认值是False(0)，默认情况下，有多少条数据就会有多少行；为True(1)的情况下，每一列的数据会组成一行，袁术数据有多少列，加载出来就会有多少行，相当于转置的效果. 其他转置方法：t.transpose()\tt.T\tt.swapaxes(1,0) # 1轴和1轴互换.  Numpy索引和切片 # 取行： T[行] # 取连续的多行： T [2:] # 取不连续的多行： T [ [2,8,10] ] = T [[2,10,3],:] 取第2行：T [1,:] 取第三行以后所有行：T [2:,:] #取列： T [:,0] #取连续的多列： T [:, 2 :] #取不连续的多列： T [:,[ 0,2]] #去行和列，取第3行，第四列的值： a = T [ 2, 3] print(type(a))\t# int #取多行和多列，取第3行到第五行，第2列到第4列的结果 #去的是行和列交叉点的位置 b = T [2:5,1:4] #取多个不相邻的点--选出来的结果是（0，0） （2，1） （2，3） c = T [[0,2,2],[0,1,3]]  Numpy中布尔索引 # numpy中三元运算符 np.where(condition, if True, if False)  Numpy中的clip(裁剪) numpy.clip(a, a_min, a_max, out=None)  [a_min, a_max] 里面的数被保留下来,外面的被截取为a_min或者a_max .\nout：可以把结果放置在此数组中.\n例如，指定间隔为[0，1]，则小于0的值赋值为0，并且大于1的值赋值为1.\n补充：int类型的情况下无法赋值为nan，所以需要将类型改为float.\nt.astype(float) t[x,y]=np.nan  数组的拼接： np.vstack((t1,t2))\t# 竖直拼接 np.hstack((t1,t2))\t# 水平拼接  数组的行列交换 Numpy更多好用的方法  获取最大值最小值的位置 np.argmax(t,axis=0) np.argmin(t,axis=1) 创建一个全0的数组: np.zeros((3,4)) 创建一个全1的数组:np.ones((3,4)) 创建一个对角线为1的正方形数组(方阵)：np.eye(3)  Numpy生成随机数 Numpy中的注意点copy和view  a=b 完全不复制，a和b相互影响 a = b[:],视图的操作，一种切片，会创建新的对象a，但是a的数据完全由b保管，他们两个的数据变化是一致的， a = b.copy(),复制，a和b互不影响  Numpy中的nan和inf（都是float类型） nan(NAN,Nan):not a number表示不是一个数字.\n什么时候numpy中会出现nan\n当我们读取本地的文件为float的时候，如果有缺失，就会出现nan． 　当做了一个不合适的计算的时候(比如无穷大(inf)减去无穷大)．\ninf(-inf,inf):infinity,inf表示正无穷，-inf表示负无穷\n什么时候回出现inf包括（-inf，+inf）\n比如一个数字除以0，（python中直接会报错，numpy中是一个inf或者-inf） Numpy中的nan的注意点 t.sum(axis=None) #求和 t.mean(a,axis=None) # 均值 受离群点的影响较大 np.median(t,axis=None) # 中值： t.max(axis=None) # 最大值： t.min(axis=None) # 最小值： np.ptp(t,axis=None) # 极值 即最大值和最小值只差 t.std(axis=None) # 标准差  ndarry缺失值填充均值 t中存在nan值，如何操作把其中的nan填充为每一列的均值\nt = array([[ 0., 1., 2., 3., 4., 5.], [ 6., 7., nan, 9., 10., 11.], [ 12., 13., 14., nan, 16., 17.], [ 18., 19., 20., 21., 22., 23.]]) def fill_ndarray(t1): #遍历每一列 for i in range(t1.shape[1]): temp_col = t1[:,i] #当前的一列 nan_num = np.count_nonzero(temp_col!=temp_col) if nan_num != 0: #不为0，说明当前这一列中有nan temp_not_nan_col = temp_col[temp_col==temp_col] #当前一列不为nan的array # 选中当前为nan的位置，把值赋值为不为nan的均值 temp_col[np.isnan(temp_col)] = temp_not_nan_col.mean() return t1 if __name__ == '__main__': t1 = np.arange(12).reshape((4, 3)).astype(\u0026quot;float\u0026quot;) t1[1, 1:] = np.nan print(t1) t1 = fill_ndarray(t1) print(t1)  输出结果\n[[ 0. 1. 2.]\t[[ 0. 1. 2.] [ 3. nan nan]\t[ 3. 6. 7.] [ 6. 7. 8.]\t[ 6. 7. 8.] [ 9. 10. 11.]]\t[ 9. 10. 11.]]  ","date":1611532800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1611532800,"objectID":"366acf95216fb391a3aaa0d6d31f7922","permalink":"https://CoMath21.github.io/post/0-python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%902/","publishdate":"2021-01-25T00:00:00Z","relpermalink":"/post/0-python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%902/","section":"post","summary":"Python数据分析之Numpy.","tags":["编程语言","Python","数据分析","Numpy"],"title":"Python数据分析（二）","type":"post"},{"authors":["Xin态好先生","CoMath"],"categories":["学习笔记","编程语言"],"content":"准备工作 环境安装（不是必要，只是为了能够更好的操作及维护） CONDA： conda类似于npm或maven的包管理工具，只是conda是针对于python的. 可以安装minconda或anaconda进行安装；Conda是一个包管理器；Anaconda是一个发行包.虽然Conda与Anaconda一起包装，但两者是具有不同目标的不同实体. CONDA安装（以Win64为例）: 可以到官网；也可以到国内清华镜像源进行下载镜像文件： 安装 ： 打开安装包，一路next 即可. 注意，勾选 添加环境变量 和 默认python3.6 作为Anaconda的语言. 安装成功后打开cmd命令输入\u0026quot;python\u0026quot;查看版本信息. 查看当前有哪些可以使用的python版本：conda search \u0026ndash;full -name python 安装python版本（安装的3.6的版本）：conda create \u0026ndash;name tensorflow python=3.6\nJupyter notebook jupyter notebook:一款编程/文档/笔记/展示软件. 启动命令:jupyter notebook （已经安装Anaconda/在conda环境下） Jupyter notebook好处  极其适合数据分析 支持多语言 分享便捷：支持以网页的形式分享，GitHub 中天然支持 Notebook 展示，也可以通过 nbviewer 分享你的文档. 当然也支持导出成 HTML、PDF、Markdown等多种格式的文档. 远程运行：在任何地点都可以通过网络链接远程服务器来实现运算. 交互式展现：不仅可以输出图片、视频、数学公式，甚至可以呈现一些互动的可视化内容，比如可以缩放的地图或者是可以旋转的三维模型. 这就需要交互式插件（Interactive widgets）来支持.  基础知识 matplotlib 最流行的Python底层绘图库，主要做数据可视化图表,名字取材于MATLAB，模仿MATLAB构建；能将数据进行可视化,更直观的呈现、使数据更加客观、更具说服力 matplotlib使用流程：\n 明确问题 选择图形的呈现方式 准备数据 绘图和图形完善  例. 假设一天中每隔两个小时(range(2,26,2))的气温(℃)分别是[15, 13, 14.5, 17, 20, 25, 26, 26, 27, 22, 18, 15].\n设置图片大小 fig = plt.figure(figsize=(10,6),dpi=80)  figure图形图标的意思，在这里指的是画的图；通过实例化一个figure并传递参数，能够在后台自动使用该figure实例；在图像模糊的时候可以传入dpi参数（每英寸上像素点的个数）\n保存到本地 　保存需要在绘制图形之后保存\nplt.show(\u0026quot;路径/名字.png\u0026quot;)  也可以保存为SVG这种矢量图的格式\n描述信息,比如x轴和y轴表示什么,这个图表示什么  plt.xlabel(\u0026quot;X轴\u0026quot;) plt.ylabel(\u0026quot;Y轴\u0026quot;) plt.title(\u0026quot;Title\u0026quot;) # 存在中文乱码问题  调整x或者y的刻度的间距  设置x轴的刻度（一个参数）  plt.xticks(x)  想要密集点可以设置：\n_xticks = [i/2 for I in range(4,49)] plt.xticks(_xticks) # 显得过于密集 plt.xticks(_xticks[::3]) # 每隔3取一个；只有列表的时候才能使用[ ]取步长   设置x轴的刻度（两个参数）  plt.xticks(x,_xticks_labels) _x = x # int类型 _xtick_labels = [\u0026quot;hello,{}\u0026quot;.format(i) for i in _x] plt.xticks(_x,_xtick_labels)  format函数: 格式化字符串的函数 str.format()，它增强了字符串格式化的功能. 基本语法是通过 {} 和 : ，来代替以前的%.\nformat 函数可以接受不限个参数，位置可以不按顺序.\n\u0026quot;{} {}\u0026quot;.format(\u0026quot;hello\u0026quot;, \u0026quot;world\u0026quot;) # 不设置指定位置，按默认顺序 'hello world'  format 函数可以接受不限个参数,位置也可以设置参数：\nprint(\u0026quot;网站名：{name}, 地址 {url}\u0026quot;.format(name=\u0026quot;百度\u0026quot;, url=\u0026quot;www.Baidu.com\u0026quot;))  改进：\n_x = list(x) # int类型 _xtick_labels = [\u0026quot;hello,{}\u0026quot;.format(i) for i in _x]\t# 取步长一样，数字和字符串一一对应，数据长度一样 plt.xticks(_x[::8],_xtick_labels[::8])  使用rotation参数旋转\nplt.xticks(_x[::8],_xtick_labels[::8],rotation=45)  中文情况处理： 　matplotlib默认不支持中文字符，因为默认的英文字体无法显示汉字\n如何修改matplotlib的默认字体?\n通过matplotlib.rc可以修改,具体方法参见源码(windows/linux) import matplotlib font = {'family': \u0026quot;simhei\u0026quot;,'size': '10'} # 黑体 matplotlib.rc(\u0026quot;font\u0026quot;,**font)  通过matplotlib 下的font_manager可以解决(windows/linux/mac)\n# 设置中文字体（指定的字体文件路径，然后在显示中文的地方添加fontproperties） my_font = font_manager.FontProperties(fname=\u0026quot;/System/Library/Fonts/PingFang.ttc\u0026quot;) plt.xticks(x[::5],_x_ticks[::5],rotation=90,fontproperties=my_font)  线条的样式(比如颜色,透明度等) plt.grid()\t# 绘制网格 plt.grid(alpha=0.6)\t# 绘制网格，并调整透明度  绘制风格及描述 　描述不同曲线含义：在plot()中添加参数label=\u0026quot;Name\u0026quot; 再添加语句：\nplt.legend(loc=0)/plt.legend(prop=my_font) # loc位置：0=best/upper left  常用统计图 　统计图是数据分析和数学建模最直接、最有效的可视化形式.这里只是简单说明在Python中不同的绘图命令.\n 折线图:以折线的上升或下降来表示统计数量的增减变化的统计图.  特点:能够显示数据的变化趋势，反映事物的变化情况(变化).   直方图:由一系列高度不等的纵向条纹或线段表示数据分布的情况. 一般用横轴表示数据范围，纵轴表示分布情况.  特点:绘制连续性的数据,展示一组或者多组数据的分布状况(统计).   条形图:排列在工作表的列或行中的数据可以绘制到条形图中.  特点:绘制连离散的数据,能够一眼看出各个数据的大小,比较数据之间的差别(统计).   散点图:用两组数据构成多个坐标点，考察坐标点的分布,判断两变量之间是否存在某种关联或总结坐标点的分布模式.  特点:判断变量之间是否存在数量关联趋势,展示离群点(分布规律).    绘制折线图：plt.plot(x,y) import numpy as np linear_data = np.arange(1, 9) quadratic_data = linear_data ** 2 plt.figure() plt.plot(linear_data, '-o', quadratic_data, '-o') # 注意，这里只指定了y轴数据，x轴的数据是matplotlib自动生成的 # 添加坐标轴标签及图例 plt.xlabel('x data') plt.ylabel('y data') plt.title('Line Chart Title') plt.legend(['legend1', 'legend2', 'legend3']) # 填充两个line间的区域plt.gca().fill_between(x,y1,y2,color,透明度) plt.gca().fill_between(range(len(linear_data)), linear_data, quadratic_data, facecolor='green', alpha=0.25)  注意：\n# 对于学术制图，可在标题中包含latex语法 ax = plt.gca() ax.set_title('Quadratic ($x^2$) vs. Linear ($x$)')  绘制散点图：plt.scatter(x,y) 假设通过爬虫你获取到了北京2016年3,10月份每天白天的最高气温(分别位于列表a,b),那么此时如何寻找出气温和随时间(天)变化的某种规律?\nfrom matplotlib import pyplot as plt import matplotlib # 设置字体样式 font = {'family': \u0026quot;simhei\u0026quot;, 'size':'10'} matplotlib.rc(\u0026quot;font\u0026quot;,**font) # 数据 y_3 = [11,17,16,11,12,11,12,6,6,7,8,9,12,15,14,17,18,21,16,17,20,14,15,15,15,19,21,22,22,22,23] y_10 = [26,26,28,19,21,17,16,19,18,20,20,19,22,23,17,20,21,20,22,15,11,15,5,13,17,10,11,13,12,13,6] # 3月，10月范围 x_3 = range(1,32) x_10 = range(50,81) # 合并横坐标 plt.figure(figsize=(14,8),dpi=80) # 绘制散点图 plt.scatter(x_3,y_3,label=\u0026quot;3月份\u0026quot;) plt.scatter(x_10,y_10,label=\u0026quot;10月份\u0026quot;) # 设置x轴 _x = list(x_3) + list(x_10) _xticks_labels = [\u0026quot;3月{}日\u0026quot;.format(i) for i in x_3] _xticks_labels += [\u0026quot;10月{}日\u0026quot;.format(i) for i in x_10] plt.xticks(_x[::3],_xticks_labels[::3],rotation=45) plt.legend(loc=\u0026quot;upper left\u0026quot;) # 显示设置 plt.xlabel(\u0026quot;月份\u0026quot;) plt.ylabel(\u0026quot;温度\u0026quot;) plt.title(\u0026quot;标题\u0026quot;) # 展示 plt.show()  绘制条形图/柱状图： plt.bar(x, y, width=0.2, color='orange') plt.bar(x, y, height=0.2, color='orange')  例.\nfrom matplotlib import pyplot as plt import matplotlib # 设置字体样式 font = {'family': \u0026quot;simhei\u0026quot;, 'size':'10'} matplotlib.rc(\u0026quot;font\u0026quot;,**font) a = [\u0026quot;战狼2\u0026quot;,\u0026quot;速度与激情8\u0026quot;,\u0026quot;功夫瑜伽\u0026quot;,\u0026quot;西游伏妖篇\u0026quot;,\u0026quot;变形金刚5：最后的骑士\u0026quot;,\u0026quot;摔跤吧！爸爸\u0026quot;,\u0026quot;加勒比海盗5：死无对证\u0026quot;,\u0026quot;金刚：骷髅岛\u0026quot;,\u0026quot;极限特工：终极回归\u0026quot;,\u0026quot;生化危机6：终章\u0026quot;,\u0026quot;乘风破浪\u0026quot;,\u0026quot;神偷奶爸3\u0026quot;,\u0026quot;智取威虎山\u0026quot;,\u0026quot;大闹天竺\u0026quot;,\u0026quot;金刚狼3：殊死一战\u0026quot;,\u0026quot;蜘蛛侠：英雄归来\u0026quot;,\u0026quot;悟空传\u0026quot;,\u0026quot;银河护卫队2\u0026quot;,\u0026quot;情圣\u0026quot;,\u0026quot;新木乃伊\u0026quot;] b = [56.01,26.94,17.53,16.49,15.45,12.96,11.8,11.61,11.28,11.12,10.49,10.3,8.75,7.55,7.32,6.99,6.88,6.86,6.58,6.23] plt.figure(figsize=(12,8),dpi=80) x = range(len(a)) plt.bar(x, b, width=0.2, color='orange') plt.xticks(x, a, rotation=45) plt.show()  发现字数长的名字错位,横向的条形图,将\nplt.bar(x, y, width=0.2, color='orange')  改成\nplt.bar(x, y, height=0.2, color='orange')  再适当调整其他参数. 例.假设你知道了列表a中电影分别在2017-09-14(b_14), 2017-09-15(b_15), 2017-09-16(b_16)三天的票房,为了展示列表中电影本身的票房以及同其他电影的数据对比情况,应该如何更加直观的呈现该数据?\nfrom matplotlib import pyplot as plt import matplotlib # 设置字体样式 font = {'family': \u0026quot;simhei\u0026quot;, 'size':'10'} matplotlib.rc(\u0026quot;font\u0026quot;,**font) a = [\u0026quot;猩球崛起3：终极之战\u0026quot;,\u0026quot;敦刻尔克\u0026quot;,\u0026quot;蜘蛛侠：英雄归来\u0026quot;,\u0026quot;战狼2\u0026quot;] b_16 = [15746,312,4497,319] b_15 = [12357,156,2045,168] b_14 = [2358,399,2358,362] bar_width = 0.2 plt.figure(figsize=(10,8),dpi=80) x_14 = list(range(len(a))) x_15 = [i+bar_width for i in x_14] x_16 = [i+bar_width for i in x_15] plt.bar(x_14, b_14, width=bar_width,label=\u0026quot;2017-09-14\u0026quot;) plt.bar(x_15, b_15, width=bar_width,label=\u0026quot;2017-09-15\u0026quot;) plt.bar(x_16, b_16, width=bar_width,label=\u0026quot;2017-09-16\u0026quot;) plt.xticks(x_15, a) plt.legend() plt.show()  堆叠柱状图\n# stack bar chart plt.figure() x_vals = list(range(len(linear_data))) plt.bar(x_vals, linear_data, width=0.3) plt.bar(x_vals, quadratic_data, width=0.3, bottom=linear_data)  绘制直方图 频数分布直方图 　假设你获取了250部电影的时长(列表a中),希望统计出这些电影时长的分布状态(比如时长为100分钟到120分钟电影的数量,出现的频率)等信息,你应该如何呈现这些数据?\nfrom matplotlib import pyplot as plt import matplotlib # 设置字体样式 font = {'family': \u0026quot;simhei\u0026quot;, 'size':'10'} matplotlib.rc(\u0026quot;font\u0026quot;,**font) a=[131, 98, 125, 131, 124, 139, 131, 117, 128, 108, 135, 138, 131, 102, 107, 114, 119, 128, 121, ...] # 计算组距 dis = 3 num_bins = (max(a)-min(a))//dis plt.figure(figsize=(12,8),dpi=80) plt.hist(a, num_bins) plt.xticks(range(min(a),max(a)+dis,dis)) plt.grid() plt.show()  频率分布直方图 plt.hist(a, num_bins,normed=1/True)  例. 在美国2004年人口普查发现有124 million的人在离家相对较远的地方工作. 根据他们从家到上班地点所需要的时间,通过抽样统计(最后一列)出了下表的数据,这些数据能够绘制成直方图么? 数据被统计后，组距不同（不能使用hist）\n解决办法：使用bar（条形图）在进行调整.\nfrom matplotlib import pyplot as plt import matplotlib # 设置字体样式 font = {'family': \u0026quot;simhei\u0026quot;, 'size':'10'} matplotlib.rc(\u0026quot;font\u0026quot;,**font) interval = [0,5,10,15,20,25,30,35,40,45,60,90] width = [5,5,5,5,5,5,5,5,5,15,30,60] quantity = [836,2737,3723,3926,3596,1438,3273,642,824,613,215,47] plt.figure(figsize=(14,8),dpi=80) # 默认宽度是0.8，为了是条形图连起来，令width=1 plt.bar(range(12), quantity, width=1) # 设置X轴的刻度——为了让起点从零开始，所以i-1 _x = [i-0.5 for i in range(13)] _xticks_labels = interval+[150] plt.xticks(_x, _xticks_labels) plt.grid(linestyle='--') plt.show()  复杂分析图 # 使用gridspec和直方图绘制一个复杂分析图 import matplotlib.gridspec as gridspec x = np.random.random(size=10000) y = np.random.normal(loc=0., scale=1., size=10000) plt.figure() gspec = gridspec.GridSpec(3, 3) top_hist = plt.subplot(gspec[0, 1:]) side_hist = plt.subplot(gspec[1:, 0]) lower_right = plt.subplot(gspec[1:, 1:]) lower_right.scatter(x, y) top_hist.hist(x, bins=100, normed=True) side_hist.hist(y, bins=100, orientation='horizontal', normed=True) side_hist.invert_xaxis()  热图 　可用于三维数据可视化\nplt.imshow(arr) plt.hist2d() plt.colorbar() # 添加颜色条  其他  matplotlib支持的图形是非常多的，如果有其他的需求，可以查看一下url地址：http://matplotlib.org/gallery/index.html echarts中可以看框架实例 更多绘图工具： plotly:可视化工具中的github,相比于matplotlib更加简单,图形更加漂亮,同时兼容matplotlib和pandas 使用用法:简单,照着文档写即可 文档地址: https://plot.ly/python/  备注：如果想使用子图，用subplot函数，如果对比子图则徐亚坐标轴相同，添加sharey=（跟哪张图共享坐标轴）\nPandas绘图 Pandas的DataFrame绘图 先转换成dataframe格式进行画图\ndf.plot(kind=) pd.plotting.Tools pd.plotting.scatter_matrix() pd.plotting.parallel_coordinates()  绘制折线图 np.random.seed(100) df = pd.DataFrame({'A': np.random.randn(365).cumsum(0), 'B': np.random.randn(365).cumsum(0) + 20, 'C': np.random.randn(365).cumsum(0) - 20}, index=pd.date_range('2017/1/1', periods=365)) df.plot()  绘制散点图 df.plot('A', 'B', kind='scatter')  # 颜色(c)和大小(s)有'B'列的数据决定 ax = df.plot('A', 'C', kind='scatter', c='B', s=df['B'], colormap='viridis')  盒形图 df.plot(kind='box')  柱状图 df.plot(kind='hist', alpha=0.7) df.plot(kind='kde') # 拟合分布  Seaborn绘图 seaborn的安装：\n1. conda install seaborn 2. pip install seaborn  ","date":1611273600,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1611273600,"objectID":"bc0ba72ae8f8aed4b3757171e8e3b7df","permalink":"https://CoMath21.github.io/post/0-python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%901/","publishdate":"2021-01-22T00:00:00Z","relpermalink":"/post/0-python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%901/","section":"post","summary":"Python数据分析前的准备.","tags":["编程语言","Python","数据分析"],"title":"Python数据分析（一）","type":"post"},{"authors":["Xin态好先生","CoMath"],"categories":["学习笔记","编程语言"],"content":"  文字特殊标注\n  标题\n使用方式：#一级标题\t##二级标题\t######六级标题\n一级标题 二级标题 六级标题   下划线\nctrl+u\n下划线\n  强调\n使用方式：在强调的内容前后各添加两个*\nctrl+b\n强调的内容\n  斜体\n使用方式：内容前后各添加一个*\nctrl+i\n斜体内容\n  删除线\n使用方式：内容前后各添加两个~\n删除线\n  高亮\n使用方式：内容前后各添加两个=\n==高亮==\n    list\n  有序列表\n使用方式：数字1+.\n      无序列表\n使用方式：+/-/*\n       table\nctrl+t\n   序号 姓名 成绩 排名     1 张三 100 1            分割线\n使用方式：输入三个及以上*或-\n    插入元素\n  图片\n插入本地图片：直接把图片拖入即可； 插入网络图片：! [图片标题] (图片链接)\n  链接\n使用方式：[链接提示] (链接地址)\n百度\n  数学公式\n使用方式：$$ 回车 $$ x^2+x_1+7=0 $$\n  代码\n行内代码：代码两端各加一个`\n​\tSystem.out.println();\n代码块：输入三个~ 回车\npublic static void main(String[] args){ System.out.println(\u0026quot;hello world\u0026quot;); }      注意  使用信号符和文字间加一个空格或回车，即可产生效果 强大的导出功能  ","date":1611100800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1611100800,"objectID":"6e4a2227ea2c55aa7d75770fac9a6ee8","permalink":"https://CoMath21.github.io/post/0-typora%E4%BD%BF%E7%94%A8/","publishdate":"2021-01-20T00:00:00Z","relpermalink":"/post/0-typora%E4%BD%BF%E7%94%A8/","section":"post","summary":"Typor快速入门简介","tags":["编程语言","Typora"],"title":"Typora使用","type":"post"},{"authors":["Xin态好先生","CoMath"],"categories":null,"content":"一个人最好的生活状态，是该看书时看书，该玩时尽情玩，看见优秀的人欣赏，看到落魄的人也不轻视，有自己的小生活和小情趣，不用去想改变世界，努力去活出自己。没人爱时专注自己，有人爱时，有能力拥抱彼此\n","date":1611100800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1611100800,"objectID":"83707939014fe3796e181283a66a9a76","permalink":"https://CoMath21.github.io/talk/demo/","publishdate":"2021-01-20T00:00:00Z","relpermalink":"/talk/demo/","section":"talk","summary":"总要留点东西占个地方.","tags":[],"title":"测试-Demo","type":"talk"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"c1d17ff2b20dca0ad6653a3161942b64","permalink":"https://CoMath21.github.io/people/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/people/","section":"","summary":"","tags":null,"title":"关于","type":"widget_page"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"5fcc8730459b0823616811b99a622d2b","permalink":"https://CoMath21.github.io/category/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/category/","section":"","summary":"","tags":null,"title":"分类","type":"widget_page"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"9a6cb9348361050ffbcc0117246adb56","permalink":"https://CoMath21.github.io/tag/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/tag/","section":"","summary":"","tags":null,"title":"标签","type":"widget_page"}]