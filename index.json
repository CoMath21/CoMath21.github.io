[{"authors":null,"categories":null,"content":"","date":1611878400,"expirydate":-62135596800,"kind":"term","lang":"zh","lastmod":1611878400,"objectID":"7e67303e3d29a2216e9a2e04059938a0","permalink":"https://CoMath21.github.io/authors/comath/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/comath/","section":"authors","summary":"","tags":null,"title":"CoMath","type":"authors"},{"authors":null,"categories":null,"content":"关于我 96后，2019级计算数学硕士在读， 一个刚步入计算数学领域的小学生😂；本科专业信息与计算科学，当初作为一个刚刚步入大学生活的小年轻，没有过多的考虑，只想毕业工作挣钱😅. 在荒废了一年的时间后，开始学习计算机编程. C++入门，后自学Java进阶(也快忘的差不多了😖，不过编程的思想还在)，目前能够熟练掌握Matlab和Python(稍差一点). 相比较于编程，对数学的热爱略少一点(数学底子较差)，希望以后能够弥补这一短板. 不会抽烟，跟朋友会小酌一杯，喜欢动电影、动漫；运动细胞比较稀缺，仍不断开发训练中💪.\n为什么写博客 其实在我大三的时候就已经谋生了做个人博客的想法🤔，当时的我还是一心想着毕业之后工作，一直埋头于学程序、敲代码，很多学习笔记也是在那个时候积累的；凭借当初学习的Java、数据库等知识确实做了一个基于SSH框架的个人博客(如果还能重新搭建出原来的环境，我会将这个博客的代码共享出来😎)，想的是可以将学过的编程语言、遇到的各种Bug进行整理留个备份，方便自己随时翻阅；还有一个原因就是想着有这样一个完全由自己搭建的Blog能够得到HR的认可😄.直到后来选择读研就一直放下了，现在再捡起来的目的一是为了不想让当初整理的笔记无处安放，另一个也是为了督促自己能够在学习新知识的同时能把它讲出来，分享出来，这样对自己也是有推动作用的🧐. ","date":1611878400,"expirydate":-62135596800,"kind":"term","lang":"zh","lastmod":1611878400,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://CoMath21.github.io/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"关于我 96后，2019级计算数学硕士在读， 一个刚步入计算数学领域的小学生😂；本科专业信息与计算科学，当初作为一个刚刚步入大学生活的小年轻，没有过多的考虑，只想毕业工作挣钱😅. 在荒废了一年的时间后，开始学习计算机编程. C++入门，后自学Java进阶(也快忘的差不多了😖，不过编程的思想还在)，目前能够熟练掌握Matlab和Python(稍差一点). 相比较于编程，对数学的热爱略少一点(数学底子较差)，希望以后能够弥补这一短板. 不会抽烟，跟朋友会小酌一杯，喜欢动电影、动漫；运动细胞比较稀缺，仍不断开发训练中💪.\n为什么写博客 其实在我大三的时候就已经谋生了做个人博客的想法🤔，当时的我还是一心想着毕业之后工作，一直埋头于学程序、敲代码，很多学习笔记也是在那个时候积累的；凭借当初学习的Java、数据库等知识确实做了一个基于SSH框架的个人博客(如果还能重新搭建出原来的环境，我会将这个博客的代码共享出来😎)，想的是可以将学过的编程语言、遇到的各种Bug进行整理留个备份，方便自己随时翻阅；还有一个原因就是想着有这样一个完全由自己搭建的Blog能够得到HR的认可😄.直到后来选择读研就一直放下了，现在再捡起来的目的一是为了不想让当初整理的笔记无处安放，另一个也是为了督促自己能够在学习新知识的同时能把它讲出来，分享出来，这样对自己也是有推动作用的🧐. ","tags":null,"title":"Xin态好先生","type":"authors"},{"authors":["Xin态好先生","CoMath"],"categories":["学习笔记","编程语言"],"content":"Hibernate 是什么？  hibernate是一个轻量级JavaEE应用的持久层框架（framework） hibernate是一个ORM（object relation mapping对象关系映射）框架  o object -\u0026gt; 业务层(只对对象操作) r relation-\u0026gt; 关系数据库，关系型数据库中二维表 m mapping 对象关系映射文件  java类\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-\u0026gt;表 java对象\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;\u0026gt;表中记录 java对象属性\u0026mdash;\u0026mdash;-\u0026gt;表中字段     hibernate 处于我们项目的持久层位置(正因为如此，所以有人又把hibernate称为 持久层框架) hibernate 实际上就是对jdbc进行了轻量级的封装. hibernate 的基础还是我们java反射机制  手动配置hibernate方式完成crud操作 　首先创建项目，再引入jar包. hibernate开发的三种方式：\n 由domain object –\u0026gt; mapping -\u0026gt; db (官方推荐). 由DB开始，用工具生成mapping和domain object (使用较多). 由映射开始.  Employee.hbml.xml配置文件 \u0026lt;!DOCTYPE hibernate-mapping PUBLIC \u0026quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN\u0026quot; \u0026quot;http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\u0026quot;\u0026gt; \u0026lt;hibernate-mapping package=\u0026quot;com.hsp.domain\u0026quot;\u0026gt; \u0026lt;class name=\u0026quot;Employee\u0026quot; table=\u0026quot;employee\u0026quot;\u0026gt; \u0026lt;!-- id元素用于指定主键属性 --\u0026gt; \u0026lt;id name=\u0026quot;id\u0026quot; column=\u0026quot;id\u0026quot; type=\u0026quot;java.lang.Integer\u0026quot;\u0026gt; \u0026lt;!-- 该元素用于指定主键值生成策略hilo native increment sequence uuid --\u0026gt; \u0026lt;generator class=\u0026quot;sequence\u0026quot;\u0026gt; \u0026lt;param name=\u0026quot;sequence\u0026quot;\u0026gt;emp_seq\u0026lt;/param\u0026gt; \u0026lt;/generator\u0026gt; \u0026lt;/id\u0026gt; \u0026lt;!-- 对其它属性还有配置 --\u0026gt; \u0026lt;property name=\u0026quot;name\u0026quot; type=\u0026quot;java.lang.String\u0026quot;\u0026gt; \u0026lt;column name=\u0026quot;name\u0026quot; not-null=\u0026quot;false\u0026quot; /\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;email\u0026quot; type=\u0026quot;java.lang.String\u0026quot; \u0026gt; \u0026lt;column name=\u0026quot;email\u0026quot; not-null=\u0026quot;false\u0026quot;/\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;hiredate\u0026quot; type=\u0026quot;java.util.Date\u0026quot;\u0026gt; \u0026lt;column name=\u0026quot;hiredate\u0026quot; not-null=\u0026quot;false\u0026quot; /\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/class\u0026gt;\t\u0026lt;/hibernate-mapping\u0026gt;  hibernate.cfg.xml配置文件 \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt; \u0026lt;!DOCTYPE hibernate-configuration PUBLIC \u0026quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN\u0026quot; \u0026quot;http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd\u0026quot;\u0026gt; \u0026lt;hibernate-configuration\u0026gt; \u0026lt;session-factory\u0026gt; \u0026lt;!-- hibernate 设计者，给我们提供了一写常用的配置 --\u0026gt; \u0026lt;!-- 配置使用的driver --\u0026gt; \u0026lt;property name=\u0026quot;connection.driver_class\u0026quot;\u0026gt;oracle.jdbc.driver.OracleDriver\u0026lt;/property\u0026gt; \u0026lt;!-- 配置使用的账户密码 --\u0026gt; \u0026lt;property name=\u0026quot;connection.username\u0026quot;\u0026gt;scott\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;connection.password\u0026quot;\u0026gt;tiger\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;connection.url\u0026quot;\u0026gt;jdbc:oracle:thin:@127.0.0.1:1521:orclhsp\u0026lt;/property\u0026gt; \u0026lt;!-- 配置dialect方言,明确告诉hibernate连接是哪种数据库 --\u0026gt; \u0026lt;property name=\u0026quot;dialect\u0026quot;\u0026gt;org.hibernate.dialect.OracleDialect\u0026lt;/property\u0026gt; \u0026lt;!-- 显示出对于sql语句 --\u0026gt; \u0026lt;property name=\u0026quot;show_sql\u0026quot;\u0026gt;true\u0026lt;/property\u0026gt; \u0026lt;!-- 指定管理的对象映射文件 --\u0026gt; \u0026lt;mapping resource=\u0026quot;com/hsp/domain/Employee.hbm.xml\u0026quot;/\u0026gt; \u0026lt;/session-factory\u0026gt; \u0026lt;/hibernate-configuration\u0026gt;  说明：\n connection.driver_class:在etc下可以找到； hibernate.cfg.xml文件可以不写，但要在spring中配置.  测试文件TestMain.java package com.hsp.view; import com.hsp.util.*; import java.util.Date; import org.hibernate.Session; import org.hibernate.SessionFactory; import org.hibernate.Transaction; import org.hibernate.cfg.*; import com.hsp.domain.Employee; public class TestMain { public static void main(String[] args) { //查询[load]-\u0026gt;hql语句(hibernate query language) } public static void delEmp() { //删除 //获取一个session Session session=MySessionFactory.getSessionFactory().openSession(); Transaction ts=session.beginTransaction(); //删除1.先获取该雇员，然后删除 Employee emp=(Employee) session.load(Employee.class, 3); session.delete(emp); ts.commit(); session.close(); } public static void updateEmp() { // TODO Auto-generated method stub //修改用户 //获取一个会话 Session session=MySessionFactory.getSessionFactory().openSession(); Transaction ts=session.beginTransaction(); //修改用户1. 获取要修改的用户，2.修改 //load是通过主键属性，获取该对象实例.\u0026lt;---\u0026gt;表的记录对应 Employee emp=(Employee) session.load(Employee.class, 3); emp.setName(\u0026quot;韩顺平8\u0026quot;);//update... emp.setEmail(\u0026quot;abc@sohu.com\u0026quot;); ts.commit(); session.close(); } public static void addEmployee() { //我们使用hibernate完成crud操作[这里我们只见对象，不见表] //现在我们不是用service ,直接测试. //1. 创建Configuration,该对象用于读取hibernate.cfg.xml,并完成初始化 Configuration configuration=new Configuration().configure(); //2.创建SessoinFactory[这是一个会话工厂，是一个重量级的对象] SessionFactory sessionFactory=configuration.buildSessionFactory(); //3.创建Sessoin 相当于jdbc Connection[ servelt HttpSession ,也不是 jsp session] Session session=sessionFactory.openSession(); //4.对hiberate而言，要求在进行 增加，删除，修改的时候使用事务提交， Transaction transaction = session.beginTransaction(); //添加一个雇员 Employee employee=new Employee(); employee.setName(\u0026quot;shunping\u0026quot;); employee.setEmail(\u0026quot;shunping@sohu.com\u0026quot;); employee.setHiredate(new Date()); //insert ............. //保存 session.save(employee);//save employee就是持久化该对象 (把对象保存到了数据库中称为一条记录) //==\u0026gt;insert into ....[被hiberante封装] //提交 transaction.commit(); session.close(); } }  　\u0026lt;Hibernate-mapping\u0026gt;标签的属性如下：\n package：指定一个包前缀，如果在映射文档中(就是在class标签的那么属性里没有指定全类名)没有指定全限定的类名，就使用这个作为包名. schema：数据库schema的名称. catalog：数据库catalog的名称. default-cascade：默认的级联风格,默认为none. default-access：Hibernate用来访问属性的策略. default-lazy：指定了此属性，未明确注明lazy属性的Java属性和集合类，Hibernate会采取的默认使用这个属性加载风格,默认为true. auto-import：指定我们是否可以在查询语言中使用非全限定的类名,默认为true,如果项目中有两个同名的持久化类,则最好在这两个类的对应的映射文件中配置为false.  　Hibernate的子标签class标签：\n class 元素用于指定类和表的映射 . name:指定该持久化类映射的持久化类的类名.  example:\u0026lt;class name=\u0026quot;com.jeremy.hibernate.example.News\u0026quot; table=\u0026quot;NEWS\u0026quot;\u0026gt;.   table:指定该持久化类映射的表名, Hibernate 默认以持久化类的类名作为表名 .  example:\u0026lt;class name=\u0026quot;com.jeremy.hibernate.example.News\u0026quot; table=\u0026quot;NEWS\u0026quot;\u0026gt;.   dynamic-insert: 若设置为 true, 表示当（调用Session的save()方法时）保存一个对象时, 会动态生成 insert 语句, insert 语句中仅包含所有取值不为 null 的字段. 默认值为 false. Example:这个跟dynamic-update一个意思. dynamic-update: 若设置为 true, 表示当(调用对象的set()方法)更新一个对象时, 会动态生成 update 语句, update 语句中仅包含所有取值需要更新的字段. 默认值为 false.  　Hibernate映射文件主要内容:\n 映射内容的定义: Hibernate映射文件由\u0026lt;hibernate-mapping package=\u0026quot;JavaBean所在包的全路径\u0026quot;\u0026gt;节点定义映射内容并指定所对应的JavaBean的位置(也可以不在该节点中用package属性指定对应的JavaBean位置,而在该节点下的class节点中的name属性中指定). 数据库和JavaBean的关联: Hibernate映射文件中用\u0026lt;hibernate-mapping\u0026gt;节点下的 \u0026lt;class name=\u0026quot;JavaBean名称\u0026quot; table=\u0026quot;对应数据库中的表名\u0026quot;\u0026gt;节点指定数据库表和JavaBean的关联. ( 该节点的父节点中用package属性指定了JavaBean的包名时用)/全路径(该节点的父节点中没用package属性指定JavaBean的包名时用). 主键映射: 在\u0026lt;class \u0026gt;节点下用\u0026lt;id name=\u0026quot;数据库中主键在JavaBean中的属性名称\u0026quot; column=\u0026quot;数据库中主键名\u0026quot; type=\u0026quot;string\u0026quot;\u0026gt;节点映射对应的主键,该节点必须有且只有一个(因为主键只有一个),同时必须放在\u0026lt;property ...\u0026gt;节点前. 普通字段映射: 在\u0026lt;class ...\u0026gt;节点下用\u0026lt;property name=\u0026quot;数据库中字段在JavaBean中的属性名称\u0026quot; column=\u0026quot;数据库中的字段名\u0026quot; type=\u0026quot;string\u0026quot;/\u0026gt;节点映射普通字段,该节点可有多个(一个字段用一个该节点来映射).  　Heibernate的主键映射方式：\n　在\u0026lt;id ...\u0026gt;节点下用\u0026lt;generator class=\u0026quot;映射方式\u0026quot;/\u0026gt;节点指定Hibernate向数据库插入数据时主键的生成方式.\n assigned：应用程序自身对id赋值. 当设置\u0026lt;generator class=\u0026quot;assigned\u0026quot;/\u0026gt;时，应用程序自身需要负责主键id的赋值，由外部程序负责生成(在session.save()之前为对象的主键设置值),无需Hibernate参与，一般应用在主键为自然主键时. 例如XH为主键时，当添加一个学生信息时，就需要程序员自己设置学号的值，这时就需要应用该id生成器. native：由数据库对id赋值. 当设置\u0026lt;generator class=\u0026quot;native\u0026quot;/\u0026gt;时，数据库负责主键id的赋值，最常见的是int型的自增型主键. 例如，在SQLServer中建立表的id字段为identity，配置了该生成器，程序员就不用为该主键设置值，它会自动设置. identity：采用数据库提供的主键生成机制，为long/short/int型列生成唯一标识如SQL Server、MySQL中的自增主键生成机制. hilo：通过hi/lo算法实现的主键生成机制，需要额外的数据库表保存主键生成历史状态. seqhilo：与hi/lo类似，通过hi/lo算法实现的主键生成机制，只是主键历史状态保存在sequence中，适用于支持sequence的数据库，如Oracle. increment：主键按数值顺序递增. 此方式的实现机制为在当前应用实例中维持一个变量，以保存当前的最大值，之后每次需要生成主键的时候将此值加1作为主键. 这种方式可能产生的问题是：如果当前有多个实例访问同一个数据库，由于各个实例各自维护主键状态，不同实例可能生成同样的主键，从而造成主键重复异常. 因此，如果同一个数据库有多个实例访问，这种方式应该避免使用. sequence：采用数据库提供的sequence机制生成主键，用于用序列方式产生主键的数据库(如:Oracle、DB2等的Sequence),用于为long/short/int型列生成唯一标识,如:\u0026lt;generator class=\u0026quot;sequence\u0026quot;\u0026gt;\u0026lt;param name=\u0026quot;sequence\u0026quot;\u0026gt;序列名\u0026lt;/param\u0026gt;\u0026lt;/generator\u0026gt;如Oracle sequence. uuid.hex：由Hibernate基于128位唯一值产生算法，根据当前设备IP、时间、JVM启动时间、内部自增量等4个参数生成十六进制数值（编码后长度为32位的字符串表示）作为主键. 即使是在多实例并发运行的情况下，这种算法在最大程度上保证了产生id的唯一性. 当然，重复的概率在理论上依然存在，只是概率比较小. 一般而言，利用uuid.hex方式生成主键将提供最好的数据插入性能和数据平台适应性. uuid.string：与uuid.hex类似，只是对生成的主键进行编码（长度为16位）. 在某些数据库中可能出现问题. foreign：使用外部表的字段作为主键. 该主键一般应用在表与表之间的关系上，会在后面的表对应关系上进一步讲解. select：Hibernate 3新引入的主键生成机制，主要针对遗留系统的改造工程. 由于常用的数据库，如SQLServer、MySQL等，都提供了易用的主键生成机制（如auto-increase字段），可以在数据库提供的主键生成机制上，采用native生成器来配置主键生成方式.  Hibernate的核心类和接口 1、Configuration类 它的作用是：\n 负责管理hibernate的配置信息； 读取hibernate.cfg.xml文件； 加载hibernate.cfg.xml配置文件中配置的驱动文件，url，用户名，密码，连接池； 管理 *.hbm.xml对象关系文件.  2、hibernate.cfg.xml文件  该文件主要用于制定各个参数，值hibernate核心文件； 默认放在src目录下，也可以在别的目录下； 指定连接数据库的驱动、用户名、url、密码、连接池； 制定对象关系映射文件位置； 也可以使用hibernate,properties文件来替代该文件.  3、SessionFactory 接口  可以缓存SQL语句或者数据（称为）. 在应用程序化的时候创建，是一个重量级的类，一般用单例模式保证一个应用只需要一个SessionFactory实例. 如果某个应用访问多个数据库，则要创建多个回话工厂实例，一般一个数据库一个会话工厂实例. 通过SessionFactory接口可以获得Session实例.  Configuration cf = new Configuration().configure(); SessionFactory sf = cf.buildSessionFactory(); Session s = sf.getCurrentSession(); //或者：Session s = sf.openSession();  3.1 openSession()和getCurrentSession()区别  采用getCurrentSession()创建的session会绑定到当前线程中，而采用openSession()创建的Session则不会； 采用getCurrentSession()创建的session在commit或rollback时会自动关闭，而采用openSession()创建的session必须手动关闭（建议不管是用哪个，最好都要手动关闭）； 使用getCurrentSession()需要在hibernate.cfg.xml文件中加入如下配置：  * 如果使用的是本地事务（jdbc事务：针对一个数据库的事务）* \u0026lt;property name=\u0026quot;hibernate.current_session_context_class\u0026quot;\u0026gt;thread\u0026lt;/property\u0026gt; * 如果使用的是全局事务（jta事务：卷数据库的事务）* \u0026lt;property name=\u0026quot;hibernate.current_session_context_class\u0026quot;\u0026gt;jta\u0026lt;/property\u0026gt;  如何选择openSession()和getCurrentSession()\n原则：\n 如果需要在同一线程中，保证使用同一个Session，则使用getCurrentSession(). 如果在一个线程中，需要使用不同的Session，则使用openSession().  3.2\tget vs load 　可以使用session.get(Student.class,i)/session.load(…)获取值\n 如果查询不到数据，get会返回 null,但是不会报错, load如果查询不到数据，则报错ObjectNotFoundException 使用get 去查询数据，(先到一级/二级)会立即向db发出查询请求(select \u0026hellip;), 如果你使用的是 load查询数据，(先到一级、二级))即使查询到对象，返回的是一个代理对象,如果后面没有使用查询结果，它不会真的向数据库发select ,当程序员使用查询结果的时候才真的发出select ,这个现象我们称为“懒加载”(lazy) 通过修改配置文件，我们可以取消“懒加载”；  \u0026lt;class name=\u0026quot;Employee\u0026quot; lazy=\u0026quot;false\u0026quot; table=\u0026quot;employee\u0026quot;\u0026gt;  如何选择使用哪个: 如果你确定DB中有这个对象就用load(),不确定就用get()（这样效率高）.  4、Transaction（事务）接口 　事务简单地说就是一组对数据库的操作集合，他们要么全部成功，要么全部失败，这个可以保证数据的一致性，事务具有原子性.\n Transaction是底层的事物实现中抽取出来的接口； 可能是一个jdbc或者jta的事务，这样有利于hibernate在不同执行环境的移植； Hibernate要求显示的调用事务（如果仅仅是查询可以不调用）.  //增加删除修改如果发生异常要tx.rollback()回滚 Session sess = factory.openSession(); Transaction tx; try { tx = sess.beginTransaction(); //do some work ... tx.commit(); } catch (Exception e) { if (tx!=null) tx.rollback(); throw e; } finally { sess.close(); }  5、Query 接口 　Query接口类型的对象可以对数据库操作，他可以使用Hql，Qbc，Qbe和原生SQL（native Sql）对数据库操作，官方推荐使用Hql语句.\n//获取query引用[这里Employee不是表名，而是domain类名]，where后面的条件最好使用类下的属性名 Query query = session.createQuery(\u0026quot;from Employee where id=10\u0026quot;); //通过list方法获取结果，这个list会自动封装成对应的domain对象 List\u0026lt;Employee\u0026gt; list = query.list(); for(Employee e:list) ...  6、Criteria接口 　什么是QBC： QBC（Query By Criteria）按条件查询，通过Criteria构造查询条件，即通过调用Criteria的api实现各种查询.\n　通过Criteria对象拼装 查询条件，调用Criteria的add方法拼接查询条件，最终hibernate通过criteria对象自动生成sql语句.\n（了解）纯面向对象的检索方式\nSession session=HibernateUtil.getCurrentSession(); Transaction ts=null;\ttry {\tts=session.beginTransaction();\tCriteria cri = session.createCriteria(Employee.class). setMaxResults(2).addOrder(Order.desc(\u0026quot;id\u0026quot;) );//按照升序 List\u0026lt;Employee\u0026gt; list=cri.list(); for(Employee e: list){ System.out.println(e.getAaaid()); }\tts.commit();\t} catch (Exception e) {\tif(ts!=null){ ts.rollback(); } throw new RuntimeException(e.getMessage()); }finally{ //关闭session if(session!=null\u0026amp;\u0026amp;session.isOpen()){ session.close(); } }  MySQL记录总数查询  分页查询  投影查询方法  记录总数查询   DetachedCriteria  DetachedCriteria是什么？离线的Criteria. DetachedCriteria和Criteria区别：  Criteria创建方法：session.createCriteria DetachedCriteria创建方法：不需要session．   DetachedCriteria和Criteria相同点：实现查询条件拼装.  　建议使用DetachedCriteria，因为DetachedCriteria创建不需要session，在任何代码中通过DetachedCriteria 拼接查询条件. 这里的HibernateUtil为打开SessionFactory.\nservice 　接收servlet传入查询条件，将查询条件拼装成DetachedCritriea. @Override public Long findCustomerCount(CstCustomer cstCustomer) { //创建DetachedCriteria DetachedCriteria detachedCriteria = DetachedCriteria.forClass(CstCustomer.class); //根据cstCustomer中数据动态拼接查询条件 if(cstCustomer!=null){ //拼接客户名称查询条件，使用like if(cstCustomer.getCustName()!=null \u0026amp;\u0026amp; !cstCustomer.getCustName().equals(\u0026quot;\u0026quot;)){ detachedCriteria.add(Restrictions.like(\u0026quot;custName\u0026quot;, \u0026quot;%\u0026quot;+cstCustomer.getCustName()+\u0026quot;%\u0026quot;)); } //拼接联系人查询条件 if(cstCustomer.getCustLinkman()!=null \u0026amp;\u0026amp; !cstCustomer.getCustLinkman().equals(\u0026quot;\u0026quot;)){ detachedCriteria.add(Restrictions.eq(\u0026quot;custLinkman\u0026quot;,cstCustomer.getCustLinkman())); } } CstCustomerDao cstCustomerDao = new CstCustomerDaoImpl(); return cstCustomerDao.findCustomerCount(detachedCriteria); } @Override public List\u0026lt;CstCustomer\u0026gt; findCustomerList(CstCustomer cstCustomer, int firstResult, int maxResults) { CstCustomerDao cstCustomerDao = new CstCustomerDaoImpl(); //创建DetachedCriteria DetachedCriteria detachedCriteria = DetachedCriteria.forClass(CstCustomer.class); //拼接查询条件 //根据cstCustomer中数据动态拼接查询条件 if(cstCustomer!=null){ //拼接客户名称查询条件，使用like if(cstCustomer.getCustName()!=null \u0026amp;\u0026amp; !cstCustomer.getCustName().equals(\u0026quot;\u0026quot;)){ detachedCriteria.add(Restrictions.like(\u0026quot;custName\u0026quot;, \u0026quot;%\u0026quot;+cstCustomer.getCustName()+\u0026quot;%\u0026quot;)); } //拼接联系人查询条件 if(cstCustomer.getCustLinkman()!=null \u0026amp;\u0026amp; !cstCustomer.getCustLinkman().equals(\u0026quot;\u0026quot;)){ detachedCriteria.add(Restrictions.eq(\u0026quot;custLinkman\u0026quot;,cstCustomer.getCustLinkman())); } } return cstCustomerDao.findCustomerList(detachedCriteria, firstResult, maxResults); }  log4j学习 目标：学会使用log4j自定义输出日志信息.\nhibernate默认使用slf4j框架.\n slf4j：提供了一套日志记录接口规范. log4j：日志接口的实现类.  　如果 使用log4j需要以classpath下添加log4j.properties文件.\nLog4j包括三个主要部件，分别是：\n 记录器（Loggers）：配置日志在哪记录. 输出源（Appenders）：配置日志输出到哪里.  布局（Layouts），指定日志输出格式 记录器：  log4j.rootLogger=debug,A log4j.appender.A=org.apache.log4j.ConsoleAppender log4j.appender.A.layout=org.apache.log4j.PatternLayout  日志级别\n  日志级别由低到高为：ALL \u0026lt; TRACE \u0026lt; DEBUG \u0026lt; INFO \u0026lt; WARN \u0026lt; ERROR \u0026lt; FATAL \u0026lt; OFF.\n  日志级别越低输出日志越多，因为将系统调试信息设置级别低，系统的错误信息级别要高，设置成error.\n  根据log4j.properties中级别设置，将级别高的日志输出.\n在开发阶段设置为debug，在生产环境设置info或error.\n用MyEclipse进行hibernate快速开发 　手动配置:\ndb(table )-\u0026gt; 手写domain对象-\u0026gt;对象关系映射文件.\n现在我们希望用工具完成Domain对象和关系映射文件的工作. 错误信息\njava.lang.AbstractMethodError: com.microsoft.jdbc.base.BaseDatabaseMetaData.supportsGetGeneratedKeys()Z\n解决：microsoft提供的数据库驱动存在bug. 需要换一种驱动连接，使用jtds（下载地址）下载jtds1.2版，解压得到jtds-1.2.jar，引用到eclipse中项目目录下（去除原驱动引用），更改hibernate配置文件.\n原驱动连接配置：\n\u0026lt;property name=\u0026quot;connection.driver_class\u0026quot;\u0026gt;com.microsoft.jdbc.sqlserver.SQLServerDriver\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;connection.url\u0026quot;\u0026gt;jdbc:microsoft:sqlserver://127.0.0.1:1433;DatabaseName=hibernate\u0026lt;/property\u0026gt;  更改jtds连接：\n\u0026lt;property name=\u0026quot;connection.driver_class\u0026quot;\u0026gt;net.sourceforge.jtds.jdbc.Driver\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;connection.url\u0026quot;\u0026gt;jdbc:jtds:sqlserver://127.0.0.1:1433;DatabaseName=hibernate\u0026lt;/property\u0026gt;  问题得到解决.\n补充：java代码调原驱动连接数据库是没有问题的，搭配hibernate会有此问题.\n# HibernateUtil工具类： package com.haibao.util; import javax.persistence.Entity; import org.hibernate.Session; import org.hibernate.SessionFactory; import org.hibernate.cfg.Configuration; @Entity final public class HibernateUtil { private static SessionFactory sessionFactory = null; private static ThreadLocal\u0026lt;Session\u0026gt; threadLocal = new ThreadLocal\u0026lt;Session\u0026gt;(); private HibernateUtil(){}; static{ sessionFactory = new Configuration().configure().buildSessionFactory(); } public static Session openSession(){ return sessionFactory.openSession(); } public static Session getCurrentSession(){ Session session = threadLocal.get(); if(session==null){ session = sessionFactory.openSession(); threadLocal.set(session); } return session; } } # 实现类： package com.haibao.view; import javax.persistence.Entity; import org.hibernate.Session; import org.hibernate.Transaction; import com.haibao.bean.Person; import com.haibao.util.HibernateUtil; @Entity public class Main { public static void main(String[] args) { Session session = null; Transaction ts = null; try { session = HibernateUtil.getCurrentSession(); ts = session.beginTransaction(); Person p = new Person(); p.setName(\u0026quot;asd\u0026quot;); p.setSex(\u0026quot;男\u0026quot;); session.persist(p); ts.commit(); } catch (Exception e) { if(ts!=null){ ts.rollback(); } throw new RuntimeException(e.getMessage()); }finally{ if(session!=null \u0026amp;\u0026amp; session.isOpen()){ session.close(); } } } }  HQL语句（Hibernate Query Language） 　面向对象的查询语句，与SQL不同，HQl中的对象是区分大小写的（除了JAVA类和属性其他部分不区分大小写）；在HQL中查的是对象而不是表，并且支持多态；HQL主要通过Query来操作，Query的创建方式：\nQuery query = session.createQuery(hql);  　现在使用hibernate工具，自动生成 domain 对象 和映射文件,如果我们的表有主外键的关系，则应当先映射主表，再映射从表.\nuniqueResult方法 　如果我们检索一个对象，明确知道最多只有一个对象，则建议使用该方法，简单高效. 具体用法如下:\nStudent s=(Student) session.createQuery(\u0026quot;from Student where sid='20050003'\u0026quot;).uniqueResult(); System.out.println(s.getSname());  distinct的用法 过滤重复的记录\n//比如，显示所有学生的性别和年龄. List list=session.createQuery(\u0026quot;select distinct sage,ssex from Student\u0026quot;).list(); for(int i=0;i\u0026lt;list.size();i++){ Object [] objs=(Object[]) list.get(i); System.out.println(objs[0].toString()+\u0026quot; \u0026quot;+objs[1].toString()); }  between and.. List list=session.createQuery(\u0026quot;select distinct sage,ssex,sname from Student where sage between 20 and 22\u0026quot;).list(); for(int i=0;i\u0026lt;list.size();i++){ Object [] objs=(Object[]) list.get(i); System.out.println(objs[0].toString()+\u0026quot; \u0026quot;+objs[1].toString()+objs[2].toString()); }  in/not in //查询计算机系和外语系的学生信息 List\u0026lt;Student\u0026gt; list=session.createQuery(\u0026quot;from Student where sdept in ('计算机系','外语系')\u0026quot;).list(); //取出1. for 增强 for(Student s:list){ System.out.println(s.getSname()+\u0026quot; \u0026quot;+s.getSaddress()+\u0026quot; \u0026quot;+s.getSdept()); }  group by使用 //显示各个系的学生的平均年龄 List\u0026lt;Object[]\u0026gt; list=session.createQuery(\u0026quot;select avg(sage),sdept from Student group by sdept\u0026quot;).list(); //取出1. for 增强 for(Object[] obj:list){ System.out.println(obj[0].toString()+\u0026quot; \u0026quot;+obj[1].toString()); }  having的使用 //1.对分组查询后的结果，进行筛选:比如请显示人数大于3的系名称 //a. 查询各个系分别有多少学生. List\u0026lt;Object[]\u0026gt; list=session.createQuery(\u0026quot;select count(*) as c1,sdept from Student group by sdept having count(*)\u0026gt;3\u0026quot;).list(); //取出1. for 增强 for(Object[] obj:list){ System.out.println(obj[0].toString()+\u0026quot; \u0026quot;+obj[1].toString()); } //2查询女生少于200人的系 //a.查询各个系的女生有多个个 List\u0026lt;Object[]\u0026gt; list=session. createQuery(\u0026quot;select count(*) as c1,sdept from Student where ssex='F' group by sdept\u0026quot;).list(); //取出1. for 增强 for(Object[] obj:list){ System.out.println(obj[0].toString()+\u0026quot; \u0026quot;+obj[1].toString()); } //1.查询计算机系共多少人?-\u0026gt;如果我们返回的是一列数据 //这时我们的取法是直接取出list-\u0026gt;object 而不是 list-\u0026gt;Object[] List\u0026lt;Object[]\u0026gt; list=session.createQuery(\u0026quot;select sage from Student where sdept='计算机系'\u0026quot;).list(); //取出1. for 增强 for(Object obj:list){ System.out.println(obj.toString()); } //3.查询选修11号课程的最高分和最低分. List\u0026lt;Object[]\u0026gt; list=session. createQuery(\u0026quot;select 11,max(grade),min(grade) from Studcourse where course.cid=11\u0026quot;).list(); //取出1. for 增强 for(Object[] obj:list){ System.out.println(obj[0].toString()+\u0026quot; max=\u0026quot;+obj[1].toString()+\u0026quot; min=\u0026quot;+obj[2].toString()); } //4.计算各个科目不及格的学生数量. List\u0026lt;Object[]\u0026gt; list=session. createQuery(\u0026quot;select count(*),student.sdept from StudCourse where grade\u0026lt;60 group by student.sdept\u0026quot;).list(); //取出1. for 增强 for(Object[] obj:list){ System.out.println(obj[0].toString()+\u0026quot; \u0026quot;+obj[1].toString()); }  分页显示对象： 　根据用户输入的pageNow和pageSize现实对象\nQuery query = session.createQuery(hql); query.setFirdtRequest(从第几条取//从0开始计算); query.setMaxRequest(取出几条); List list = query.list(); //list就是结果 query = session.createQuery(得到count(*)的查询语句); int pageRow = (Integer)query.list().get(0).intValue();  参数绑定 　可以用setParameter()方法来确定变量的值：\nQuery query = session.createQuery(\u0026quot;from Student where sdept = :dept and sage\u0026gt;:age\u0026quot;); query.setParameter(参数名，值);  使用绑定参数的好处：\n 可读性好 性能提高 防止SQL注入（where 1=1）  提示：也可以使用setInteger().setString()…来指定值.\n另外：hql语句也可以用“?”来指定带绑定的参数.\nQuery query = session.createQuery(“from Student where sdept = ? and sage\u0026gt;?”); query.setParameter(0，值); query.setParameter(1，值);  在映射文件中得到hql语句 　可以从某些映射文件中得到hql语句，执行查询语句，这样可以更加灵活，在某种情况下，可以考虑使用. 比如：在Student.hbm.xml中.\n\u0026lt;query name=”myquerytest”\u0026gt; \u0026lt;![CDATA[select sname,ssex from Student where sage\u0026gt;22]]\u0026gt; \u0026lt;/query\u0026gt; 如何使用： List list = session.getNameQuery(“myQuerytest”).lise(); System.out.println(list.size()); Iterator iterator = list.iterator(); while(iterator.hasNext()){ Object obj[] = (Object[])iterator.next(); System.out.println(“N=”+obj[0]); }  使用子查询 hibernate中的对象存在三种关系  one-to-one：身份证←→人 one-to-many【many-to-one】部门←→员工 many-to-many：老师←→学生（尽量化简） 实际开发中，如果出现了many-to-many关系，用将其装换成两个one-to-many或者many-to-one，这样程序好控制，同时不会冗余.  criterial使用:\n//查询年龄大于10岁的学生 criteria Session s=HibernateUtil.getCurrentSession(); Transaction tx=s.beginTransaction(); Criteria cri=s.createCriteria(Student.class); //添加检索条件 cri.add(Restrictions.gt(\u0026quot;sage\u0026quot;, new Long(10))); List\u0026lt;Student\u0026gt; list=cri.list(); for(Student s1: list){ System.out.println(s1.getSname()); } tx.commit();  hibernate开发的三种方式中的 　编写domain object + 映射文件 \u0026mdash;\u0026mdash;\u0026gt; 创建出对应的数据库,这里我们说明如果要自动的创建出对应的数据库，需要做配置(hibernate.cfg.xml).\n\u0026lt;property name=\u0026quot;hbm2ddl.auto\u0026quot;\u0026gt;create\u0026lt;/property\u0026gt;  这里有四个配置值: create , update , create-drop, validate\n create:当我们的应用程序加载hibernate.cfg.xml[new Configuration().config();]就会根据映射文件，创建出数据库, 每次都会重新创建， 原来表中的数据就没有!!! update: 如果数据库中没有该表，则创建，如果有表，则看有没有变化，如果有变化，则更新. create-drop: 在显示关闭 sessionFactory时，将drop掉数据库的schema validate: 相当于每次插入数据之前都会验证数据库中的表结构和hbm文件的结构是否一致  　在开发测试中，我们配置哪个都可以测试，但是如果项目发布后，最好自己配置一次，让对应的数据库生成，完后取消配置.\ndomain对象的细节:\n 需要一个无参的构造函数(用于hibernate反射该对象) 应当有一个无业务逻辑的主键属性. 给每个属性提供 get/set方法. 在domian对象中的属性，只有配置到了对象映射文件xxx.hbm.xml后，才会被hiberante管理. 属性一般是private范围  对象关系映射文件的说明：\n　对象关系文件中，有些属性是可以不配，hibernate会采用默认机制，比如\u0026lt;class table=\u0026quot;?\u0026quot; \u0026gt; table 值不配，则以类的小写做表名；\u0026lt;property type=\u0026quot;?\u0026quot;\u0026gt; type不配置，则hibernate会根据类的属性类型，选择一个适当的类型.\nHibernate的三种状态：\n 瞬时态：对象刚刚被创建，没有处于session的管理下，同时在数据库没有记录； 持久态：既处于session的管理下，同时又被保存到数据库中（在数据库中有记录）； 脱管/游离态：没有在session管理下，但在数据库中有记录. 如何判断一个对象处于怎样的状态？  主要的依据是:\n 看该对象是否处于session管理； 看在数据库中有没有对应的记录.    瞬时态: 没有session管理,同时数据库没有对应记录;new了一个对象，此时对象就是瞬时态;瞬时态对象和数据库记录没有对关系，和session没有关系.\n  持久态: 有session管理，同时在数据库中有记录; 瞬时态对象执行save变化持久层;持久态对象和数据库记录存在对应关系，和session有关系.修改对象的属性，直接将数据保证到数据库.\n  管态/游离态： 没有session管理，但是在数据库中有记录.当session关闭后，持久态对象变为托管态;\t托管态对象和session没有关系，可能和数据库存在对象也可能不对应.\n  托管态和瞬时态区别\n 托管态对象:\t和session没有关联，可能和数据库存在对应关系，托管态对象中存在主键的值. 持久态对象:\t和session有状态 瞬时态对象:\t和session没有关联，和数据库记录没有对象关系，没有主键.  将瞬时态对象设置一个主键值，它就变为了托管态对象！！！\nsaveOrUpdate方法测试：  对瞬时态对象执行insert操作 对持久态对象执行update操作 对托管态对象执行update操作  懒加载: 　简述: 当我们查询一个对象的时候，在默认情况下,返回的只是该对象的普通属性（直接属性，不需要通过外键等查询得到）,当用户去使用对象属性时，才会向数据库发出再一次的查询.这种现象我们称为 lazy现象. 解决方法可以这样:\n 显示初始化代理对象： Hibernate.initized(student.getDepart())；与直接属性相连的对象. 修改对象关系文件 lazy 改写 lazy=false（说明：不要再one-to-many的one中设置false，在many中设置可以提高效率） 以上两种方法 不能直接解决懒加载问题. 通过过滤器(web项目) openSessionInView 添加一个过滤器  懒加载详解： 　懒加载（Load On Demand）是一种独特而又强大的数据获取方法，是指程序推迟访问数据库，这样可以保证有时候不必要的访问数据库，因为一次访问数据库是比较耗时的. 懒加载的几种情况： 首先明确一点：Domain Object是非finally的，才能实现懒加载. 解决方法：（因为要重写集合Set…）\n 明确初始化 在session还没有关闭时，访问一次xxx.getXxx()，强制访问数据库. 或者Hibernate.initialize(xxx)； openSessionView 这个往往需要过滤器配合使用(web程序)； 在ssh中，可以实现在service层，标准方式解决懒加载； 在映射文件中配置，lazy=false.  Hibernate的关系映射： mang-to-one： \u0026lt;!-- 对于private Department depart就不能用property many-to-one 的name=“变量名” column name=“将来生成表的名” --\u0026gt; \u0026lt;many-to-one name=\u0026quot;depart\u0026quot;\u0026gt; \u0026lt;column name=\u0026quot;depart_id\u0026quot;\u0026gt;\u0026lt;/column\u0026gt; \u0026lt;/many-to-one\u0026gt;  one-to-many 需求：查询所有一号部门的学生.\n常规思维：String hql = “from Student where dept.id=1”;\n还可以采用一对多：\n 现在Department中添加一个Set集合，并生成get/set方法； private Set stu;//一个部门可以对应多个学生 在Department.hbm.xml文件中添加  \u0026lt;set name=“集合对象属性名”\u0026gt; \u0026lt;key column=“外键名”\u0026gt; \u0026lt;one-to-many class=“集合存放的类名”\u0026gt; \u0026lt;/set\u0026gt; \u0026lt;!-- 配置onne-to-many关系 --\u0026gt; \u0026lt;set name=“stus” cascade=“联级”\u0026gt; \u0026lt;key column=“depart_id”\u0026gt; \u0026lt;one-to-many class=“Student”\u0026gt;  one-to-one 一对一有两种方式：\n 基于主键的一对一:   主键关联映射：其中一个表的主键依赖于另一张表的主键而建立起的一对一的关系，这两张互相关联的表的主键一致. 必须为one-to-one元素增加constrained=\u0026ldquo;true\u0026quot;属性，表明该类的主键由关联类生成.  【要点】Person - IdCard\n\u0026lt;id name=”id”\u0026gt; \u0026lt;generator class=”foreign”\u0026gt; \u0026lt;param name=”property”\u0026gt;idCard\u0026lt;/param\u0026gt; \u0026lt;/generator\u0026gt; \u0026lt;/id\u0026gt; \u0026lt;one-to-one name=”idCard” constrained=”true”/\u0026gt;  基于外键的一对一 和N-1相同，多添加一个unique=\u0026ldquo;true\u0026rdquo; 属性，用以表示N的一端必须唯一，加了唯一约束，即成了1-1  【举例】\n\u0026lt;one-to-one name=”idCard” property-ref=“person”/\u0026gt; \u0026lt;many-to-one name=”person” unique=”true” /\u0026gt; # property-ref：用于指定关联类的一个属性，这个属性将会和本外键相对应  many-to-many 　学生←→课程 顾客←→商品 student:one-to-mangy class Student{ private Integer id; private String name; private Set\u0026lt;StuCourse\u0026gt; stuCourses; }  从stucourse的角度看是 many-to-one class StuCourse{ private Integer id; private Student student; private Course course; private Integer grade; }  courset:one-to-mangy class Course{ private Integer id; private String name; private Set\u0026lt;StuCourse\u0026gt; stuCourses; }  cascade（Employee-Department、bbs项目等） 所谓级联操作就是说，当进行某个操作（添加/删除/修改…），就有hibernate自动完成. 例如：Department←→Employee当某个部门被删除后，员工也不会存在. 常用的cascade：none、all、save-update、delete、lock、refresh、evict、replic、persist、merge、delete-orphan(one-to-many). 一般对many-to-many，many-to-one不设置联级，在one-to-many和one-to-one中设置联级.\n在JSP页面中获取项目名称： \u0026lt;%=this.getServletContext().getContextPath()%\u0026gt; //java片段 ${ pageContext.request.contextPath } //通过标签  缓存 　缓存的作用主要用来提高性能，可以简单的理解成一个Map；使缓存涉及到三个操作：把数据放入缓存、从缓存获取数据、删除缓存中的无效数据.\n一级缓存（Session级共享） 一级缓存是 session对象中一块内存. 在同一个session中，查询一个对象是不会发出sql语句. session关闭一级缓存不存在了，再查询对象，会发出sql.\nsave，update，saveOrUpdate，load，get，list，iterator，lock这些方法都会将对象放在一级缓存中，一级缓存不能控制缓存的数量，所以要注意将大批量操作数据时可能造成内存溢出；可以用evict(清楚一个对象)，clear(清除所有对象)方法清除缓存的内容. 用HashMap来模拟一个Session缓存，加深对缓存的深入.\npackage com.hsp.view; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; public class MyCache { //使用map来模拟缓存 static Map\u0026lt;Integer,Student\u0026gt; maps=new HashMap\u0026lt;Integer,Student\u0026gt;(); public static void main(String[] args) { // TODO Auto-generated method stub getStudent(1); getStudent(1); getStudent(1); getStudent(1); getStudent(3); getStudent(3); } public static Student getStudent(Integer id){ //s.get() //先到缓存去 if(maps.containsKey(id)){ //在缓存有 System.out.println(\u0026quot;从缓存取出\u0026quot;); return maps.get(id); }else{ System.out.println(\u0026quot;从数据库中取\u0026quot;); //到数据库取 Student stu=MyDB.getStudentFromDB(id); //放入缓存 maps.put(id, stu); return stu; } } } //我的数据库 class MyDB{\tstatic List\u0026lt;Student\u0026gt; lists=new ArrayList\u0026lt;Student\u0026gt;(); //初始化数据库,假设有三个学生 static{ Student s1=new Student(); s1.setId(1); s1.setName(\u0026quot;aaa\u0026quot;); Student s2=new Student(); s2.setId(2); s2.setName(\u0026quot;bbb\u0026quot;); Student s3=new Student(); s3.setId(3); s3.setName(\u0026quot;ccc\u0026quot;); lists.add(s1); lists.add(s2); lists.add(s3); } public static Student getStudentFromDB(Integer id){ for(Student s: lists){ if(s.getId().equals(id)){ return s; } } return null;// 在数据库中没有. } } class Student{ private Integer id; private String name; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } }  二级缓存（SessionFactory级共享） 为什么需要二级缓存?\n　因为一级缓存有限(生命周期短),所以我们需要二级缓存(SessionFactory缓存)来弥补这个问题\n 需要配置 二级缓存是交给第三方去处理,常见的Hashtable , OSCache , EHCache 二级缓存的原理； 二级缓存的对象可能放在内存，也可能放在磁盘.  使用OsCache来演示二级缓存的使用.\n 配置二级缓存  对配置说明:\n\u0026lt;property name=\u0026quot;hbm2ddl.auto\u0026quot;\u0026gt;update\u0026lt;/property\u0026gt; \u0026lt;!-- 启动二级缓存 --\u0026gt; \u0026lt;property name=\u0026quot;cache.use_second_level_cache\u0026quot;\u0026gt;true\u0026lt;/property\u0026gt; \u0026lt;!-- 指定使用哪种二级缓存 --\u0026gt; \u0026lt;property name=\u0026quot;cache.provider_class\u0026quot;\u0026gt;org.hibernate.cache.OSCacheProvider\u0026lt;/property\u0026gt; \u0026lt;mapping resource=\u0026quot;com/hsp/domain/Department.hbm.xml\u0026quot; /\u0026gt; \u0026lt;mapping resource=\u0026quot;com/hsp/domain/Student.hbm.xml\u0026quot; /\u0026gt; \u0026lt;!-- 指定哪个domain启用二级缓存 特别说明二级缓存策略: 1. read-only 2. read-write 3. nonstrict-read-write 4. transcational --\u0026gt; \u0026lt;class-cache class=\u0026quot;com.hsp.domain.Student\u0026quot; usage=\u0026quot;read-write\u0026quot;/\u0026gt;  可以把oscache.properties文件放在 src目录下，这样你可以指定放入二级缓存的对象capacity 大小. 默认1000. 使用  // TODO Auto-generated method stub //通过获取一个sesion,让hibernate框架运行(config-\u0026gt;加载hibernate.cfg.xml) Session s=null; Transaction tx=null;\ttry { //我们使用基础模板来讲解. s=HibernateUtil.openSession(); tx=s.beginTransaction();\t//查询45号学生\tStudent stu1=(Student) s.get(Student.class, 45);//45-\u0026gt;一级缓存\tSystem.out.println(stu1.getName()); tx.commit();\t} catch (Exception e) { e.printStackTrace(); if(tx!=null){ tx.rollback(); } }finally{\tif(s!=null \u0026amp;\u0026amp; s.isOpen()){ s.close(); } }\tSystem.out.println(\u0026quot;*********************************\u0026quot;); try { //我们使用基础模板来讲解. s=HibernateUtil.openSession(); tx=s.beginTransaction();\t//查询45号学生\tStudent stu1=(Student) s.get(Student.class, 45);\tSystem.out.println(stu1.getName());\tStudent stu3=(Student) s.get(Student.class, 46);\tSystem.out.println(stu3.getName()); tx.commit();\t} catch (Exception e) { e.printStackTrace(); if(tx!=null){ tx.rollback(); } }finally{ if(s!=null \u0026amp;\u0026amp; s.isOpen()){ s.close(); } } //完成一个统计，统计的信息在Sessfactory //SessionFactory对象. Statistics statistics= HibernateUtil.getSessionFactory().getStatistics(); System.out.println(statistics); System.out.println(\u0026quot;放入\u0026quot;+statistics.getSecondLevelCachePutCount()); System.out.println(\u0026quot;命中\u0026quot;+statistics.getSecondLevelCacheHitCount()); System.out.println(\u0026quot;错过\u0026quot;+statistics.getSecondLevelCacheMissCount());  在配置了二级缓存后，请大家要注意可以通过 Statistics,查看你的配置命中率高不高.  事务管理  在hibernate设置隔离级别 在hibernate.cfg.xml中设置隔离级别：  \u0026lt;!-- 事务隔离级别 --\u0026gt; \u0026lt;property name=\u0026quot;hibernate.connection.isolation\u0026quot;\u0026gt;4\u0026lt;/property\u0026gt;  事务控制在哪里进行？  service(){ session.beginTransaction;//开启事务 try{ 调用dao方法1 调用dao方法2 ..... session.getTransaction().commit();//提交事务 }catch(Exception ex){ session.getTransaction().rollback();//回滚事务 } }  session如何管理 　在service接口中，每个dao请求中使用同一个session即使用同一个数据库连接，保证多个dao调用在一个事务中. 在service执行开始处开启一个新session，将session和当前线程绑定，在每个dao调用中获取当前线程绑定的session，实现每个dao获取到的session是同一个session. 主键增长策略  increment: 自增，每次增长1, 适用于所有数据库. 但是不要使用在多进程,主键类型是数值型 select max(id) from Student identity : 自增，每次增长1, 适用于支持identity的数据(mysql,sql server), 主键类型是数值 sequence native:会根据数据类型来选择，使用identity,sequence ,hilo select hibernate_sequence.nextval from dual.主键类型是数值long , short ,int  \u0026lt;id name=\u0026quot;id\u0026quot; type=\u0026quot;java.lang.Integer\u0026quot;\u0026gt; \u0026lt;generator class=\u0026quot;native\u0026quot;/\u0026gt; \u0026lt;/id\u0026gt;  hilo:hilo标识符生成器由Hibernate按照一种high/low算法生成标识符.  用法:\n\u0026lt;id name=”id” type=”java.lang.Integer” column=”ID”\u0026gt; \u0026lt;generator class=”hilo”\u0026gt; \u0026lt;param name=”table”\u0026gt;my_hi_value\u0026lt;/param\u0026gt; \u0026lt;param name=”column”\u0026gt;next_value\u0026lt;/param\u0026gt; \u0026lt;/generator\u0026gt; \u0026lt;/id\u0026gt;  uuid: 会根据uuid算法，生成128-bit的字串 主键属性类型不能是数值型，而是字串型 assigned: 用户自己设置主键值，所以主键属性类型可以是数值，字串 映射复合主键 foreign: 在one-to-one的关系中，有另一张表的主键(Person) 来决定 自己主键/外键( IdCard)  给出一个简单原则:\n 针对oracle [主键是int/long/short 建议使用 sequence] 主键是String 使用uuid或者assinged 针对 mysql [主键是 int/long/short 建议使用increment/assigend ,如果是字串 UUId/assigned] 针对 sql server [主键是 int/long/short 建议使用identity/native/assinged ,如果主键是字串，使用uuid/assigned ] one-to-one 又是基于主键的则使用foreign  Hibernate不适合的场景 　不适合OLAP（On-Line-Analytical Processing联机分析处理），已查询分析数据为主流的系统，适合OLTP（On-line transaction Processing联机事务处理）\n    OLTP OLAP     用户 操作人员，底层管理人员 决策人员，高级管理人员   功能 日常操作管理 分析决策   DB设计 面向应用 面向主题   数据 当前的，最新的，细节的，二维的分立的 历史的、聚集的、多维的集成的，统一的   存取 读/写数十条记录 读/写上百万 条记录   工作单位 简单事务 复杂查询   用户 上千个 上百个   DB大小 100M-GB 100GB-TB    ","date":1611878400,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1611878400,"objectID":"fe1a2ed54399c32bb0a8893cc5ff6170","permalink":"https://CoMath21.github.io/post/1-hibernate/","publishdate":"2021-01-29T00:00:00Z","relpermalink":"/post/1-hibernate/","section":"post","summary":"具体介绍Hibernate的相关内容.","tags":["编程语言","Java","Hibernate"],"title":"Hibernate学习笔记","type":"post"},{"authors":["Xin态好先生","CoMath"],"categories":["学习笔记","编程语言"],"content":"1、什么是Struts2: 　Struts2是一个基于MVC设计模式的Web应用框架，它本质上相当于一个servlet，在MVC设计模式中，Struts2作为控制器(Controller)来建立模型与视图的数据交互. Struts2是WebWork2基础发展而来的.\n2、Struts2优点：  Struts2的应用可以不依赖于Servlet API（request,response）和struts API；这种设计属于无侵入式设计. Struts2提供了拦截器,利用拦截器可以进行AOP编程,实现如权限拦截等功能. Struts2提供类型转换器,可以把特殊类型参数转换程序要的类型. Struts2提供支持多种表现层技术,如JSP,freeMarker,Velocity等. Struts2的输入校验可以对指定的方法进行校验. Struts2提供了全局范围、包范围、和Action范围的国际换资源文件管理实现.  3、搭建Struts2开发环境 3.1、开发Struts2应用依赖的jar文件 开发Struts2应用需要依赖的jar文件在解压目录的lib文件夹下,不同的应用需要的JAR包是不同的. 开发Struts2程序最少需要的JAR.\n struts2-core-2.x.x.jar ：Struts2框架的核心类库. xwork-2.x.x jar ：XWork类库,Struts2在其上构建. ognl-2.6.x.jar ：对象图导航语言(Object Graph Navigation Language),struts2框架通过其读写对象的属性. freemarker-2.3.x.jar ：Struts 2的UI标签的模板使用FreeMarker编写. commons-logging-1.1.x jar ：ASF出品的日志包,Struts2框架使用这个日志包来支持Log4J和JDK1.4+的日志记录. commons-fileupload-12 .1.jar ：文件上传组件,2 .1.6版本后必须加入此文件.   3.2、搭建Struts2开发环境  找到Struts2需要的几个jar包； 编写配置struts2的配置文件：src下创建struts.xml文件； 在web.xml中加入struts2 MVC框架启动配置  \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;struts2\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.apache.struts2.dispatcher.ng.filter. StrutsPrepareAndExecuteFilter\u0026lt;/filter-class\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;struts2\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt;  4、Struts.xml配置中的包介绍  配置包时必须指定name属性： 该属性名字可以任意,但是必须唯一,主要作用在于：如果其他包要继承该包就必须通过该属性(name属性)进行引用. 包的namespace属性： 用于定义该包的命名空间,命名空间作为访问该包下Action路径的一部分. 如果不配置,默认为””(空字符串). 继承方法extends： 通常每个包都应该继承struts-default包,因为Struts2很多核心的功能都是拦截器来实现的. struts-default定义了这些拦截器和Result类型；struts-default包是在struts2-core-2.jar文件中的struts-default.xml中定义的,struts-default.xml也是Struts2默认配置文件. Struts2每次都会自动加载struts-default.xml文件.\n  4.1、Action配置中的各种默认值  如果没有为action指定class,默认是ActionSupport. 如果没有为action指定method,默认执行action中的execute()方法. 如果没有指定action的name属性,默认值为success.  Action中的result的各种转发类型 　Struts2常用的结果类型有：dispathcher(默认值)、redirect(重定向)、redirectAction、plainText 在result中可以使用${属性名}表达式访问action中的属性,表达式里的属性名对应action中的属性.\n dispathcher(默认值)：内部请求转发 redirect(重定向)：  // 格式： \u0026lt;result type=\u0026quot;redirect\u0026quot;\u0026gt;/hello.jsp\u0026lt;/result\u0026gt; // 如果重定向需要带参数,则用： \u0026lt;result type=\u0026quot;redirect\u0026quot;\u0026gt;/hello.jsp?id=${id}\u0026lt;/result\u0026gt;  此时,需要在对应的Action下有对应的变量,并且提供get属性. 注意：重定向不能访问WEB-INF下的文件.\n redirectAction(在其他*Action下)：  // 格式： \u0026lt;action name=\u0026quot; redirectActionName\u0026quot;\u0026gt; \u0026lt;result type=\u0026quot; redirectAction\u0026quot;\u0026gt;重定向的name\u0026lt;/result\u0026gt; \u0026lt;/action\u0026gt; // 如果不不在同一个包下需配置项 \u0026lt;result type=\u0026quot; redirectAction\u0026quot;\u0026gt; \u0026lt;param name=\u0026quot; actionName\u0026quot;\u0026gt;xxx\u0026lt;/param\u0026gt; \u0026lt;param name=\u0026quot; namespace\u0026quot;\u0026gt;/…/…\u0026lt;/param\u0026gt; \u0026lt;/result\u0026gt;  补充.\n中文字符编码、解码\n 编码(java.net.URLEncoder)：URLEncoder.encode(\u0026quot;字符串\u0026quot;,\u0026quot;UTF-8\u0026quot;); 解码(java.net.URLDecoder)：URLDecoder.encode(new String (request.getParameter(\u0026quot;属性名\u0026quot;).getBytes(\u0026quot;ISO8859-1\u0026quot;),\u0026quot;UTF-8\u0026quot;),\u0026quot;UTF-8\u0026quot;); JSP文件中可以用$(param.属性名)访问Action中的属性(会乱码)  　plaintext(显示原始文件内容的重定向)：例如某功能需要查看源代码\n\u0026lt;action name=\u0026quot; plainText\u0026quot;\u0026gt; \u0026lt;result type=\u0026quot; plainText\u0026quot;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;/action\u0026gt;  注意：当该JSP文件存在中文的时候,会乱码！  需要加入：\n\u0026lt;param name=\u0026quot; location\u0026quot;\u0026gt;/xxx.jsp\u0026lt;/param\u0026gt;\u0026lt;!—定向的路径--\u0026gt; \u0026lt;param name=\u0026quot; charSet\u0026quot;\u0026gt;UTF-8\u0026lt;/param\u0026gt;\u0026lt;!--指定读取文件的编码--\u0026gt;  附：Struts2的全视图 单个包下：\n\u0026lt;package name=\u0026quot; xxx\u0026quot; namespace=\u0026quot; /…/…\u0026quot; extends=\u0026quot; struts-default\u0026quot;\u0026gt; \u0026lt;global-results\u0026gt;\t\u0026lt;result type=\u0026quot; mess…\u0026quot;\u0026gt;/…/…\u0026lt;/result\u0026gt; \u0026lt;/global-results\u0026gt; \u0026lt;/package\u0026gt;  全局：(在一个包中写,然后其他包继承该包)\n4.2、为Action属性注入值 \u0026lt;package name=\u0026quot; xxx\u0026quot; namespace=\u0026quot; /…/…\u0026quot; extends=\u0026quot; struts-default\u0026quot;\u0026gt; \u0026lt;action name=\u0026quot; list\u0026quot; class=\u0026quot;com.haibao.HelloWorldAction\u0026quot; method=\u0026quot;execute\u0026quot;\u0026gt; \u0026lt;param name=\u0026quot;path \u0026quot;\u0026gt;/image\u0026lt;/param\u0026gt; \u0026lt;result name=\u0026quot;success \u0026quot;\u0026gt;/xxx.jsp \u0026lt;/result\u0026gt; \u0026lt;/action\u0026gt; \u0026lt;/package\u0026gt;  附：在HelloWorldAction下必须存在“path”属性的get方法 ,访问xxx.jsp得到的是“/image”\n5、指定struts2处理的请求后缀 5.1、默认后缀及修改 默认后缀：.action 默认后缀可以通过常量\u0026quot;struts.action.extension\u0026quot;进行修改\n\u0026lt;constant name=\u0026quot; struts.action.extension\u0026quot; value=\u0026quot;do\u0026quot;/\u0026gt;  如果用户指定多个请求后缀,则多个后缀之间以英文逗号( , )隔开\n\u0026lt;constant name=\u0026quot; struts.action.extension\u0026quot; value=\u0026quot;do,action\u0026quot;/\u0026gt;  5.2、常用的常量 \u0026lt;!--指定默认编码集,作用于HTTPServletRequest的setCharacterEncoding方法和freemarker、velocity的输出--\u0026gt; \u0026lt;constant name=\u0026quot; struts.i18n.encoding\u0026quot; value=\u0026quot;UTF-8\u0026quot;/\u0026gt; \u0026lt;!-- 该属性指定需要的struts2处理的后缀请求如果用户指定多个请求后缀,则多个后缀之间以英文逗号(,)隔开--\u0026gt; \u0026lt;constant name=\u0026quot; struts.action.extension\u0026quot; value=\u0026quot;do,action\u0026quot;/\u0026gt; \u0026lt;!-- 设置浏览器是否缓存静态内容. 默认值为true(生产环境下使用)--\u0026gt; \u0026lt;constant name=\u0026quot;struts.serve.static.browserCache\u0026quot; value=\u0026quot;false\u0026quot;/\u0026gt; \u0026lt;!-- 当struts的配置文件修改后,系统是否自动重新加载该文件,默认false(生产环境下使用) --\u0026gt; \u0026lt;constant name=\u0026quot; struts.configuration.xml.reload\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;!-- 开发模式下使用,这样可以打印出更详细的错误信息 --\u0026gt; \u0026lt;constant name=\u0026quot; struts.devMode\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;!-- 默认的视图主题 --\u0026gt; \u0026lt;constant name=\u0026quot; struts.ui.theme\u0026quot; value=\u0026quot;smple\u0026quot;/\u0026gt; \u0026lt;!-- 与Spring集成时,指定有Spring负责action对象的创建 --\u0026gt; \u0026lt;constant name=\u0026quot; struts.objectFactory\u0026quot; value=\u0026quot;spring\u0026quot;/\u0026gt; \u0026lt;!-- 该属性设置Struts2是否支持动态方法调用,默认为true --\u0026gt; \u0026lt;constant name=\u0026quot; struts.enable.DynamicMethodlnvocation\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;!-- 上传文件的大小限制 --\u0026gt; \u0026lt;constant name=\u0026quot; struts.multipart.maxSize\u0026quot; value=\u0026quot;10701096\u0026quot;/\u0026gt;  5.3、常量的定义 常量可以在struts.xml或struts.propreties中配置,建议在struts.xml中配置 在struts.xml文件中配置常量：\n\u0026lt;struts\u0026gt; \u0026lt;constant name=\u0026quot;struts.action.extension\u0026quot; value=\u0026quot;do\u0026quot;\u0026gt; \u0026lt;/struts\u0026gt;  在struts.propreties中配置常量：\nstruts.action.extension=do  常量可以在下面多个配置文件中定义,加载常量的搜索顺序为：\n struts-default.xml struts-plugin.xml struts.xml struts.propreties web.xml  多个文件中配置了同一个常量,则后一个文件中配置的常量值会覆盖前面文件中配置的常量值.\n6、Struts2的处理流程 StrutsPrepareAndExecuteFilter是Struts的核心控制器,他负责拦截由/*指定的所有用户请求,当用户请求到达时,给Filter会过滤用户的请求. 默认情况下,如果用户请求路径不带后缀或者以.action结尾,这时请求被转入Struts2框架处理,否则Struts2框架将略过该请求的处理. 当请求转入Struts2框架处理时会经过一系列的拦截器,然后到Action. 与Struts1不同,Struts2对用户的每一次请求都会创建一个Action,所以Struts2中的Action是线程安全的.\n为应用指定多个Struts配置文件\n　在大部分应用里,随着应用规模的增加,系统中Action的数量也会大大增加,导致struts.xml配置文件变得臃肿,为了避免struts.xml文件过于庞大,提高struts.xml文件的可读性,可以将一个struts.xml配置文件分解成多个配置文件,然后在struts.xml文件中包含其他配置文件(通过元素指定多个配置文件)\n\u0026lt;struts\u0026gt; \u0026lt;include file=\u0026quot;struts-user.xml\u0026quot;/\u0026gt; \u0026lt;include file=\u0026quot;struts-order.xml\u0026quot;/\u0026gt; \u0026lt;/struts\u0026gt;  7、动态方法调用：  动态方法调用DMI（动态指定）,可以在url地址中动态指定action执行哪个方法,可以通过action+!+方法名. (注：只要Action对象中有这个方法,并且返回类型为String就可以调用,这样struts.xml文件配置文件就可以不需要配置method属性)： 设置Struts2是否支持动态方法调用,如果没有这一行要加上去,要不然会报错误,如果你加上这一行,但是你把value值改成false,也会报错！   8、使用通配符定义action 　其中*匹配所有,在method=\u0026quot;{数字}\u0026ldquo;中用{数字}表示匹配第几个*,其中跳转页面的命名也是根据第一个*的值进行的. 9、请求参数的接收 　在Action中必须存在该属性并且存在该属性的set方法,这样在url中赋值才能接收到get方法直接在url后面加入“?属性名=属性值\u0026amp;属性名=属性值”\n9.1、基本类型 9.2、复合类型 （为了减少复杂度,尽量用复合类型） 原理：Struts2首先通过反射技术调用Person的默认构造器创建product对象,然后再通过反射技术调用product中与请求参数同名的属性的setter方法来获取请求参数的值.\n10、关于Struts2.1.6接收中文请求参数乱码问题 　Struts2.1.6版本中存在一个Bug,即接收到的中文请求参数为乱码（以post方法提交）,原因是struts2.1.6在获取并使用了请求参数后才调用HttpServletRequest的setCharacterEncoding()方法进行编码设置,导致应用使用的就是乱码请求参数.\n解决方法：新建一个Filter,把这个Filter放置在Struts2的Filter之前,然后在doFilter()方法里添加一下代码：\npublic void doFilter(…){ HttpServletRequest req = (HttpServletRequest)request; req.setCharacterEncoding(\u0026quot;UTF-8\u0026quot;); filterchain.doFilter(request,response); }  11、自定义类型转换器 11.1、局部类型转换器：  首先需要定义类并继承DefaultTypeConverter类; 在Action类所在的包下放置ActionClassName-conversion.properties文件；其中ActionClassName是Action的类名,后面的-conversion.properties是固定写法; 在.properties文件中内容为：属性名称=类型转换器的全类名. 以出生年月为例：   11.2、全局类型转换器： 在src(根目录)下放置xwork-conversion.properties. 文件中的内容为： 带转换的类型=类型转换器的全类名 例如：java.util.Date=com.haibao.… 11.3、访问或添加属性 仅仅是为了访问添加：\npublic String scope() throws Exception{//方法 ActionContext ctx = ActionContext.getContext(); ctx.getApplication().put(\u0026quot;app\u0026quot;,\u0026quot;应用范围\u0026quot;);//往ServletContext里放入app ctx.getSession().put(\u0026quot;ses\u0026quot;,\u0026quot;session范围\u0026quot;)；//往ServletContext里放入ses ctx.put(\u0026quot;req\u0026quot;,\u0026quot;request范围\u0026quot;)；//往ServletContext里放入req return \u0026quot;scope\u0026quot;;// }  JSP中：\n\u0026lt;body\u0026gt; ${applicationScope.app}\u0026lt;br\u0026gt; ${sessionScope.ses}\u0026lt;br\u0026gt; ${requestScope.ses}\u0026lt;br\u0026gt; \u0026lt;body\u0026gt;  要是想得到对象：\n// 方法一：通过ServletActionContext类直接实现 public String rsa() throws Exception{//方法 HttpServletRequest request = ServletActionContext.getRequest(); ServletContext servletContext = ServletActionContext.getServletContest(); request.setAttribute(\u0026quot;req\u0026quot;,\u0026quot;应用范围\u0026quot;); request.getSession().setAttribute(\u0026quot;ses\u0026quot;,\u0026quot;session范围\u0026quot;)； servletContext.setAttribute(\u0026quot;app\u0026quot;,\u0026quot;应用范围\u0026quot;); return \u0026quot;scope\u0026quot;;// } // 方法二：通过指定接口,有Struts框架运行时注入 public class HelloWorldAction implements ServletRequestAware, ServletResponseAware,ServletContextAware{ private HttpServletRequest requesr; private ServletContextResponse Context; private HttpServletResponse response; public void setServletRequest(HttoServletRequest req){ this.request = req; } public void setServletResponse(){ } public void setServletContext(){ }  12、文件上传 12.1、单文件上传 步骤\n 第一步：在WEB-INF/lib下加入commons-fileupload-1.2.1.jar（2.1版本之后必须添加）、commons-io.jar（需要用到里面的工具类） 第二步：把form表的enctype设置为：“multipart/form-data”  \u0026lt;form action=\u0026quot;${pageContext.request.contextPath}/uploadAction_execute.action\u0026quot; enctype=\u0026quot;multipart/form-data\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; 文件：\u0026lt;input type=\u0026quot;file\u0026quot; name=\u0026quot;image\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;上传\u0026quot;\u0026gt; \u0026lt;/form\u0026gt;  第三步：在Action类中添加以下属性  public class UploadAction { private File image;// 文件名称 // 如果想得到上传文件的名称,则定义文件名. 格式：文件名称+FileName private String imageFileName;// 得到上传文件名称 // 如果想得到文件的类型,则定义文件名. 格式：文件名称+ContextType private String imageContextType; public String getImageFileName() { return imageFileName; } public void setImageFileName(String imageFileName) { this.imageFileName = imageFileName; } // 提供与字段名称相符的get、set属性,以便得到上传的文件 public File getImage() { return image; } public void setImage(File image) { this.image = image; } public String execute() throws Exception { // 在该方法下进行保存 String realPath = ServletActionContext.getServletContext().getRealPath( \u0026quot;/images\u0026quot;);// 得到根目录 System.out.println(\u0026quot;*****\u0026quot; + realPath + \u0026quot;****\u0026quot;); if (image != null) { File savefile = new File(new File(realPath), imageFileName);// 保存到... if (!savefile.getParentFile().exists()) savefile.getParentFile().mkdirs(); FileUtils.copyFile(image, savefile);// 调用commons-io.jar下的工具类Copy文件到指定位置 ActionContext.getContext().put(\u0026quot;message\u0026quot;, \u0026quot;上传成功\u0026quot;);// 返回信息 } return \u0026quot;success\u0026quot;; } }  12.2、多文件上传 　只需要将单文件上传的第三步：在Action类中添加以下属性中把单个文件变成数组.\npublic class moreUploadAction { private File[] image;// 文件名称 // 如果想得到上传文件的名称,则定义文件名. 格式：文件名称+FileName private String[] imageFileName;// 得到上传文件名称 // 如果想得到文件的类型,则定义文件名. 格式：文件名称+ContextType private String[] imageContextType; public File[] getImage() { return image; } public void setImage(File[] image) { this.image = image; } public String[] getImageFileName() { return imageFileName; } public void setImageFileName(String[] imageFileName) { this.imageFileName = imageFileName; } public String[] getImageContextType() { return imageContextType; } public void setImageContextType(String[] imageContextType) { this.imageContextType = imageContextType; } public String execute() throws Exception { // 在该方法下进行保存 String realPath = ServletActionContext.getServletContext().getRealPath( \u0026quot;/images\u0026quot;);// 得到根目录 System.out.println(\u0026quot;*****\u0026quot; + realPath + \u0026quot;****\u0026quot;); if (image != null) { File savedir = new File(realPath); if (!savedir.exists()) savedir.mkdirs(); for (int i = 0; i \u0026lt; image.length; i++) { File savefile = new File(savedir, imageFileName[i]);// 保存到... FileUtils.copyFile(image[i], savefile);// 调用commons-io.jar下的工具类Copy文件到指定位置 } ActionContext.getContext().put(\u0026quot;message\u0026quot;, \u0026quot;上传成功\u0026quot;);// 返回信息 } return \u0026quot;success\u0026quot;; } }  13、自定义拦截器 需求：对于登陆的用户可以访问Action中的所有方法,而没有登录的用户则不可以访问任何方法.\n方法：添加自定义拦截器. 实现com.opensymphony.xwork2.interceptor.interceptor接口\n@Override public String intercept(ActionInvocation arg0) throws Exception { // 当拦截到Action时执行该方法 // 得到session中存在的对象 Object user = ActionContext.getContext() .getSession().get(\u0026quot;user\u0026quot;); // 如果希望被拦截的的方法执行,调用arg0.invoke(); if (user != null) return arg0.invoke();//如果User不为null,代表合法用户,允许访问方法 // 返回的是Action中对应方法的返回值String ActionContext.getContext().put(\u0026quot;message\u0026quot;, \u0026quot;请先登录\u0026quot;); return \u0026quot;success\u0026quot;; }  在struts.xml中定义拦截器\n\u0026lt;!-- 定义拦截器 --\u0026gt; \u0026lt;interceptors\u0026gt; \u0026lt;!-- 自定义拦截器 --\u0026gt; \u0026lt;interceptor name=\u0026quot;permission\u0026quot; class=\u0026quot;com.haibao.interceptor.PermissionInterceptor\u0026quot; /\u0026gt; \u0026lt;!-- 定义拦截器栈 目的：使得Struts2自带的拦截器有效 --\u0026gt; \u0026lt;interceptor-stack name=\u0026quot;permissionStack\u0026quot;\u0026gt; \u0026lt;interceptor-ref name=\u0026quot;defaultStack\u0026quot;/\u0026gt; \u0026lt;interceptor-ref name=\u0026quot;permission\u0026quot;/\u0026gt; \u0026lt;/interceptor-stack\u0026gt; \u0026lt;/interceptors\u0026gt; \u0026lt;action name=\u0026quot;loginAction_*\u0026quot; class=\u0026quot;com.haibao.action.LoginAction\u0026quot;\tmethod=\u0026quot;{1}\u0026quot;\u0026gt; \u0026lt;result name=\u0026quot;success\u0026quot;\u0026gt;/WEB-INF/page/LoginPage.jsp\u0026lt;/result\u0026gt; \u0026lt;interceptor-ref name=\u0026quot;permissionStack\u0026quot;/\u0026gt; \u0026lt;/action\u0026gt;  注意： 如果直接在action中定义使用拦截器,则不会在使用Struts自带拦截器！这样Struts2的优势就没有了，所以引入拦截器栈的概念，在拦截器栈中要把Struts的拦截器写在前面，以保证web项目会首先执行Struts再带的拦截器. 如果想所有的程序都是用自定义的拦截器，可以使用：\n\u0026lt;default-interceptor-ref name=\u0026quot;permissionStack\u0026quot;/\u0026gt;  效果演示：\n直接访问会被拦截： 登录后访问 14、输入校验 　Struts2中可以实现对action的所有方法进行校验或者对action的指定方法进项校验，实现方法有两种：\n 采用手工编写代码实现   对所有方法进行校验 重写validate()方法实现，validate()方法会校验action中所有的与execute方法签名相同的方法. 当某个数据校验失败时，调用addFieldError()方法往系统的fieldErrors添加校验失败信息，（为了使用addFieldError()方法，action可以继承ActionSupport），如果系统的fieldError包含失败信息，struts2会将请求转发到名为input的result. 在input视图中可以通过\u0026lt;s:fielderror/\u0026gt;显示失败信息. 需要引入标签  \u0026lt;%@ taglab url=\u0026quot;/struts-tags\u0026quot; prefix=\u0026quot;s\u0026quot;%\u0026gt;  public void validate(){ if(this.mobile==null||\u0026quot;\u0026quot;.equals(this.mobile.trim())){ this.addFieldError(\u0026quot;username\u0026quot;,\u0026quot;用户名不能为空\u0026quot;); } if(this.mobile==null||\u0026quot;\u0026quot;.equals(this.mobile.trim())){ this.addFieldError(\u0026quot;mobile\u0026quot;,\u0026quot;手机号不能为空\u0026quot;); }else{ if(!Pattern.compile(\u0026quot;^1[358]\\\\d{9}\u0026quot;).matcher(this.mobile.trim()).matches()){ this.addFieldError(\u0026quot;mobile\u0026quot;,\u0026quot;手机号格式不正确\u0026quot;); } }\t}   对指定方法进行校验  　重写validateXxx()方法实现，validate()方法会校验action中所有的与execute方法签名相同的方法. 当某个数据校验失败时，调用addFieldError()方法往系统的fieldErrors添加校验失败信息，（为了使用addFieldError()方法，action可以继承ActionSupport），如果系统的fieldError包含失败信息，struts2会将请求转发到名为input的result. 在input视图中可以通过\u0026lt;s:fielderror/\u0026gt;显示失败信息. 需要引入标签\n\u0026lt;%@ taglab url=\u0026quot;/struts-tags\u0026quot; prefix=\u0026quot;s\u0026quot;%\u0026gt;  public void validateUpdata(){ if(this.mobile==null||\u0026quot;\u0026quot;.equals(this.mobile.trim())){ this.addFieldError(\u0026quot;username\u0026quot;,\u0026quot;用户名不能为空\u0026quot;); } if(this.mobile==null||\u0026quot;\u0026quot;.equals(this.mobile.trim())){ this.addFieldError(\u0026quot;mobile\u0026quot;,\u0026quot;手机号不能为空\u0026quot;); }else{ if(!Patten.compile(\u0026quot;^1[358]\\\\d{9}\u0026quot;).matcher(this.mobile.trim()).matches()){ this.addFieldError(\u0026quot;mobile\u0026quot;,\u0026quot;手机号格式不正确\u0026quot;); } } }   输入校验的流程  类型转换器队请求参数执行类型转换，并把转换后的赋值给action中的属性. 如果在执行类型转换的过程中出现异常，系统会将异常信息保存到ActionContext，conversionError拦截器将异常信息封装到fieldErrors里. 不管类型转换是否出现异常，都会进入第3步. 系统通过反射技术先调用action中的validateXxx()方法，Xxx为方法名. 在调用action中的validate()方法. 经过上面4步，如果系统中的fieldErrors存在错误信息（即存放错误信息的集合的size\u0026gt;0），系统自动将请求转发至名称为input视图. 如果系统中的fieldErrors没有任何错误信息，系统将执行action中的处理方法.    基于XML配置方式实现  　a) 对所有方法进行校验\n　在Action相同包下创建ActionClassName-validation.xml文件. Struts2 的验证规则大概有以下数种：\n required:必填校验器，要求field的值不能为null requiredstring:必填字符串校验器，要求field的值不能为null,并且长度大于0，默 认情况下会对字符串去掉前后空格 int:整数校验器，要求field的值必须在整数范围内，min指定最小值，max指定最大值 double:双精度浮点数校验器 date:日期校验器 expression:表达式校验器 fieldexpression:字段表达式校验器 email:电子邮件校验器，要求如果field的值非空，则必须是合法的邮件地址 url:网址校验器，要求如果field的值非空，则必须是合法的url地址 visitor:Visitor校验器，用于校验action的复合属性，它指定一个校验文件用于校验复合属性中的属性 conversion:转换校验器 stringlength:字符串长度校验器 regex:正则表达式校验器  常用的验证规则：  必填检验  \u0026lt;validators\u0026gt; \u0026lt;field name=\u0026quot;username\u0026quot;\u0026gt; \u0026lt;field-validator type=\u0026quot;required\u0026quot;\u0026gt; \u0026lt;message\u0026gt;指定检验失败的提示信息\u0026lt;/message\u0026gt; \u0026lt;/field-validator\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/validators\u0026gt;  必填字符串检验  \u0026lt;validators\u0026gt; \u0026lt;field name=\u0026quot;username\u0026quot;\u0026gt; \u0026lt;field-validator type=\u0026quot;requiredstring\u0026quot;\u0026gt; \u0026lt;param name=\u0026quot;trim\u0026quot;\u0026gt;true\u0026lt;/param\u0026gt; \u0026lt;message\u0026gt;指定检验失败的提示信息\u0026lt;/message\u0026gt; \u0026lt;/field-validator\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/validators\u0026gt;  整数检验器/浮点检验  \u0026lt;validators\u0026gt; \u0026lt;field name=\u0026quot;age\u0026quot;\u0026gt; \u0026lt;field-validator type=\u0026quot;int\u0026quot;\u0026gt; \u0026lt;param name=\u0026quot;min\u0026quot;\u0026gt;1\u0026lt;/param\u0026gt; \u0026lt;param name=\u0026quot;max\u0026quot;\u0026gt;150\u0026lt;/param\u0026gt; \u0026lt;message\u0026gt;年纪必须在1到150之间\u0026lt;/message\u0026gt; \u0026lt;/field-validator\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/validators\u0026gt;  日期检验  \u0026lt;validators\u0026gt; \u0026lt;field name=\u0026quot;birth\u0026quot;\u0026gt; \u0026lt;field-validator type=\u0026quot;date\u0026quot;\u0026gt; \u0026lt;param name=\u0026quot;min\u0026quot;\u0026gt;1900-01-01\u0026lt;/param\u0026gt; \u0026lt;param name=\u0026quot;max\u0026quot;\u0026gt;2050-02-21\u0026lt;/param\u0026gt; \u0026lt;message key=\u0026quot;birth.range\u0026quot;/\u0026gt; \u0026lt;/field-validator\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/validators\u0026gt;  字段表达式检验器(要求指定字段满足一个逻辑表达式)  \u0026lt;validators\u0026gt; \u0026lt;field name=\u0026quot;re_pass\u0026quot;\u0026gt; \u0026lt;field-validator type=\u0026quot;fieldexpression\u0026quot;\u0026gt; \u0026lt;!--指定逻辑表达式 --\u0026gt; \u0026lt;param name=\u0026quot;expression\u0026quot;\u0026gt; (pass eq re_pass)\u0026lt;/param\u0026gt; \u0026lt;message\u0026gt;密码必须和确认密码相等\u0026lt;/message\u0026gt; \u0026lt;/field-validator\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/validators\u0026gt;  邮件地址校验  \u0026lt;validators\u0026gt; \u0026lt;field name=\u0026quot;email\u0026quot;\u0026gt; \u0026lt;field-validator type=\u0026quot;email\u0026quot;\u0026gt; \u0026lt;message\u0026gt;你的电子邮件地址必须是一个有效的电邮地址\u0026lt;/message\u0026gt; \u0026lt;/field-validator\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/validators\u0026gt;  网址检验  \u0026lt;validators\u0026gt; \u0026lt;field name=\u0026quot;url\u0026quot;\u0026gt; \u0026lt;field-validator type=\u0026quot;url\u0026quot;\u0026gt; \u0026lt;message\u0026gt;你的主页地址必须是一个有效的网址\u0026lt;/message\u0026gt; \u0026lt;/field-validator\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/validators\u0026gt;  字符串长度检验  \u0026lt;validators\u0026gt; \u0026lt;field name=\u0026quot;user\u0026quot;\u0026gt; \u0026lt;field-validator type=\u0026quot;stringlength\u0026quot;\u0026gt; \u0026lt;param name=\u0026quot;minlength\u0026quot;\u0026gt;4\u0026lt;/param\u0026gt; \u0026lt;param name=\u0026quot;maxlength\u0026quot;\u0026gt;20\u0026lt;/param\u0026gt; \u0026lt;message\u0026gt;你的用户名长度必须在4到20之间\u0026lt;/message\u0026gt; \u0026lt;/field-validator\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/validators\u0026gt;  正则表达式检验  \u0026lt;validators\u0026gt; \u0026lt;field name=\u0026quot;user\u0026quot;\u0026gt; \u0026lt;field-validator type=\u0026quot;regex\u0026quot;\u0026gt; \u0026lt;param name=\u0026quot;regex\u0026quot;\u0026gt;\u0026lt;![CDATA[(\\w{4,25})]]\u0026gt;\u0026lt;/param\u0026gt; \u0026lt;message\u0026gt;您输入的用户名只能是字母和数组，且长度必须在4到25之间\u0026lt;/message\u0026gt; \u0026lt;/field-validator\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/validators  　b) 对指定方法进行校验\n　取名更改为ActionClassName-ActionName-validation.xml\n注意\n 当action同时提供了两个校验方法，则按照“所有方法”，“指定方法”的顺序汇总后执行；如果后面的文件包含前面文件的方法发生冲突，则只是用后面文件中的校验规则. 当action继承了另外一个action，父类action的校验文件会先被搜索到.  15、国际化 准备资源文件，资源文件的命名格式如下：\nbaseName_language_country.propeties baseName_language.propeties baseName.propeties  其中baseName是资源文件的基本名，可以自定义，但language和country必须是java支持的语言和国家.\n 中国：baseName_zh_CN.properties 美国：baseName_en_US.properties  如果没有使用开发工具，对于中文的属性文件，应该使用JDK提供的native2ascii命令把文件转换为Unicode编码的文件. 命令使用如下： native2ascii 源文件.properties 目标文件.properties\n15.1、配置全局资源与输出国际化信息 当准备好资源文件之后，可以在struts.xml中通过struts.custom.i18n.resources常量把资源文件定义为全局变量：\n\u0026lt;constant name=\u0026quot;struts.custom.i18n.resources\u0026quot; value=\u0026quot;baseName\u0026quot;/ \u0026gt;  其中baseName为资源的基本名. 之后就可以在页面或者action中访问国际化信息：\n 在JSP页面中使用\u0026lt;s:text name=\u0026quot;\u0026quot;/\u0026gt;标签输出国际化信息；\u0026lt;s:text name=\u0026quot;user\u0026quot;/\u0026gt;,name为资源文件中的Key. 在Action类中，可以继承ActionSupport，使用getText()方法得到国际化信息，该方法的第一个参数用于指定资源文件中的Key. 在表单标签中，通过Key属性指定资源文件中的Key，如：  \u0026lt;s:textfield name=\u0026quot;realname\u0026quot; key=\u0026quot;use\u0026quot;/\u0026gt;  输出带占位符的国际化信息 资源文件中的内容如下： welcome={0},你好{1}\n15.2、JSP页面中输出占位符的国际化信息 \u0026lt;s:text name=\u0026quot;welcome\u0026quot;\u0026gt; \u0026lt;s:param\u0026gt;熊大\u0026lt;/s:param\u0026gt; \u0026lt;s:param\u0026gt;学习\u0026lt;/s:param\u0026gt; \u0026lt;s:text/\u0026gt;  　在Action类中获取带占位符的国际化信息，可以使用getText(String Key，String[] args)或者getText(String Key，List args)方法\n15.3、包范围资源文件 　在一个大型应用中，整个应用有大量的内容需要实现国际化，如果把国际化的内容放置在全局资源属性文件中，显然会导致资源文件变的庞大、臃肿、不便于维护，支个时候可以针对不同末班，使用包范围来组织国际化文件.\n方法：在java的包下放置package_language_country.properties资源文件，package为固定写法，处于该包及子包下的action都可以访问该资源，当查到指定Key的消息时，系统会先从package资源文件查找，当不存在对应的Key时，才会从常量struts.custom.i18n.resources指定的资源文件中寻找.\n15.4、Action范围资源文件 　在Action类所在的路径，放置ActionClassName_languaage_country.properties资源文件，ActionClassName为action类的简单名称；当指定key的消息时，系统会先从ActionClassName_languaage_country.properties资源文件中查找.\n15.5、JSP中直接访问某个资源文件 struts2提供了\u0026lt;s:i18n\u0026gt;标签，使用\u0026lt;s:i18n\u0026gt;标签可以在类路径下直接从某个资源文件中获取国际化数据，无需任何配置：\n\u0026lt;s:i18n name=\u0026quot;realname\u0026quot;\u0026gt; \u0026lt;s:text name=\u0026quot;realname\u0026quot;/\u0026gt; \u0026lt;s:i18n\u0026gt;  realname为要访问的资源文件的基本名\n如果要访问的资源文件在类路径的某个包下，可以访问：\n\u0026lt;s:i18n name=\u0026quot;com/haibao/action/package\u0026quot;\u0026gt; \u0026lt;s:text name=\u0026quot;realname\u0026quot;\u0026gt; \u0026lt;s:param\u0026gt;熊大\u0026lt;/s:param\u0026gt; \u0026lt;/s:text/\u0026gt; \u0026lt;s:i18n\u0026gt;  上面访问com.haibao.action包下基本名为package的资源文件.\n16、OGNL表达式语言 　OGNL是Object Graphic Navigation Language（对象图导航语言）的缩写，是一个开源的项目. Struts2框架采用OGNL作为默认的表达式语言.\n相对于EL表达式，OGNL提供了：\n 支持对象方法调用：如xxx.sayHello()； 支持类静态方法调用和值访问，表达式的格式为@[类全名（包括路径）]@[方法名|值名] 例如：@java.lang.String@format('foo %s'，bar) 或者 @com.haibao.Constant@APP_NAME 操作集合对象.  　Ognl有一个上下文（Context）概念，它实现了了java.utils.Map接口，Struts2中说明：\n 上下文（Context）的实现为ActionContext. 当Struts2接受一个请求时，会迅速创建ActionContext，ValueStack，action. 然后把action存进ValueStack，所以action的实例变量可以被OGNL访问. 访问上下文（Context）中的对象需要使用#符号标注命名空间. 如#application、#session. 如：#application['userName']==#application.userName//获得application中userName值.  （#session对象、#request对象、#paramete对象、attr对象—按照page—request—session—application顺序访问其属性）. OGNL设定了一个跟对象（root）对象，在Struts2中根对象就是ValueStack（值栈）. 如果访问根对象中的属性，则可以省略#命名空间，直接访问该对象的属性即可. 如：${foo}//获得栈值中某个对象的foo属性.  注意：Struts2中，OGNL表达式需要配合Struts标签使用. 如：\u0026lt;s:property value=\u0026quot;name\u0026quot;\u0026gt;；使用EL表达式能够访问valueStack中对象的属性，原因是：Struts2对HTTPServletRequest作了进一步的封装.\n17、采用OGNL表达式创建List/Map集合对象 17.1、试用如下直接生成一个List对象： \u0026lt;s:set name=\u0026quot;list\u0026quot; value=\u0026quot;{'zhangsan','lisi','wangwu'}\u0026quot;/\u0026gt; \u0026lt;s:iterator value=\u0026quot;#list\u0026quot;\u0026gt;\u0026lt;!-- 迭代器 --\u0026gt; \u0026lt;s:property/\u0026gt;\u0026lt;br\u0026gt; \u0026lt;/s:iterator\u0026gt;  Set标签用于将某个值放入指定范围\n scope：指定变量被放置的范围，该属性可以接受application、session、request、page或action. 如果没有设置该属性，则默认放置在OGNL Context中. value：赋给变量的值，如果没有设置该属性，则将ValueStack栈顶的值赋值给变量.  生成一个Map对象：(Key\u0026ndash;Value)\n\u0026lt;s:set name=\u0026quot;foobar\u0026quot; value=\u0026quot;#{'k1': 'value1','k2':'value2'}\u0026quot;/\u0026gt; \u0026lt;s:iterator value=\u0026quot;# foobar \u0026quot;\u0026gt;\u0026lt;!-- 迭代器 --\u0026gt; \u0026lt;s:property value=\u0026quot;key\u0026quot;/\u0026gt;=\u0026lt;s:property value=\u0026quot;value\u0026quot;/\u0026gt;\u0026lt;br\u0026gt; \u0026lt;/s:iterator\u0026gt;  java 迭代方法：\nfor(Map.Entry\u0026lt;String,Integer\u0026gt;entry:maps.entrySet){ System.out.println(entry.getKey()+\u0026quot;=\u0026quot;+entry.getValue()); }  18、采用OGNL表达式判断对象是否存在于集合中 使用in和not in in表达式\n\u0026lt;s:if test=\u0026quot;foor\u0026quot; in {'foo', 'bar'}\u0026gt; 在 \u0026lt;/s:if\u0026gt; \u0026lt;s:else\u0026gt; 不在 \u0026lt;/s:else\u0026gt; not in 表达式 \u0026lt;s:if test=\u0026quot;foor\u0026quot; not in {'foo','bar'}\u0026gt; 不在 \u0026lt;/s:if\u0026gt; \u0026lt;s:else\u0026gt; 在 \u0026lt;/s:else\u0026gt;  附加： 除了in和not in之外OGNL还允许使用某个规则获得集合对象的子集\n ?:获得所有符合逻辑的元素. ^:获得符合逻辑的第一个元素. $:获得符合逻辑的最后一个元素.  例如：\n\u0026lt;s:iterator value=\u0026quot;books.{?#this.price}35}\u0026quot;\t/\u0026gt;  19、常用标签 19.1、propert标签： 用于输出指定值：\n\u0026lt;s:set name=\u0026quot;name\u0026quot; value=\u0026quot;kk\u0026quot;/\u0026gt; \u0026lt;s:property value=\u0026quot;#name\u0026quot;/\u0026gt;   default:可选属性，如果需要输出指定的属性值为null，则显示该属性指定的值. value：可选属性，指定需要输出的属性值，如果没有指定该属性，则默认输出ValueStack栈顶的值. escape：可选属性，指定是否格式化HTML代码. id：可选属性，指定还元素的标识.  19.2、iterator标签 iterator标签用于对集合进行迭代，治理的集合包含List、Set和数组\n\u0026lt;s:set name=\u0026quot;list\u0026quot; value=\u0026quot;{'foo','bar'}\u0026quot;/\u0026gt; \u0026lt;s:iterator value=\u0026quot;#list\u0026quot; status=\u0026quot;st\u0026quot;\u0026gt; \u0026lt;s:color=\u0026lt;s:if test=\u0026quot;#st.odd\u0026quot;\u0026gt;red\u0026lt;/s:if\u0026gt;\u0026lt;s:else\u0026gt;blue\u0026lt;/s:else\u0026gt;\u0026gt; \u0026lt;s:property/\u0026gt;\u0026lt;/font\u0026gt;\u0026lt;br\u0026gt; \u0026lt;/s:iterator\u0026gt;   value:可选属性，指定被迭代的集合，如果没有设置该属性，则使用ValueStack栈顶的集合 id:可选属性，指定即合理元素的id. （过时） status：该属性指定迭代时的IteratorStatus实例. 该实例包含以下几个方法：  int getCount()，返回当前迭代了几个元素 int getIndex()，返回当前迭代元素的索引 boolean isEven()，返回当前被迭代元素的索引是否为偶数 boolean isOdd()，返回当前被迭代元素的索引是否为奇数 boolean isFirst()，返回当前被迭代元素的索引是否是第一个元素 boolean isLast()，返回当前被迭代元素的索引是否最后一个元素    19.3、url标签 \u0026lt;s:url value=\u0026quot;hellowoeld_add\u0026quot; namespace=\u0026quot;/test\u0026quot;\u0026gt;\u0026lt;s:param name=\u0026quot;person\u0026quot; value=\u0026quot;23\u0026quot;/\u0026gt;\u0026lt;/s:url\u0026gt;  生成类似如下路径： /struts/test/helloworld_add.adtion?persom=23 红色部分为内容路径\n当标签的属性作为字符串类型处理时，“%”符号的用途试计算OGNL表达式的值\n\u0026lt;s:set value=\u0026quot;myurl\u0026quot; value='\u0026quot;http://www.sohu.com\u0026quot;'/\u0026gt; \u0026lt;s:url value=\u0026quot;myurl\u0026quot;/\u0026gt;\u0026lt;/br\u0026gt; \u0026lt;s:url value=\u0026quot;%{#myurl}\u0026quot;/\u0026gt;  输出结果：\n# myurl http://www.sohu.com  19.4、表单标签：checkboxlist复选框 如果集合为list\n\u0026lt;s:checkboxlist name=\u0026quot;list\u0026quot; list=\u0026quot;{'Java','.Net','Ror','PHP'}\u0026quot; value=\u0026quot;{'Java','.Net'}\u0026quot;/\u0026gt;  生成如下html代码：\n\u0026lt;input type=\u0026quot;checkbox\u0026quot; name=\u0026quot;list\u0026quot; value=\u0026quot;Java\u0026quot; checked=\u0026quot;checked\u0026quot;/\u0026gt;\u0026lt;lable\u0026gt;Java\u0026lt;/lable\u0026gt; \u0026lt;input type=\u0026quot;checkbox\u0026quot; name=\u0026quot;list\u0026quot; value=\u0026quot;.Net\u0026quot; checked=\u0026quot;checked\u0026quot;/\u0026gt;\u0026lt;lable\u0026gt;.Net\u0026lt;/lable\u0026gt; \u0026lt;input type=\u0026quot;checkbox\u0026quot; name=\u0026quot;list\u0026quot; value=\u0026quot; Ror\u0026quot;/\u0026gt;\u0026lt;lable\u0026gt;Ror\u0026lt;/lable\u0026gt; \u0026lt;input type=\u0026quot;checkbox\u0026quot; name=\u0026quot;list\u0026quot; value=\u0026quot; PHP\u0026quot;/\u0026gt;\u0026lt;lable\u0026gt;PHP\u0026lt;/lable\u0026gt;  如果集合为Map\n\u0026lt;s:checkboxlist name=\u0026quot;map\u0026quot; list=\u0026quot;#{1:'Java',2:'.Net',3:'Ror',4:'PHP'}\u0026quot; listKey=\u0026quot;key\u0026quot; listValue=\u0026quot;value\u0026quot; value=\u0026quot;{1,2,3}\u0026quot;/\u0026gt;  生成如下html代码：\n\u0026lt;input type=\u0026quot;checkbox\u0026quot; name=\u0026quot;map\u0026quot; value=\u0026quot;1\u0026quot; checked=\u0026quot;checked\u0026quot;/\u0026gt;\u0026lt;lable\u0026gt;Java\u0026lt;/lable\u0026gt; \u0026lt;input type=\u0026quot;checkbox\u0026quot; name=\u0026quot;map\u0026quot; value=\u0026quot;2\u0026quot; checked=\u0026quot;checked\u0026quot;/\u0026gt;\u0026lt;lable\u0026gt;.Net\u0026lt;/lable\u0026gt; \u0026lt;input type=\u0026quot;checkbox\u0026quot; name=\u0026quot;map\u0026quot; value=\u0026quot;3\u0026quot; checked=\u0026quot;checked\u0026quot;/\u0026gt;\u0026lt;lable\u0026gt;Ror\u0026lt;/lable\u0026gt; \u0026lt;input type=\u0026quot;checkbox\u0026quot; name=\u0026quot;map\u0026quot; value=\u0026quot;4\u0026quot;/\u0026gt;\u0026lt;lable\u0026gt;PHP\u0026lt;/lable\u0026gt;  如果集合里存放的是javabean\n\u0026lt;% Person p1 = new Person(1,\u0026quot;第一个\u0026quot;); Person p1 = new Person(2,\u0026quot;第一个\u0026quot;); List\u0026lt;Person\u0026gt; list = new ArrayList\u0026lt;Person\u0026gt;(); list.add(p1); list.add(p2); request.setAttribute(\u0026quot;person\u0026quot;, list); %\u0026gt; \u0026lt;s:checkboxlist list=\u0026quot;#request.persons\u0026quot; listKey=\u0026quot;personid\u0026quot; listValue=\u0026quot;name\u0026quot;\u0026gt;\u0026lt;/s:checkboxlist\u0026gt;  personid和name为Person的属性 生成如下代码：\n\u0026lt;input type=\u0026quot;checkbox\u0026quot; name=\u0026quot;beans\u0026quot; value=\u0026quot;1\u0026quot;/\u0026gt;\u0026lt;lable\u0026gt;第一个\u0026lt;/lable\u0026gt; \u0026lt;input type=\u0026quot;checkbox\u0026quot; name=\u0026quot;beans\u0026quot; value=\u0026quot;2\u0026quot;/\u0026gt;\u0026lt;lable\u0026gt;第二个\u0026lt;/lable\u0026gt;  19.5、表单标签：radio单选框 如果集合为list\n\u0026lt;s:radio name=\u0026quot;list\u0026quot; list=\u0026quot;{'Java','.Net','Ror','PHP'}\u0026quot; value=\u0026quot;'Java'\u0026quot;/\u0026gt;  生成如下html代码：\n\u0026lt;input type=\u0026quot;radio\u0026quot; name=\u0026quot;list\u0026quot; value=\u0026quot;Java\u0026quot; checked=\u0026quot;checked\u0026quot;/\u0026gt;\u0026lt;lable\u0026gt;Java\u0026lt;/lable\u0026gt; \u0026lt;input type=\u0026quot;radio\u0026quot; name=\u0026quot;list\u0026quot; value=\u0026quot;.Net\u0026quot;/\u0026gt; \u0026lt;input type=\u0026quot;radio\u0026quot; name=\u0026quot;list\u0026quot; value=\u0026quot;Ror\u0026quot;/\u0026gt; \u0026lt;input type=\u0026quot;radio\u0026quot; name=\u0026quot;list\u0026quot; value=\u0026quot;PHP\u0026quot;/\u0026gt;  如果集合为Map\n\u0026lt;s:radio name=\u0026quot;map\u0026quot; list=\u0026quot;#{1:'Java',2:'.Net'3:,'Ror',4:'PHP'}\u0026quot; listKey=\u0026quot;key\u0026quot; listValue=\u0026quot;value\u0026quot; value=\u0026quot;1\u0026quot;/\u0026gt;  生成如下html代码：\n\u0026lt;input type=\u0026quot;radio\u0026quot; name=\u0026quot;map\u0026quot; value=\u0026quot;1\u0026quot; checked=\u0026quot;checked\u0026quot;/\u0026gt;\u0026lt;lable\u0026gt;Java\u0026lt;/lable\u0026gt; \u0026lt;input type=\u0026quot;radio\u0026quot; name=\u0026quot;map\u0026quot; value=\u0026quot;2\u0026quot;/\u0026gt;\u0026lt;lable\u0026gt;.Net\u0026lt;/lable\u0026gt; \u0026lt;input type=\u0026quot;radio\u0026quot; name=\u0026quot;map\u0026quot; value=\u0026quot;3\u0026quot;/\u0026gt;\u0026lt;lable\u0026gt;Ror\u0026lt;/lable\u0026gt; \u0026lt;input type=\u0026quot;radio\u0026quot; name=\u0026quot;map\u0026quot; value=\u0026quot;4\u0026quot;/\u0026gt;\u0026lt;lable\u0026gt;PHP\u0026lt;/lable\u0026gt;  如果集合里存放的是javabean\n\u0026lt;% Person p1 = new Person(1,\u0026quot;第一个\u0026quot;); Person p1 = new Person(2,\u0026quot;第一个\u0026quot;); List\u0026lt;Person\u0026gt; list = new ArrayList\u0026lt;Person\u0026gt;(); list.add(p1); list.add(p2); request.setAttribute(\u0026quot;person\u0026quot;, list); %\u0026gt; \u0026lt;s:radio name=\u0026quot;beans\u0026quot; list=\u0026quot;#request.persons\u0026quot; listKey=\u0026quot;personid\u0026quot; listValue=\u0026quot;name\u0026quot;/\u0026gt;  personid和name为Person的属性 生成如下代码：\n\u0026lt;input type=\u0026quot;radio\u0026quot; name=\u0026quot;beans\u0026quot; value=\u0026quot;1\u0026quot;/\u0026gt;\u0026lt;lable\u0026gt;第一个\u0026lt;/lable\u0026gt; \u0026lt;input type=\u0026quot;radio\u0026quot; name=\u0026quot;beans\u0026quot; value=\u0026quot;2\u0026quot;/\u0026gt;\u0026lt;lable\u0026gt;第二个\u0026lt;/lable\u0026gt;  19.6、表单标签select下拉选择框 \u0026lt;s:select name=\u0026quot;list\u0026quot; list=\u0026quot;{'Java','.Net'}\u0026quot; value=\u0026quot;'Java'\u0026quot;/\u0026gt;  生成如下html代码：\n\u0026lt;s:select name=\u0026quot;list\u0026quot; id=\u0026quot;list\u0026quot;\u0026gt; \u0026lt;option value=\u0026quot;Java\u0026quot; selected=\u0026quot;selected\u0026quot;\u0026gt;Java\u0026lt;option/\u0026gt; \u0026lt;option value=\u0026quot;.Net\u0026quot;\u0026gt;.Net \u0026lt;option/\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;s:select name=\u0026quot;map\u0026quot; list=\u0026quot;#{1:'Java',2:'.Net'3:,'Ror',4:'PHP'}\u0026quot; listKey=\u0026quot;key\u0026quot; listValue=\u0026quot;value\u0026quot; value=\u0026quot;1\u0026quot;/\u0026gt;  生成如下html代码：\n\u0026lt;s:select name=\u0026quot;list\u0026quot; id=\u0026quot;list\u0026quot;\u0026gt; \u0026lt;option value=\u0026quot;1\u0026quot; selected=\u0026quot;selected\u0026quot;\u0026gt;Java\u0026lt;option/\u0026gt; \u0026lt;option value=\u0026quot;2\u0026quot;\u0026gt;.Net\u0026lt;option/\u0026gt; \u0026lt;/select\u0026gt;  20、\u0026lt;s:token/\u0026gt;标签放置重复提交 \u0026lt;s:token/\u0026gt;标签放置重复提交用法如下： 第一步：在表单中加入\u0026lt;s:token/\u0026gt;\n\u0026lt;s:form action=\u0026quot;Action_execute()\u0026quot; method=\u0026quot;post\u0026quot; \u0026gt; 姓名\u0026lt;s:textfield name=\u0026quot;name\u0026quot;/\u0026gt;\u0026lt;s:token/\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;发送\u0026quot;/\u0026gt; \u0026lt;/s:form\u0026gt;  第二步：\n\u0026lt;action name=\u0026quot;Action_*\u0026quot; class=\u0026quot;com.haibao.action.XMLvalidate\u0026quot; method=\u0026quot;{1}\u0026quot;\u0026gt; \u0026lt;interceptor-ref name=\u0026quot;defaultStack\u0026quot;/\u0026gt; \u0026lt;interceptor-ref name=\u0026quot;token\u0026quot;/\u0026gt; \u0026lt;result name=\u0026quot;ivalid.token\u0026quot;\u0026gt;/message.jsp\u0026lt;/result\u0026gt; \u0026lt;result name=\u0026quot;success\u0026quot;\u0026gt;/WEB-INF/page/message.jsp\u0026lt;/result\u0026gt; \u0026lt;/action\u0026gt;  以上配置加入了“token”拦截器和“ivalid.token”结果，因为“token”拦截器在会话的token与请求的token不一致时，将会直接返回“ivalid.token”结果.\n","date":1611878400,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1611878400,"objectID":"97fdddcd9bf62e2f6e54ff9f344cbe06","permalink":"https://CoMath21.github.io/post/1-struts2/","publishdate":"2021-01-29T00:00:00Z","relpermalink":"/post/1-struts2/","section":"post","summary":"具体介绍Strust2的相关内容.","tags":["编程语言","Java","Struts2"],"title":"Struts2学习笔记","type":"post"},{"authors":["Xin态好先生","CoMath"],"categories":["学习笔记","编程语言"],"content":"　对于这一组电影数据，如果我们想runtime的分布情况.\n# coding=utf-8 import pandas as pd from matplotlib import pyplot as plt file_path = \u0026quot;./IMDB-Movie-Data.csv\u0026quot; df = pd.read_csv(file_path) # print(temp_list.tolist()) # nums = set([i for j in temp_list for i in j]) # print(len(nums)) time_list = df[\u0026quot;Runtime (Minutes)\u0026quot;].values max_time = time_list.max() min_time = time_list.min() dis = (max_time - min_time)//5 plt.figure(figsize=(20,8),dpi=80) plt.hist(time_list,dis) plt.xticks(range(min_time,max_time,5)) plt.show()  对于这一组电影数据，如果我们希望统计电影分类(genre)的情况，应该如何处理数据？\n思路：重新构造一个全为0的数组，列名为分类，如果某一条数据中分类出现过，就让0变为1.\n# coding=utf-8 import pandas as pd from matplotlib import pyplot as plt import numpy as np file_path = \u0026quot;./IMDB-Movie-Data.csv\u0026quot; # 读取CSV文件 df = pd.read_csv(file_path) print(df[\u0026quot;Genre\u0026quot;].head(3)) # 统计分类的列表 temp_list = df[\u0026quot;Genre\u0026quot;].str.split(\u0026quot;,\u0026quot;).tolist() #[[],[],[]] genre_list = list(set([i for j in temp_list for i in j])) # 等价于 genre_list = [] # for i in temp_genre_list: # genre_list.extend(i) # genre_list = list(set(genre_list)) # 构造全为0的数组 zeros_df = pd.DataFrame(np.zeros((df.shape[0],len(genre_list))),columns=genre_list) # 给每个电影出现分类的位置赋值1 for i in range(df.shape[0]): #zeros_df.loc[0,[\u0026quot;Sci-fi\u0026quot;,\u0026quot;Mucical\u0026quot;]] = 1 zeros_df.loc[i,temp_list[i]] = 1 # 统计每个分类的电影的数量和 genre_count = zeros_df.sum(axis=0) # 排序 genre_count = genre_count.sort_values() _x = genre_count.index _y = genre_count.values #画图 plt.figure(figsize=(20,8),dpi=80) plt.bar(range(len(_x)),_y,width=0.4,color=\u0026quot;orange\u0026quot;) plt.xticks(range(len(_x)),_x) plt.show()  数据合并之join 　join:默认情况下他是把行索引相同的数据合并到一起. 数据合并之merge 　merge:按照指定的列把数据按照一定的方式合并到一起\nmerge(left, right, how='inner', on=None, left_on=None, right_on=None, left_index=False, right_index=False, sort=False, suffixes=('_x', '_y'), copy=True, indicator=False, validate=None) import pandas as pd df1=pd.DataFrame({'key':['a','b','a','b','b'],'value1':range(5)}) df2=pd.DataFrame({'key':['a','c','c','c','c'],'value2':range(5)}) display(df1,df2,pd.merge(df1,df2))   默认的合并方式inner，交集; merge outer，并集，NaN补全; merge left，左边为准，NaN补全; merge right，右边为准，NaN补全.  分组和聚合 　在pandas中类似的分组的操作有很简单的方式来完成\ngrouped = df.groupby(by=\u0026quot;columns_name\u0026quot;)  grouped是一个DataFrameGroupBy对象，是可迭代的;grouped中的每一个元素是一个元组，元组里面是（索引(分组的值)，分组之后的DataFrame）.\n那么，分组之后的每个DataFrame的长度？ 长度是一个思路，但更多的方法(聚合方法)来解决这个问题. DataFrameGroupBy对象有很多经过优化的方法. 如果需要对国家和省份进行分组统计\ngrouped = df.groupby(by=[df[\u0026quot;Country\u0026quot;],df[\u0026quot;State/Province\u0026quot;]])  很多时候我们只希望对获取分组之后的某一部分数据，或者说我们只希望对某几列数据进行分组，这个时候我们应该怎么办呢？ 获取分组之后的某一部分数据：\ndf.groupby(by=[\u0026quot;Country\u0026quot;,\u0026quot;State/Province\u0026quot;])[\u0026quot;Country\u0026quot;].count()  对某几列数据进行分组：\ndf[\u0026quot;Country\u0026quot;].groupby(by=[df[\u0026quot;Country\u0026quot;],df[\u0026quot;State/Province\u0026quot;]]).count()  观察结果，由于只选择了一列数据，所以结果是一个Series类型.\n如果我想返回一个DataFrame类型呢？\nt1 = df[[\u0026quot;Country\u0026quot;]].groupby(by=[df[\u0026quot;Country\u0026quot;],df[\u0026quot;State/Province\u0026quot;]]).count() t2 = df.groupby(by=[\u0026quot;Country\u0026quot;,\u0026quot;State/Province\u0026quot;])[[\u0026quot;Country\u0026quot;]].count()  以上的两条命令结果一样，和之前的结果的区别在于当前返回的是一个DataFrame类型.\n索引和复合索引 简单的索引操作：  获取index：df.index 指定index ：df.index = ['x','y'] 重新设置index : df.reindex(list(\u0026quot;abcedf\u0026quot;)) 指定某一列作为index ：df.set_index(\u0026quot;Country\u0026quot;,drop=False) 返回index的唯一值：df.set_index(\u0026quot;Country\u0026quot;).index.unique()  　假设a为一个DataFrame,那么当a.set_index([\u0026quot;c\u0026quot;,\u0026quot;d\u0026quot;])即设置两个索引的时候是什么样子的结果呢？\na = pd.DataFrame({'a': range(7),'b': range(7, 0, -1),'c': ['one','one','one','two','two','two', 'two'],'d': list(\u0026quot;hjklmno\u0026quot;)})  Series复合索引 DataFrame复合索引 例.现在有2015到2017年25万条911的紧急电话的数据，请统计出出这些数据中不同类型的紧急情况的次数.\nimport pandas as pd import numpy as np from matplotlib import pyplot as plt df = pd.read_csv(\u0026quot;./911.csv\u0026quot;) # print(df.info()) temp_list = df[\u0026quot;title\u0026quot;].str.split(\u0026quot;:\u0026quot;).tolist() cate_list = [i[0] for i in temp_list] cate_set_list = list(set(cate_list)) df[\u0026quot;type\u0026quot;] = pd.DataFrame(np.array(cate_list).reshape((df.shape[0],1))) # print(df.head()) cate_zeros = pd.DataFrame(np.zeros((df.shape[0],len(cate_set_list))),columns=cate_set_list) for cate in cate_set_list: cate_zeros[cate][df[\u0026quot;type\u0026quot;].str.contains(cate)] = 1 zeros_sum = cate_zeros.sum(axis=0) sum_values = zeros_sum.values plt.figure(figsize=(8, 6),dpi=80) plt.bar(cate_set_list,sum_values,color=\u0026quot;orange\u0026quot;,width=0.4) plt.show()  统计出不同月份不同类型紧急电话的次数的变化情况，应该怎么做可以按照上面的方法将时间戳按照右边“-”进行切割，然后将前面的字符串定义为原数组的最后一列，在进行其他操作. 也可以使用pandas的时间序列.\npandas中的时间序列 　不管在什么行业，时间序列都是一种非常重要的数据形式，很多统计数据以及数据的规律也都和时间序列有着非常重要的联系,而且在pandas中处理时间序列是非常简单的生成一段时间范围.\npd.date_range(start=None, end=None, periods=None, freq='D')  start和end以及freq配合能够生成start和end范围内以频率freq的一组时间索引. start和periods以及freq配合能够生成从start开始的频率为freq的periods个时间索引. 在DataFrame中使用时间序列 index=pd.date_range(\u0026quot;20170101\u0026quot;,periods=10) df = pd.DataFrame(np.random.rand(10),index=index)  回到最开始的911数据的案例中，我们可以使用pandas提供的方法把时间字符串转化为时间序列.\ndf[\u0026quot;timeStamp\u0026quot;] = pd.to_datetime(df[\u0026quot;timeStamp\u0026quot;],format=\u0026quot;\u0026quot;)  format参数大部分情况下可以不用写，但是对于pandas无法格式化的时间字符串，我们可以使用该参数，比如包含中文.\npandas重采样 　重采样：指的是将时间序列从一个频率转化为另一个频率进行处理的过程，将高频率数据转化为低频率数据为降采样，低频率转化为高频率为升采样.pandas提供了一个resample的方法来帮助我们实现频率转化. PeriodIndex 　之前所学习的DatetimeIndex可以理解为时间戳，那么现在我们要学习的PeriodIndex可以理解为时间段．\nperiods = pd.PeriodIndex(year=data[\u0026quot;year\u0026quot;],month=data[\u0026quot;month\u0026quot;],day=data[\u0026quot;day\u0026quot;],hour=data[\u0026quot;hour\u0026quot;],freq=\u0026quot;H\u0026quot;)  那么如果给这个时间段降采样呢？\ndata = df.set_index(periods).resample(\u0026quot;10D\u0026quot;).mean()  ","date":1611792000,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1611792000,"objectID":"25241c6db9aa838d1b87741feaee85e3","permalink":"https://CoMath21.github.io/post/0-python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%904/","publishdate":"2021-01-28T00:00:00Z","relpermalink":"/post/0-python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%904/","section":"post","summary":"Python数据分析之常用统计方法.","tags":["编程语言","Python","数据分析"],"title":"Python数据分析（四）","type":"post"},{"authors":["Xin态好先生","CoMath"],"categories":["学习笔记","编程语言"],"content":"","date":1611792000,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1611792000,"objectID":"9226e139b2d30f2cbf1e37cc4f3ba49e","permalink":"https://CoMath21.github.io/post/1-spring2.5/","publishdate":"2021-01-28T00:00:00Z","relpermalink":"/post/1-spring2.5/","section":"post","summary":"具体介绍Spring2.5的相关内容.","tags":["编程语言","Java","Spring"],"title":"Spring2.5学习笔记","type":"post"},{"authors":["Xin态好先生","CoMath"],"categories":["学习笔记","编程语言"],"content":"　Numpy能够帮助我们处理数值，pandas除了处理数值之外(基于numpy)，还能够帮助我们处理其他类型的数据.\npandas的常用数据类型 Series 一维，带标签数组 t = pd.Series(np.arange(10),index=list(string.ascoo_uppercase[:10]))  Series切片和索引 Series的索引和值 对于一个陌生的series类型，可以通过t.index获取其索引值 pandas读取外部数据：  直接使用pd. read_csv()即可. 如果待数据的数据没有列名，则需要补充，即在读取文件时给定参数names的值.  pd.read_csv(“’’,names=column_names)   column_names：指定类别名字,[\u0026lsquo;Sample code number\u0026rsquo;,\u0026lsquo;Clump Thickness\u0026rsquo;, \u0026lsquo;Uniformity of Cell Size\u0026rsquo;,\u0026lsquo;Uniformity of Cell Shape\u0026rsquo;,\u0026lsquo;Marginal Adhesion\u0026rsquo;, \u0026lsquo;Single Epithelial Cell Size\u0026rsquo;,\u0026lsquo;Bare Nuclei\u0026rsquo;,\u0026lsquo;Bland Chromatin\u0026rsquo;,\u0026lsquo;Normal Nucleoli\u0026rsquo;,\u0026lsquo;Mitoses\u0026rsquo;,\u0026lsquo;Class\u0026rsquo;] return:数据. replace(to_replace=’’,value=)：返回数据. dropna():返回数据. 注：读取文件只要是.CSV文件就可以使用load_csv()方法，即使文件地址是网站.  DataFrame 二维，Series容器 DataFrame对象既有行索引，又有列索引 行索引，表明不同行，横向索引，叫index，0轴，axis=0； 列索引，表名不同列，纵向索引，叫columns，1轴，axis=1． 和一个ndarray一样，通过ndim，shape，dtype了解这个ndarray的基本信息． 获得使用次数最高的前几个名字是什么？\nimport pandas as pd df = pd.read_csv(\u0026quot;./dogNames.csv\u0026quot;) # print(df.head()) # print(df.info()) # dataFrame 中排序的方法 df = df.sort_values(\u0026quot;Count_AnimalName\u0026quot;,ascending=False) print(df.head())  def sort_values(self, by, axis=0, ascending=True, inplace=False, kind='quicksort', na_position='last') # ascending：升序：True\t# 降序：False  问题：数据有10列，我想按照其中的第1，第3，第8列排序？\n# pandas取行或者列的注意点 # - 方括号写数组,表示取行,对行进行操作 # - 写字符串,表示的去列索引,对列进行操作 print(df[:20]) print(df[\u0026quot;Row_Labels\u0026quot;]) print(type(df[\u0026quot;Row_Labels\u0026quot;]))  还有更多的经过pandas优化过的选择方式：\n df.loc 通过标签索引行数据（行列的名字）  df.loc[“a”,”w”] # a行w列 df.loc[“a”,:] # a行 df.loc[:,”w”] # w列 df.loc[[“a”,”c”],:] # a，c行 df.loc[:,[“w”,”z”]] # w，z列 df.loc[[“a”,”c” ,[“w”,”z”]] # a,c行，w,z列 df.loc[[“a”:”c” ,[“w”,”z”]] # a到c行，w,z列  df.iloc 通过位置获取行数据（行列号-1）  df.iloc[1,:] # 第二行 df.iloc[:,2] # 第三列 df.iloc[:,[2,1]] # 第三列第二列 df.iloc[[0,2], [2,1]]\t# 第1,3行, 第3,2列  赋值更改数据的过程： 布尔索引 　找到所有的使用次数超过800的狗的名字. 找到所有的使用次数超过700并且名字的字符串的长度大于4的狗的名字 字符串方法 Pandas缺失数据的处理 数据缺失通常有两种情况： 　一种就是空，None等，在pandas是NaN(和np.nan一样);另一种是我们让其为0，蓝色框中对于NaN的数据，在numpy中我们是如何处理的？\n　在pandas中我们处理起来非常容易.\n判断数据是否为NaN：pd.isnull(df),pd.notnull(df)\n 处理方式1：删除NaN所在的行列dropna (axis=0, how=\u0026lsquo;any\u0026rsquo;, inplace=False)# 是否原地修改 处理方式2：填充数据，t.fillna(t.mean()),t.fiallna(t.median()),t.fillna(0) 处理为0的数据：t[t==0]=np.nan  当然并不是每次为0的数据都需要处理计算平均值等情况，nan是不参与计算的，但0会.\n数据变形：  处理重复数据  判断数据是否重复，duplicated() 去除重复数据，drop_dumplicates()，可指定列及如何保留数据   使用函数或map转化数据，通常根据字典进行数据转化  data = pd.DataFrame({'food': ['bacon', 'pulled pork', 'bacon', 'Pastrami', 'corned beef', 'Bacon', 'pastrami', 'honey ham', 'nova lox'], 'ounces': [4, 3, 12, 6, 7.5, 8, 3, 5, 6]})  # 添加一列，用于指定食物的来源 meat_to_animal = { 'bacon': 'pig', 'pulled pork': 'pig', 'pastrami': 'cow', 'corned beef': 'cow', 'honey ham': 'pig', 'nova lox': 'salmon' } # 使用map() lowercased = data['food'].str.lower() data['animal'] = lowercased.map(meat_to_animal)   替换值，replace() 离散化和分享操作，pd.cut()，返回Categorical对象  哑变量操作，pd.get_dummies() 向量化字符串操作  字符串列越苏中是否包含子字符串，ser_obj.str.contains() 字符串列切片操作，ser_obj.str[a:b]    ","date":1611705600,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1611705600,"objectID":"160ed39b47e3b45a7d11a8d243db6c3c","permalink":"https://CoMath21.github.io/post/0-python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%903/","publishdate":"2021-01-27T00:00:00Z","relpermalink":"/post/0-python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%903/","section":"post","summary":"Python数据分析之Pandas.","tags":["编程语言","Python","数据分析","Pandas"],"title":"Python数据分析（三）","type":"post"},{"authors":["Xin态好先生","CoMath"],"categories":["学习笔记","编程语言"],"content":"Numpy 　Numpy是一个在Python中做科学计算的基础库，重在数值计算，也是大部分PYTHON科学计算库的基础库，多用于在大型、多维数组上执行数值运算.\nNumpy简单创建数组 import numpy as np # 创建简单的列表 a = [1, 2, 3, 4]\t此处输出a的话是[1,2,3,4] # 将列表转换为数组 b = np.array(a)\t此处b输出的话是[1 2 3 4] np.array(a) = np.array(range(1,4)) = np.arange(1,4) np,arrange([start, ] stop[, step,], ftype=None) # 去小数 np.round(x,保留位数)  Numpy查看数组属性 数组元素个数：b.size\n数组形状：b.shape\n一维：列数(8,)；二维：行列(2, 4)；三维：块行列(2, 2, 4)\n重塑reshape：数组一个新的形状而不改变其数据.\n# 具有返回值的，不会改变原数组 numpy.reshape(a, newshape, order='C')\torder : {‘C’, ‘F’, ‘A’} # C:横着读横着写; E:竖着的竖着写; A:竖着度横着写  例.\na = np.array([[1,2,3], [4,5,6]]) print(a) [[1 2 3] [4 5 6]] print(np.reshape(a, (3,2))) [[1 2] [3 4] [5 6]]  数组维度：b.ndim\n数组元素类型：b.dtype\n快速创建N维数组的api函数\n#创建10行10列的数值为浮点1的矩阵 array_one = np.ones([10, 10]) #创建10行10列的数值为浮点0的矩阵 array_zero = np.zeros([10, 10]) #降到一维： b.flatten(order='C') # 把a降到一维，默认是按横的方向降order:{‘C’, ‘F’,‘A’,‘K’} b.flatten('F') # 按竖的方向降  轴(axis) 　在numpy中可以理解为方向,使用0,1,2\u0026hellip;数字表示,对于一个一维数组,只有一个0轴,对于2维数组(shape(2,2)),有0轴和1轴,对于三维数组(shape(2,2, 3)),有0,1,2轴. Numpy读取数据 （以后结合框架之类的读取文件大多数是从CSV文件中读取）\n　CSV（Comma-Separated Value,逗号分隔值文件）：由于csv便于展示,读取和写入,所以很多地方也是用csv的格式存储和传输中小型的数据,为了方便教学,我们会经常操作csv格式的文件,但是操作数据库中的数据也是很容易的实现的.\n方法\nnp.loadtxt(fname,dtype=np.float,delimiter=None,skiprows=0,usecols=None,unpack=False)  注意 其中添加的delimiter和dtype以及unpack效果.\n delimiter：指定边界符号是什么，不指定会导致每行数据为一个整体法人字符串而报错 dtype：默认情况下对于较大的数据将变为科学计数法的方式 upack：默认值是False(0)，默认情况下，有多少条数据就会有多少行；为True(1)的情况下，每一列的数据会组成一行，袁术数据有多少列，加载出来就会有多少行，相当于转置的效果. 其他转置方法：t.transpose()\tt.T\tt.swapaxes(1,0) # 1轴和1轴互换.  Numpy索引和切片 # 取行： T[行] # 取连续的多行： T [2:] # 取不连续的多行： T [ [2,8,10] ] = T [[2,10,3],:] 取第2行：T [1,:] 取第三行以后所有行：T [2:,:] #取列： T [:,0] #取连续的多列： T [:, 2 :] #取不连续的多列： T [:,[ 0,2]] #去行和列，取第3行，第四列的值： a = T [ 2, 3] print(type(a))\t# int #取多行和多列，取第3行到第五行，第2列到第4列的结果 #去的是行和列交叉点的位置 b = T [2:5,1:4] #取多个不相邻的点--选出来的结果是（0，0） （2，1） （2，3） c = T [[0,2,2],[0,1,3]]  Numpy中布尔索引 # numpy中三元运算符 np.where(condition, if True, if False)  Numpy中的clip(裁剪) numpy.clip(a, a_min, a_max, out=None)  [a_min, a_max] 里面的数被保留下来,外面的被截取为a_min或者a_max .\nout：可以把结果放置在此数组中.\n例如，指定间隔为[0，1]，则小于0的值赋值为0，并且大于1的值赋值为1.\n补充：int类型的情况下无法赋值为nan，所以需要将类型改为float.\nt.astype(float) t[x,y]=np.nan  数组的拼接： np.vstack((t1,t2))\t# 竖直拼接 np.hstack((t1,t2))\t# 水平拼接  数组的行列交换 Numpy更多好用的方法  获取最大值最小值的位置 np.argmax(t,axis=0) np.argmin(t,axis=1) 创建一个全0的数组: np.zeros((3,4)) 创建一个全1的数组:np.ones((3,4)) 创建一个对角线为1的正方形数组(方阵)：np.eye(3)  Numpy生成随机数 Numpy中的注意点copy和view  a=b 完全不复制，a和b相互影响 a = b[:],视图的操作，一种切片，会创建新的对象a，但是a的数据完全由b保管，他们两个的数据变化是一致的， a = b.copy(),复制，a和b互不影响  Numpy中的nan和inf（都是float类型） nan(NAN,Nan):not a number表示不是一个数字.\n什么时候numpy中会出现nan\n当我们读取本地的文件为float的时候，如果有缺失，就会出现nan． 　当做了一个不合适的计算的时候(比如无穷大(inf)减去无穷大)．\ninf(-inf,inf):infinity,inf表示正无穷，-inf表示负无穷\n什么时候回出现inf包括（-inf，+inf）\n比如一个数字除以0，（python中直接会报错，numpy中是一个inf或者-inf） Numpy中的nan的注意点 t.sum(axis=None) #求和 t.mean(a,axis=None) # 均值 受离群点的影响较大 np.median(t,axis=None) # 中值： t.max(axis=None) # 最大值： t.min(axis=None) # 最小值： np.ptp(t,axis=None) # 极值 即最大值和最小值只差 t.std(axis=None) # 标准差  ndarry缺失值填充均值 t中存在nan值，如何操作把其中的nan填充为每一列的均值\nt = array([[ 0., 1., 2., 3., 4., 5.], [ 6., 7., nan, 9., 10., 11.], [ 12., 13., 14., nan, 16., 17.], [ 18., 19., 20., 21., 22., 23.]]) def fill_ndarray(t1): #遍历每一列 for i in range(t1.shape[1]): temp_col = t1[:,i] #当前的一列 nan_num = np.count_nonzero(temp_col!=temp_col) if nan_num != 0: #不为0，说明当前这一列中有nan temp_not_nan_col = temp_col[temp_col==temp_col] #当前一列不为nan的array # 选中当前为nan的位置，把值赋值为不为nan的均值 temp_col[np.isnan(temp_col)] = temp_not_nan_col.mean() return t1 if __name__ == '__main__': t1 = np.arange(12).reshape((4, 3)).astype(\u0026quot;float\u0026quot;) t1[1, 1:] = np.nan print(t1) t1 = fill_ndarray(t1) print(t1)  输出结果\n[[ 0. 1. 2.]\t[[ 0. 1. 2.] [ 3. nan nan]\t[ 3. 6. 7.] [ 6. 7. 8.]\t[ 6. 7. 8.] [ 9. 10. 11.]]\t[ 9. 10. 11.]]  ","date":1611532800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1611532800,"objectID":"366acf95216fb391a3aaa0d6d31f7922","permalink":"https://CoMath21.github.io/post/0-python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%902/","publishdate":"2021-01-25T00:00:00Z","relpermalink":"/post/0-python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%902/","section":"post","summary":"Python数据分析之Numpy.","tags":["编程语言","Python","数据分析","Numpy"],"title":"Python数据分析（二）","type":"post"},{"authors":["Xin态好先生","CoMath"],"categories":["学习笔记","编程语言"],"content":"准备工作 环境安装（不是必要，只是为了能够更好的操作及维护） CONDA： conda类似于npm或maven的包管理工具，只是conda是针对于python的. 可以安装minconda或anaconda进行安装；Conda是一个包管理器；Anaconda是一个发行包.虽然Conda与Anaconda一起包装，但两者是具有不同目标的不同实体. CONDA安装（以Win64为例）: 可以到官网；也可以到国内清华镜像源进行下载镜像文件： 安装 ： 打开安装包，一路next 即可. 注意，勾选 添加环境变量 和 默认python3.6 作为Anaconda的语言. 安装成功后打开cmd命令输入\u0026quot;python\u0026quot;查看版本信息. 查看当前有哪些可以使用的python版本：conda search \u0026ndash;full -name python 安装python版本（安装的3.6的版本）：conda create \u0026ndash;name tensorflow python=3.6\nJupyter notebook jupyter notebook:一款编程/文档/笔记/展示软件. 启动命令:jupyter notebook （已经安装Anaconda/在conda环境下） Jupyter notebook好处  极其适合数据分析 支持多语言 分享便捷：支持以网页的形式分享，GitHub 中天然支持 Notebook 展示，也可以通过 nbviewer 分享你的文档. 当然也支持导出成 HTML、PDF、Markdown等多种格式的文档. 远程运行：在任何地点都可以通过网络链接远程服务器来实现运算. 交互式展现：不仅可以输出图片、视频、数学公式，甚至可以呈现一些互动的可视化内容，比如可以缩放的地图或者是可以旋转的三维模型. 这就需要交互式插件（Interactive widgets）来支持.  基础知识 matplotlib 最流行的Python底层绘图库，主要做数据可视化图表,名字取材于MATLAB，模仿MATLAB构建；能将数据进行可视化,更直观的呈现、使数据更加客观、更具说服力 matplotlib使用流程：\n 明确问题 选择图形的呈现方式 准备数据 绘图和图形完善  例. 假设一天中每隔两个小时(range(2,26,2))的气温(℃)分别是[15, 13, 14.5, 17, 20, 25, 26, 26, 27, 22, 18, 15].\n设置图片大小 fig = plt.figure(figsize=(10,6),dpi=80)  figure图形图标的意思，在这里指的是画的图；通过实例化一个figure并传递参数，能够在后台自动使用该figure实例；在图像模糊的时候可以传入dpi参数（每英寸上像素点的个数）\n保存到本地 　保存需要在绘制图形之后保存\nplt.show(\u0026quot;路径/名字.png\u0026quot;)  也可以保存为SVG这种矢量图的格式\n描述信息,比如x轴和y轴表示什么,这个图表示什么  plt.xlabel(\u0026quot;X轴\u0026quot;) plt.ylabel(\u0026quot;Y轴\u0026quot;) plt.title(\u0026quot;Title\u0026quot;) # 存在中文乱码问题  调整x或者y的刻度的间距  设置x轴的刻度（一个参数）  plt.xticks(x)  想要密集点可以设置：\n_xticks = [i/2 for I in range(4,49)] plt.xticks(_xticks) # 显得过于密集 plt.xticks(_xticks[::3]) # 每隔3取一个；只有列表的时候才能使用[ ]取步长   设置x轴的刻度（两个参数）  plt.xticks(x,_xticks_labels) _x = x # int类型 _xtick_labels = [\u0026quot;hello,{}\u0026quot;.format(i) for i in _x] plt.xticks(_x,_xtick_labels)  format函数: 格式化字符串的函数 str.format()，它增强了字符串格式化的功能. 基本语法是通过 {} 和 : ，来代替以前的%.\nformat 函数可以接受不限个参数，位置可以不按顺序.\n\u0026quot;{} {}\u0026quot;.format(\u0026quot;hello\u0026quot;, \u0026quot;world\u0026quot;) # 不设置指定位置，按默认顺序 'hello world'  format 函数可以接受不限个参数,位置也可以设置参数：\nprint(\u0026quot;网站名：{name}, 地址 {url}\u0026quot;.format(name=\u0026quot;百度\u0026quot;, url=\u0026quot;www.Baidu.com\u0026quot;))  改进：\n_x = list(x) # int类型 _xtick_labels = [\u0026quot;hello,{}\u0026quot;.format(i) for i in _x]\t# 取步长一样，数字和字符串一一对应，数据长度一样 plt.xticks(_x[::8],_xtick_labels[::8])  使用rotation参数旋转\nplt.xticks(_x[::8],_xtick_labels[::8],rotation=45)  中文情况处理： 　matplotlib默认不支持中文字符，因为默认的英文字体无法显示汉字\n如何修改matplotlib的默认字体?\n通过matplotlib.rc可以修改,具体方法参见源码(windows/linux) import matplotlib font = {'family': \u0026quot;simhei\u0026quot;,'size': '10'} # 黑体 matplotlib.rc(\u0026quot;font\u0026quot;,**font)  通过matplotlib 下的font_manager可以解决(windows/linux/mac)\n# 设置中文字体（指定的字体文件路径，然后在显示中文的地方添加fontproperties） my_font = font_manager.FontProperties(fname=\u0026quot;/System/Library/Fonts/PingFang.ttc\u0026quot;) plt.xticks(x[::5],_x_ticks[::5],rotation=90,fontproperties=my_font)  线条的样式(比如颜色,透明度等) plt.grid()\t# 绘制网格 plt.grid(alpha=0.6)\t# 绘制网格，并调整透明度  绘制风格及描述 　描述不同曲线含义：在plot()中添加参数label=\u0026quot;Name\u0026quot; 再添加语句：\nplt.legend(loc=0)/plt.legend(prop=my_font) # loc位置：0=best/upper left  常用统计图 　统计图是数据分析和数学建模最直接、最有效的可视化形式.这里只是简单说明在Python中不同的绘图命令.\n 折线图:以折线的上升或下降来表示统计数量的增减变化的统计图.  特点:能够显示数据的变化趋势，反映事物的变化情况(变化).   直方图:由一系列高度不等的纵向条纹或线段表示数据分布的情况. 一般用横轴表示数据范围，纵轴表示分布情况.  特点:绘制连续性的数据,展示一组或者多组数据的分布状况(统计).   条形图:排列在工作表的列或行中的数据可以绘制到条形图中.  特点:绘制连离散的数据,能够一眼看出各个数据的大小,比较数据之间的差别(统计).   散点图:用两组数据构成多个坐标点，考察坐标点的分布,判断两变量之间是否存在某种关联或总结坐标点的分布模式.  特点:判断变量之间是否存在数量关联趋势,展示离群点(分布规律).    绘制折线图：plt.plot(x,y) import numpy as np linear_data = np.arange(1, 9) quadratic_data = linear_data ** 2 plt.figure() plt.plot(linear_data, '-o', quadratic_data, '-o') # 注意，这里只指定了y轴数据，x轴的数据是matplotlib自动生成的 # 添加坐标轴标签及图例 plt.xlabel('x data') plt.ylabel('y data') plt.title('Line Chart Title') plt.legend(['legend1', 'legend2', 'legend3']) # 填充两个line间的区域plt.gca().fill_between(x,y1,y2,color,透明度) plt.gca().fill_between(range(len(linear_data)), linear_data, quadratic_data, facecolor='green', alpha=0.25)  注意：\n# 对于学术制图，可在标题中包含latex语法 ax = plt.gca() ax.set_title('Quadratic ($x^2$) vs. Linear ($x$)')  绘制散点图：plt.scatter(x,y) 假设通过爬虫你获取到了北京2016年3,10月份每天白天的最高气温(分别位于列表a,b),那么此时如何寻找出气温和随时间(天)变化的某种规律?\nfrom matplotlib import pyplot as plt import matplotlib # 设置字体样式 font = {'family': \u0026quot;simhei\u0026quot;, 'size':'10'} matplotlib.rc(\u0026quot;font\u0026quot;,**font) # 数据 y_3 = [11,17,16,11,12,11,12,6,6,7,8,9,12,15,14,17,18,21,16,17,20,14,15,15,15,19,21,22,22,22,23] y_10 = [26,26,28,19,21,17,16,19,18,20,20,19,22,23,17,20,21,20,22,15,11,15,5,13,17,10,11,13,12,13,6] # 3月，10月范围 x_3 = range(1,32) x_10 = range(50,81) # 合并横坐标 plt.figure(figsize=(14,8),dpi=80) # 绘制散点图 plt.scatter(x_3,y_3,label=\u0026quot;3月份\u0026quot;) plt.scatter(x_10,y_10,label=\u0026quot;10月份\u0026quot;) # 设置x轴 _x = list(x_3) + list(x_10) _xticks_labels = [\u0026quot;3月{}日\u0026quot;.format(i) for i in x_3] _xticks_labels += [\u0026quot;10月{}日\u0026quot;.format(i) for i in x_10] plt.xticks(_x[::3],_xticks_labels[::3],rotation=45) plt.legend(loc=\u0026quot;upper left\u0026quot;) # 显示设置 plt.xlabel(\u0026quot;月份\u0026quot;) plt.ylabel(\u0026quot;温度\u0026quot;) plt.title(\u0026quot;标题\u0026quot;) # 展示 plt.show()  绘制条形图/柱状图： plt.bar(x, y, width=0.2, color='orange') plt.bar(x, y, height=0.2, color='orange')  例.\nfrom matplotlib import pyplot as plt import matplotlib # 设置字体样式 font = {'family': \u0026quot;simhei\u0026quot;, 'size':'10'} matplotlib.rc(\u0026quot;font\u0026quot;,**font) a = [\u0026quot;战狼2\u0026quot;,\u0026quot;速度与激情8\u0026quot;,\u0026quot;功夫瑜伽\u0026quot;,\u0026quot;西游伏妖篇\u0026quot;,\u0026quot;变形金刚5：最后的骑士\u0026quot;,\u0026quot;摔跤吧！爸爸\u0026quot;,\u0026quot;加勒比海盗5：死无对证\u0026quot;,\u0026quot;金刚：骷髅岛\u0026quot;,\u0026quot;极限特工：终极回归\u0026quot;,\u0026quot;生化危机6：终章\u0026quot;,\u0026quot;乘风破浪\u0026quot;,\u0026quot;神偷奶爸3\u0026quot;,\u0026quot;智取威虎山\u0026quot;,\u0026quot;大闹天竺\u0026quot;,\u0026quot;金刚狼3：殊死一战\u0026quot;,\u0026quot;蜘蛛侠：英雄归来\u0026quot;,\u0026quot;悟空传\u0026quot;,\u0026quot;银河护卫队2\u0026quot;,\u0026quot;情圣\u0026quot;,\u0026quot;新木乃伊\u0026quot;] b = [56.01,26.94,17.53,16.49,15.45,12.96,11.8,11.61,11.28,11.12,10.49,10.3,8.75,7.55,7.32,6.99,6.88,6.86,6.58,6.23] plt.figure(figsize=(12,8),dpi=80) x = range(len(a)) plt.bar(x, b, width=0.2, color='orange') plt.xticks(x, a, rotation=45) plt.show()  发现字数长的名字错位,横向的条形图,将\nplt.bar(x, y, width=0.2, color='orange')  改成\nplt.bar(x, y, height=0.2, color='orange')  再适当调整其他参数. 例.假设你知道了列表a中电影分别在2017-09-14(b_14), 2017-09-15(b_15), 2017-09-16(b_16)三天的票房,为了展示列表中电影本身的票房以及同其他电影的数据对比情况,应该如何更加直观的呈现该数据?\nfrom matplotlib import pyplot as plt import matplotlib # 设置字体样式 font = {'family': \u0026quot;simhei\u0026quot;, 'size':'10'} matplotlib.rc(\u0026quot;font\u0026quot;,**font) a = [\u0026quot;猩球崛起3：终极之战\u0026quot;,\u0026quot;敦刻尔克\u0026quot;,\u0026quot;蜘蛛侠：英雄归来\u0026quot;,\u0026quot;战狼2\u0026quot;] b_16 = [15746,312,4497,319] b_15 = [12357,156,2045,168] b_14 = [2358,399,2358,362] bar_width = 0.2 plt.figure(figsize=(10,8),dpi=80) x_14 = list(range(len(a))) x_15 = [i+bar_width for i in x_14] x_16 = [i+bar_width for i in x_15] plt.bar(x_14, b_14, width=bar_width,label=\u0026quot;2017-09-14\u0026quot;) plt.bar(x_15, b_15, width=bar_width,label=\u0026quot;2017-09-15\u0026quot;) plt.bar(x_16, b_16, width=bar_width,label=\u0026quot;2017-09-16\u0026quot;) plt.xticks(x_15, a) plt.legend() plt.show()  堆叠柱状图\n# stack bar chart plt.figure() x_vals = list(range(len(linear_data))) plt.bar(x_vals, linear_data, width=0.3) plt.bar(x_vals, quadratic_data, width=0.3, bottom=linear_data)  绘制直方图 频数分布直方图 　假设你获取了250部电影的时长(列表a中),希望统计出这些电影时长的分布状态(比如时长为100分钟到120分钟电影的数量,出现的频率)等信息,你应该如何呈现这些数据?\nfrom matplotlib import pyplot as plt import matplotlib # 设置字体样式 font = {'family': \u0026quot;simhei\u0026quot;, 'size':'10'} matplotlib.rc(\u0026quot;font\u0026quot;,**font) a=[131, 98, 125, 131, 124, 139, 131, 117, 128, 108, 135, 138, 131, 102, 107, 114, 119, 128, 121, ...] # 计算组距 dis = 3 num_bins = (max(a)-min(a))//dis plt.figure(figsize=(12,8),dpi=80) plt.hist(a, num_bins) plt.xticks(range(min(a),max(a)+dis,dis)) plt.grid() plt.show()  频率分布直方图 plt.hist(a, num_bins,normed=1/True)  例. 在美国2004年人口普查发现有124 million的人在离家相对较远的地方工作. 根据他们从家到上班地点所需要的时间,通过抽样统计(最后一列)出了下表的数据,这些数据能够绘制成直方图么? 数据被统计后，组距不同（不能使用hist）\n解决办法：使用bar（条形图）在进行调整.\nfrom matplotlib import pyplot as plt import matplotlib # 设置字体样式 font = {'family': \u0026quot;simhei\u0026quot;, 'size':'10'} matplotlib.rc(\u0026quot;font\u0026quot;,**font) interval = [0,5,10,15,20,25,30,35,40,45,60,90] width = [5,5,5,5,5,5,5,5,5,15,30,60] quantity = [836,2737,3723,3926,3596,1438,3273,642,824,613,215,47] plt.figure(figsize=(14,8),dpi=80) # 默认宽度是0.8，为了是条形图连起来，令width=1 plt.bar(range(12), quantity, width=1) # 设置X轴的刻度——为了让起点从零开始，所以i-1 _x = [i-0.5 for i in range(13)] _xticks_labels = interval+[150] plt.xticks(_x, _xticks_labels) plt.grid(linestyle='--') plt.show()  复杂分析图 # 使用gridspec和直方图绘制一个复杂分析图 import matplotlib.gridspec as gridspec x = np.random.random(size=10000) y = np.random.normal(loc=0., scale=1., size=10000) plt.figure() gspec = gridspec.GridSpec(3, 3) top_hist = plt.subplot(gspec[0, 1:]) side_hist = plt.subplot(gspec[1:, 0]) lower_right = plt.subplot(gspec[1:, 1:]) lower_right.scatter(x, y) top_hist.hist(x, bins=100, normed=True) side_hist.hist(y, bins=100, orientation='horizontal', normed=True) side_hist.invert_xaxis()  热图 　可用于三维数据可视化\nplt.imshow(arr) plt.hist2d() plt.colorbar() # 添加颜色条  其他  matplotlib支持的图形是非常多的，如果有其他的需求，可以查看一下url地址：http://matplotlib.org/gallery/index.html echarts中可以看框架实例 更多绘图工具： plotly:可视化工具中的github,相比于matplotlib更加简单,图形更加漂亮,同时兼容matplotlib和pandas 使用用法:简单,照着文档写即可 文档地址: https://plot.ly/python/  备注：如果想使用子图，用subplot函数，如果对比子图则徐亚坐标轴相同，添加sharey=（跟哪张图共享坐标轴）\nPandas绘图 Pandas的DataFrame绘图 先转换成dataframe格式进行画图\ndf.plot(kind=) pd.plotting.Tools pd.plotting.scatter_matrix() pd.plotting.parallel_coordinates()  绘制折线图 np.random.seed(100) df = pd.DataFrame({'A': np.random.randn(365).cumsum(0), 'B': np.random.randn(365).cumsum(0) + 20, 'C': np.random.randn(365).cumsum(0) - 20}, index=pd.date_range('2017/1/1', periods=365)) df.plot()  绘制散点图 df.plot('A', 'B', kind='scatter')  # 颜色(c)和大小(s)有'B'列的数据决定 ax = df.plot('A', 'C', kind='scatter', c='B', s=df['B'], colormap='viridis')  盒形图 df.plot(kind='box')  柱状图 df.plot(kind='hist', alpha=0.7) df.plot(kind='kde') # 拟合分布  Seaborn绘图 seaborn的安装：\n1. conda install seaborn 2. pip install seaborn  ","date":1611273600,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1611273600,"objectID":"bc0ba72ae8f8aed4b3757171e8e3b7df","permalink":"https://CoMath21.github.io/post/0-python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%901/","publishdate":"2021-01-22T00:00:00Z","relpermalink":"/post/0-python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%901/","section":"post","summary":"Python数据分析前的准备.","tags":["编程语言","Python","数据分析"],"title":"Python数据分析（一）","type":"post"},{"authors":["Xin态好先生","CoMath"],"categories":["学习笔记","编程语言"],"content":"  文字特殊标注\n  标题\n使用方式：#一级标题\t##二级标题\t######六级标题\n一级标题 二级标题 六级标题   下划线\nctrl+u\n下划线\n  强调\n使用方式：在强调的内容前后各添加两个*\nctrl+b\n强调的内容\n  斜体\n使用方式：内容前后各添加一个*\nctrl+i\n斜体内容\n  删除线\n使用方式：内容前后各添加两个~\n删除线\n  高亮\n使用方式：内容前后各添加两个=\n==高亮==\n    list\n  有序列表\n使用方式：数字1+.\n      无序列表\n使用方式：+/-/*\n       table\nctrl+t\n   序号 姓名 成绩 排名     1 张三 100 1            分割线\n使用方式：输入三个及以上*或-\n    插入元素\n  图片\n插入本地图片：直接把图片拖入即可； 插入网络图片：! [图片标题] (图片链接)\n  链接\n使用方式：[链接提示] (链接地址)\n百度\n  数学公式\n使用方式：$$ 回车 $$ x^2+x_1+7=0 $$\n  代码\n行内代码：代码两端各加一个`\n​\tSystem.out.println();\n代码块：输入三个~ 回车\npublic static void main(String[] args){ System.out.println(\u0026quot;hello world\u0026quot;); }      注意  使用信号符和文字间加一个空格或回车，即可产生效果 强大的导出功能  ","date":1611100800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1611100800,"objectID":"6e4a2227ea2c55aa7d75770fac9a6ee8","permalink":"https://CoMath21.github.io/post/0-typora%E4%BD%BF%E7%94%A8/","publishdate":"2021-01-20T00:00:00Z","relpermalink":"/post/0-typora%E4%BD%BF%E7%94%A8/","section":"post","summary":"Typor快速入门简介","tags":["编程语言","Typora"],"title":"Typora使用","type":"post"},{"authors":["Xin态好先生","CoMath"],"categories":null,"content":"一个人最好的生活状态，是该看书时看书，该玩时尽情玩，看见优秀的人欣赏，看到落魄的人也不轻视，有自己的小生活和小情趣，不用去想改变世界，努力去活出自己。没人爱时专注自己，有人爱时，有能力拥抱彼此\n","date":1611100800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1611100800,"objectID":"83707939014fe3796e181283a66a9a76","permalink":"https://CoMath21.github.io/talk/demo/","publishdate":"2021-01-20T00:00:00Z","relpermalink":"/talk/demo/","section":"talk","summary":"总要留点东西占个地方.","tags":[],"title":"测试-Demo","type":"talk"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"c1d17ff2b20dca0ad6653a3161942b64","permalink":"https://CoMath21.github.io/people/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/people/","section":"","summary":"","tags":null,"title":"关于","type":"widget_page"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"5fcc8730459b0823616811b99a622d2b","permalink":"https://CoMath21.github.io/category/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/category/","section":"","summary":"","tags":null,"title":"分类","type":"widget_page"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"9a6cb9348361050ffbcc0117246adb56","permalink":"https://CoMath21.github.io/tag/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/tag/","section":"","summary":"","tags":null,"title":"标签","type":"widget_page"}]