<!DOCTYPE html><html lang="zh-Hans" >

<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  
  
  <meta name="generator" content="Wowchemy 5.0.0-beta.1 for Hugo">
  

  

  
  

  
  
  
  
  
    
    
    
  
  

  <meta name="author" content="CoMath">

  
  
  
    
  
  <meta name="description" content="具体介绍Hibernate的相关内容.">

  
  <link rel="alternate" hreflang="zh-Hans" href="https://CoMath21.github.io/post/1-hibernate/">

  







  




  
  
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  

  
  
  
  <meta name="theme-color" content="#1565c0">
  

  
  

  
  
  
  
    
    
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.0/css/academicons.min.css" integrity="sha512-W4yqoT1+8NLkinBLBZko+dFB2ZbHsYLDdr50VElllRcNt2Q4/GSs6u71UHKxB7S6JEMCp5Ve4xjh3eGQl/HRvg==" crossorigin="anonymous">
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css" integrity="sha256-FMvZuGapsJLjouA6k7Eo2lusoAX9i0ShlWFG6qt7SLc=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous" media="print" onload="this.media='all'">

    
    
    
      
    
    
      
      
        
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/styles/github.min.css" crossorigin="anonymous" title="hl-light" media="print" onload="this.media='all'">
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/styles/dracula.min.css" crossorigin="anonymous" title="hl-dark" media="print" onload="this.media='all'" disabled>
        
      
    

    

    

    
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/lazysizes/5.2.2/lazysizes.min.js" integrity="sha512-TmDwFLhg3UA4ZG0Eb4MIyT1O1Mb+Oww5kFG0uHqXsdbyZz9DcvYQhKpGgNkamAI6h2lGGZq2X8ftOJvF/XjTUg==" crossorigin="anonymous" async></script>
      
    
      

      
      

      
    
      

      
      

      
    
      

      
      
        
      

      
    
      

      
      

      
    
      

      
      

      
    

  

  
  
  
    
      
      <link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap">
      <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap" media="print" onload="this.media='all'">
    
  

  
  
  
  
  
  <link rel="stylesheet" href="/css/wowchemy.9d711cebf380679328885aff8188d64e.css">

  




  

  


  
  

  

  
  <link rel="manifest" href="/index.webmanifest">
  

  <link rel="icon" type="image/png" href="/images/icon_hue90aa69698efeb53250d93a62bbb007f_97431_32x32_fill_lanczos_center_2.png">
  <link rel="apple-touch-icon" type="image/png" href="/images/icon_hue90aa69698efeb53250d93a62bbb007f_97431_192x192_fill_lanczos_center_2.png">

  <link rel="canonical" href="https://CoMath21.github.io/post/1-hibernate/">

  
  
  
  
  
  
  
    
  
  
  <meta property="twitter:card" content="summary_large_image">
  
  <meta property="og:site_name" content="CoMath">
  <meta property="og:url" content="https://CoMath21.github.io/post/1-hibernate/">
  <meta property="og:title" content="Hibernate学习笔记 | CoMath">
  <meta property="og:description" content="具体介绍Hibernate的相关内容."><meta property="og:image" content="https://CoMath21.github.io/post/1-hibernate/featured.jpg">
  <meta property="twitter:image" content="https://CoMath21.github.io/post/1-hibernate/featured.jpg"><meta property="og:locale" content="zh-Hans">
  
    
      <meta property="article:published_time" content="2021-01-29T00:00:00&#43;00:00">
    
    <meta property="article:modified_time" content="2021-01-29T00:00:00&#43;00:00">
  

  


    






  




<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://CoMath21.github.io/post/1-hibernate/"
  },
  "headline": "Hibernate学习笔记",
  
  "image": [
    "https://CoMath21.github.io/post/1-hibernate/featured.jpg"
  ],
  
  "datePublished": "2021-01-29T00:00:00Z",
  "dateModified": "2021-01-29T00:00:00Z",
  
  "author": {
    "@type": "Person",
    "name": "Xin态好先生"
  },
  
  "publisher": {
    "@type": "Organization",
    "name": "CoMath",
    "logo": {
      "@type": "ImageObject",
      "url": "https://CoMath21.github.io/images/logo_hud8da91bfe93f3d7d35fd2296e35ef0bf_39934_192x192_fit_lanczos_2.png"
    }
  },
  "description": "具体介绍Hibernate的相关内容."
}
</script>

  

  


  


  





  <title>Hibernate学习笔记 | CoMath</title>

</head>


<body id="top" data-spy="scroll" data-offset="70" data-target="#TableOfContents" class="page-wrapper  ">

  
  
  
  
  
  
  
  
  <script src="/js/wowchemy-init.min.7264cf0eba3b66951b36da7d2cecf9c5.js"></script>

  

<aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between mb-3">
        <div class="col-6">
          <h1>搜索</h1>
        </div>
        <div class="col-6 col-search-close">
          <a class="js-search" href="#" aria-label="Close"><i class="fas fa-times-circle text-muted" aria-hidden="true"></i></a>
        </div>
      </div>

      <div id="search-box">
        
        <input name="q" id="search-query" placeholder="搜索..." autocapitalize="off"
        autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control"
        aria-label="搜索...">
        
      </div>

      

    </section>
    <section class="section-search-results">

      <div id="search-hits">
        
      </div>

    </section>
  </div>
</aside>



  <div class="page-header">
    











  


<nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id="navbar-main">
  <div class="container">

    
    <div class="d-none d-lg-inline-flex">
      <a class="navbar-brand" href="/"><img src="/images/logo_hud8da91bfe93f3d7d35fd2296e35ef0bf_39934_0x70_resize_lanczos_2.png" alt="CoMath"></a>
    </div>
    

    
    <button type="button" class="navbar-toggler" data-toggle="collapse"
            data-target="#navbar-content" aria-controls="navbar" aria-expanded="false" aria-label="切换导航">
    <span><i class="fas fa-bars"></i></span>
    </button>
    

    
    <div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none">
      <a class="navbar-brand" href="/"><img src="/images/logo_hud8da91bfe93f3d7d35fd2296e35ef0bf_39934_0x70_resize_lanczos_2.png" alt="CoMath"></a>
    </div>
    

    
    
    <div class="navbar-collapse main-menu-item collapse justify-content-end" id="navbar-content">

      
      <ul class="navbar-nav d-md-inline-flex">
        

        

        
        
        

        

        
        
        
        

        
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/"><span>首页</span></a>
        </li>

        
        

        

        
        
        

        

        
        
        
        

        
          
            
            
          
          
        

        <li class="nav-item">
          <a class="nav-link  active" href="/post"><span>归档</span></a>
        </li>

        
        

        

        
        
        
          
        

        

        
        
        
        

        
          
            
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/category"><span>分类</span></a>
        </li>

        
        

        

        
        
        

        

        
        
        
        

        
          
            
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/tag"><span>标签</span></a>
        </li>

        
        

        

        
        
        

        

        
        
        
        

        
          
            
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/talk"><span>说说</span></a>
        </li>

        
        

        

        
        
        
          
        

        

        
        
        
        

        
          
            
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/people"><span>关于</span></a>
        </li>

        
        

      

        
      </ul>
    </div>

    <ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2">

      
      
        
      

      
      
      <li class="nav-item">
        <a class="nav-link js-search" href="#" aria-label="搜索"><i class="fas fa-search" aria-hidden="true"></i></a>
      </li>
      

      
      
      <li class="nav-item dropdown theme-dropdown">
        <a href="#" class="nav-link" data-toggle="dropdown" aria-haspopup="true" aria-label="Display preferences">
          <i class="fas fa-moon" aria-hidden="true"></i>
        </a>
        <div class="dropdown-menu">
          <a href="#" class="dropdown-item js-set-theme-light">
            <span>浅色</span>
          </a>
          <a href="#" class="dropdown-item js-set-theme-dark">
            <span>深色</span>
          </a>
          <a href="#" class="dropdown-item js-set-theme-auto">
            <span>自动</span>
          </a>
        </div>
      </li>
      

      

    </ul>

  </div>
</nav>


  </div>

  <div class="page-body">
    <article class="article">

  




















  
  


<div class="article-container pt-3">
  <h1>Hibernate学习笔记</h1>

  

  


<div class="article-metadata">

  
  
  
  
  <div>
    

  <span >
      <a href="/authors/admin/">Xin态好先生</a></span>, <span >
      <a href="/authors/comath/">CoMath</a></span>
  </div>
  
  

  
  <span class="article-date">
    
    
      
    
    2021年1月29日
  </span>
  

  

  
  <span class="middot-divider"></span>
  <span class="article-reading-time">
    9 分钟阅读时长
  </span>
  

  
  
  
  
  

  
  
  <span class="middot-divider"></span>
  <span class="article-categories">
    <i class="fas fa-folder mr-1"></i><a href="/category/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>, <a href="/category/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></span>
  

</div>

  














</div>


<div class="article-header article-container featured-image-wrapper mt-4 mb-4" style="max-width: 487px; max-height: 254px;">
  <div style="position: relative">
    <img src="/post/1-hibernate/featured.jpg" alt="" class="featured-image">
    <span class="article-header-caption">CoMath</span>
  </div>
</div>



  <div class="article-container">

    <div class="article-style">
      <h2 id="hibernate-是什么">Hibernate 是什么？</h2>
<ol>
<li>hibernate是一个轻量级JavaEE应用的持久层框架（framework）</li>
<li>hibernate是一个ORM（object relation mapping对象关系映射）框架
<ul>
<li>o object -&gt; 业务层(只对对象操作)</li>
<li>r relation-&gt; 关系数据库，关系型数据库中二维表</li>
<li>m mapping 对象关系映射文件
<ul>
<li>java类&mdash;&mdash;&mdash;&mdash;-&gt;表</li>
<li>java对象&mdash;&mdash;&mdash;&ndash;&gt;表中记录</li>
<li>java对象属性&mdash;&mdash;-&gt;表中字段</li>
</ul>
</li>
</ul>
</li>
<li>hibernate 处于我们项目的持久层位置(正因为如此，所以有人又把hibernate称为 持久层框架)</li>
<li>hibernate 实际上就是对jdbc进行了轻量级的封装.</li>
<li>hibernate 的基础还是我们java反射机制</li>
</ol>
<h2 id="手动配置hibernate方式完成crud操作">手动配置hibernate方式完成crud操作</h2>
<p>　　首先创建项目，再引入jar包. hibernate开发的三种方式：</p>
<ol>
<li>由domain object –&gt; mapping -&gt; db (官方推荐).</li>
<li>由DB开始，用工具生成mapping和domain object (使用较多).</li>
<li>由映射开始.</li>
</ol>
<h2 id="employeehbmlxml配置文件">Employee.hbml.xml配置文件</h2>
<pre><code>&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;
	&quot;http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd&quot;&gt;
&lt;hibernate-mapping package=&quot;com.hsp.domain&quot;&gt;
  &lt;class name=&quot;Employee&quot; table=&quot;employee&quot;&gt;
    &lt;!-- id元素用于指定主键属性 --&gt;
    &lt;id name=&quot;id&quot; column=&quot;id&quot; type=&quot;java.lang.Integer&quot;&gt;
    &lt;!-- 该元素用于指定主键值生成策略hilo native increment sequence uuid --&gt;
      &lt;generator class=&quot;sequence&quot;&gt;
        &lt;param name=&quot;sequence&quot;&gt;emp_seq&lt;/param&gt;
      &lt;/generator&gt;
    &lt;/id&gt;
    &lt;!-- 对其它属性还有配置 --&gt;
    &lt;property name=&quot;name&quot; type=&quot;java.lang.String&quot;&gt;
      &lt;column name=&quot;name&quot; not-null=&quot;false&quot;  /&gt;
    &lt;/property&gt;
    &lt;property name=&quot;email&quot; type=&quot;java.lang.String&quot; &gt;
      &lt;column name=&quot;email&quot; not-null=&quot;false&quot;/&gt;
    &lt;/property&gt;
    &lt;property name=&quot;hiredate&quot; type=&quot;java.util.Date&quot;&gt;
      &lt;column name=&quot;hiredate&quot; not-null=&quot;false&quot; /&gt;
    &lt;/property&gt;
  &lt;/class&gt;	
&lt;/hibernate-mapping&gt;
</code></pre>
<p><img src="./1.png" alt="png"></p>
<h2 id="hibernatecfgxml配置文件">hibernate.cfg.xml配置文件</h2>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;!DOCTYPE hibernate-configuration PUBLIC
        &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot;
        &quot;http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd&quot;&gt;
&lt;hibernate-configuration&gt;
  &lt;session-factory&gt;
    &lt;!-- hibernate 设计者，给我们提供了一写常用的配置 --&gt;
    &lt;!-- 配置使用的driver --&gt;
    &lt;property name=&quot;connection.driver_class&quot;&gt;oracle.jdbc.driver.OracleDriver&lt;/property&gt;
    &lt;!-- 配置使用的账户密码 --&gt;
    &lt;property name=&quot;connection.username&quot;&gt;scott&lt;/property&gt;
    &lt;property name=&quot;connection.password&quot;&gt;tiger&lt;/property&gt;
    &lt;property name=&quot;connection.url&quot;&gt;jdbc:oracle:thin:@127.0.0.1:1521:orclhsp&lt;/property&gt;
    &lt;!-- 配置dialect方言,明确告诉hibernate连接是哪种数据库 --&gt;
    &lt;property name=&quot;dialect&quot;&gt;org.hibernate.dialect.OracleDialect&lt;/property&gt;
    &lt;!-- 显示出对于sql语句 --&gt;
    &lt;property name=&quot;show_sql&quot;&gt;true&lt;/property&gt;
    &lt;!-- 指定管理的对象映射文件 --&gt;
    &lt;mapping resource=&quot;com/hsp/domain/Employee.hbm.xml&quot;/&gt;
  &lt;/session-factory&gt;
&lt;/hibernate-configuration&gt;
</code></pre>
<p>说明：</p>
<ol>
<li>connection.driver_class:在etc下可以找到；</li>
<li>hibernate.cfg.xml文件可以不写，但要在spring中配置.</li>
</ol>
<h2 id="测试文件testmainjava">测试文件TestMain.java</h2>
<pre><code>package com.hsp.view;
import com.hsp.util.*;
import java.util.Date;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.cfg.*;

import com.hsp.domain.Employee;
public class TestMain {
  public static void main(String[] args) {
    //查询[load]-&gt;hql语句(hibernate query language)
  }
  public static void delEmp() {
    //删除
    //获取一个session
    Session session=MySessionFactory.getSessionFactory().openSession();
    Transaction ts=session.beginTransaction();
    //删除1.先获取该雇员，然后删除
    Employee emp=(Employee) session.load(Employee.class, 3);
    session.delete(emp);
    ts.commit();
    session.close();
  }

  public static void updateEmp() {
    // TODO Auto-generated method stub
    //修改用户
    //获取一个会话
    Session session=MySessionFactory.getSessionFactory().openSession();
    
    Transaction ts=session.beginTransaction();
    //修改用户1. 获取要修改的用户，2.修改
    //load是通过主键属性，获取该对象实例.&lt;---&gt;表的记录对应
    Employee emp=(Employee) session.load(Employee.class, 3);
    emp.setName(&quot;韩顺平8&quot;);//update...
    emp.setEmail(&quot;abc@sohu.com&quot;);
    ts.commit();
    session.close();
  }

  public static void addEmployee() {
    //我们使用hibernate完成crud操作[这里我们只见对象，不见表]
    //现在我们不是用service ,直接测试.
    //1. 创建Configuration,该对象用于读取hibernate.cfg.xml,并完成初始化
    Configuration configuration=new Configuration().configure();
    //2.创建SessoinFactory[这是一个会话工厂，是一个重量级的对象]
    SessionFactory sessionFactory=configuration.buildSessionFactory();
    //3.创建Sessoin 相当于jdbc Connection[ servelt HttpSession ,也不是 jsp session]
    Session session=sessionFactory.openSession();
    //4.对hiberate而言，要求在进行 增加，删除，修改的时候使用事务提交，
    Transaction transaction = session.beginTransaction();
    //添加一个雇员
    Employee employee=new Employee();
    employee.setName(&quot;shunping&quot;);
    employee.setEmail(&quot;shunping@sohu.com&quot;);
    employee.setHiredate(new Date());
    //insert .............
    //保存
    session.save(employee);//save employee就是持久化该对象 (把对象保存到了数据库中称为一条记录)
    //==&gt;insert into ....[被hiberante封装]
    //提交
    transaction.commit();
    session.close();
  }
}
</code></pre>
<p><img src="./2.png" alt="png"></p>
<p>　　<code>&lt;Hibernate-mapping&gt;</code>标签的属性如下：</p>
<ol>
<li>package：指定一个包前缀，如果在映射文档中(就是在class标签的那么属性里没有指定全类名)没有指定全限定的类名，就使用这个作为包名.</li>
<li>schema：数据库schema的名称.</li>
<li>catalog：数据库catalog的名称.</li>
<li>default-cascade：默认的级联风格,默认为none.</li>
<li>default-access：Hibernate用来访问属性的策略.</li>
<li>default-lazy：指定了此属性，未明确注明lazy属性的Java属性和集合类，Hibernate会采取的默认使用这个属性加载风格,默认为true.</li>
<li>auto-import：指定我们是否可以在查询语言中使用非全限定的类名,默认为true,如果项目中有两个同名的持久化类,则最好在这两个类的对应的映射文件中配置为false.</li>
</ol>
<p>　　Hibernate的子标签class标签：</p>
<ul>
<li>class 元素用于指定类和表的映射 .</li>
<li>name:指定该持久化类映射的持久化类的类名.
<ul>
<li>example:<code>&lt;class name=&quot;com.jeremy.hibernate.example.News&quot; table=&quot;NEWS&quot;&gt;</code>.</li>
</ul>
</li>
<li>table:指定该持久化类映射的表名, Hibernate 默认以持久化类的类名作为表名 .
<ul>
<li>example:<code>&lt;class name=&quot;com.jeremy.hibernate.example.News&quot; table=&quot;NEWS&quot;&gt;</code>.</li>
</ul>
</li>
<li>dynamic-insert: 若设置为 true, 表示当（调用Session的save()方法时）保存一个对象时, 会动态生成 insert 语句, insert 语句中仅包含所有取值不为 null 的字段. 默认值为 false.</li>
<li>Example:这个跟dynamic-update一个意思.</li>
<li>dynamic-update: 若设置为 true, 表示当(调用对象的set()方法)更新一个对象时, 会动态生成 update 语句, update 语句中仅包含所有取值需要更新的字段. 默认值为 false.</li>
</ul>
<p>　　Hibernate映射文件主要内容:</p>
<ol>
<li>映射内容的定义:
Hibernate映射文件由<code>&lt;hibernate-mapping package=&quot;JavaBean所在包的全路径&quot;&gt;</code>节点定义映射内容并指定所对应的JavaBean的位置(也可以不在该节点中用package属性指定对应的JavaBean位置,而在该节点下的class节点中的name属性中指定).</li>
<li>数据库和JavaBean的关联:
Hibernate映射文件中用<code>&lt;hibernate-mapping&gt;</code>节点下的
<code>&lt;class name=&quot;JavaBean名称&quot; table=&quot;对应数据库中的表名&quot;&gt;</code>节点指定数据库表和JavaBean的关联. ( 该节点的父节点中用package属性指定了JavaBean的包名时用)/全路径(该节点的父节点中没用package属性指定JavaBean的包名时用).</li>
<li>主键映射:
在<code>&lt;class &gt;</code>节点下用<code>&lt;id name=&quot;数据库中主键在JavaBean中的属性名称&quot; column=&quot;数据库中主键名&quot; type=&quot;string&quot;&gt;</code>节点映射对应的主键,该节点必须有且只有一个(因为主键只有一个),同时必须放在<code>&lt;property ...&gt;</code>节点前.</li>
<li>普通字段映射:
在<code>&lt;class ...&gt;</code>节点下用<code>&lt;property name=&quot;数据库中字段在JavaBean中的属性名称&quot; column=&quot;数据库中的字段名&quot; type=&quot;string&quot;/&gt;</code>节点映射普通字段,该节点可有多个(一个字段用一个该节点来映射).</li>
</ol>
<p>　　Heibernate的主键映射方式：</p>
<p>　　在<code>&lt;id ...&gt;节点下用&lt;generator class=&quot;映射方式&quot;/&gt;</code>节点指定Hibernate向数据库插入数据时主键的生成方式.</p>
<ul>
<li>assigned：应用程序自身对id赋值. 当设置<code>&lt;generator class=&quot;assigned&quot;/&gt;</code>时，应用程序自身需要负责主键id的赋值，由外部程序负责生成(在session.save()之前为对象的主键设置值),无需Hibernate参与，一般应用在主键为自然主键时. 例如XH为主键时，当添加一个学生信息时，就需要程序员自己设置学号的值，这时就需要应用该id生成器.</li>
<li>native：由数据库对id赋值. 当设置<code>&lt;generator class=&quot;native&quot;/&gt;</code>时，数据库负责主键id的赋值，最常见的是int型的自增型主键. 例如，在SQLServer中建立表的id字段为identity，配置了该生成器，程序员就不用为该主键设置值，它会自动设置.</li>
<li>identity：采用数据库提供的主键生成机制，为long/short/int型列生成唯一标识如SQL Server、MySQL中的自增主键生成机制.</li>
<li>hilo：通过hi/lo算法实现的主键生成机制，需要额外的数据库表保存主键生成历史状态.</li>
<li>seqhilo：与hi/lo类似，通过hi/lo算法实现的主键生成机制，只是主键历史状态保存在sequence中，适用于支持sequence的数据库，如Oracle.</li>
<li>increment：主键按数值顺序递增. 此方式的实现机制为在当前应用实例中维持一个变量，以保存当前的最大值，之后每次需要生成主键的时候将此值加1作为主键. 这种方式可能产生的问题是：如果当前有多个实例访问同一个数据库，由于各个实例各自维护主键状态，不同实例可能生成同样的主键，从而造成主键重复异常. 因此，如果同一个数据库有多个实例访问，这种方式应该避免使用.</li>
<li>sequence：采用数据库提供的sequence机制生成主键，用于用序列方式产生主键的数据库(如:Oracle、DB2等的Sequence),用于为long/short/int型列生成唯一标识,如:<code>&lt;generator class=&quot;sequence&quot;&gt;&lt;param name=&quot;sequence&quot;&gt;序列名&lt;/param&gt;&lt;/generator&gt;</code>如Oracle sequence.</li>
<li>uuid.hex：由Hibernate基于128位唯一值产生算法，根据当前设备IP、时间、JVM启动时间、内部自增量等4个参数生成十六进制数值（编码后长度为32位的字符串表示）作为主键. 即使是在多实例并发运行的情况下，这种算法在最大程度上保证了产生id的唯一性. 当然，重复的概率在理论上依然存在，只是概率比较小. 一般而言，利用uuid.hex方式生成主键将提供最好的数据插入性能和数据平台适应性.</li>
<li>uuid.string：与uuid.hex类似，只是对生成的主键进行编码（长度为16位）. 在某些数据库中可能出现问题.</li>
<li>foreign：使用外部表的字段作为主键. 该主键一般应用在表与表之间的关系上，会在后面的表对应关系上进一步讲解.</li>
<li>select：Hibernate 3新引入的主键生成机制，主要针对遗留系统的改造工程.
由于常用的数据库，如SQLServer、MySQL等，都提供了易用的主键生成机制（如auto-increase字段），可以在数据库提供的主键生成机制上，采用native生成器来配置主键生成方式.</li>
</ul>
<h2 id="hibernate的核心类和接口">Hibernate的核心类和接口</h2>
<h3 id="1configuration类">1、Configuration类</h3>
<p>它的作用是：</p>
<ol>
<li>负责管理hibernate的配置信息；</li>
<li>读取hibernate.cfg.xml文件；</li>
<li>加载hibernate.cfg.xml配置文件中配置的驱动文件，url，用户名，密码，连接池；</li>
<li>管理 *.hbm.xml对象关系文件.</li>
</ol>
<h3 id="2hibernatecfgxml文件">2、hibernate.cfg.xml文件</h3>
<ol>
<li>该文件主要用于制定各个参数，值hibernate核心文件；</li>
<li>默认放在src目录下，也可以在别的目录下；</li>
<li>指定连接数据库的驱动、用户名、url、密码、连接池；</li>
<li>制定对象关系映射文件位置；</li>
<li>也可以使用hibernate,properties文件来替代该文件.</li>
</ol>
<h3 id="3sessionfactory-接口">3、SessionFactory 接口</h3>
<ol>
<li>可以缓存SQL语句或者数据（称为）.</li>
<li>在应用程序化的时候创建，是一个重量级的类，一般用单例模式保证一个应用只需要一个SessionFactory实例.</li>
<li>如果某个应用访问多个数据库，则要创建多个回话工厂实例，一般一个数据库一个会话工厂实例.</li>
<li>通过SessionFactory接口可以获得Session实例.</li>
</ol>
<pre><code>Configuration cf = new Configuration().configure();
SessionFactory sf = cf.buildSessionFactory();
Session s = sf.getCurrentSession();
//或者：Session  s = sf.openSession(); 
</code></pre>
<h4 id="31-opensession和getcurrentsession区别">3.1 openSession()和getCurrentSession()区别</h4>
<ol>
<li>采用getCurrentSession()创建的session会绑定到当前线程中，而采用openSession()创建的Session则不会；</li>
<li>采用getCurrentSession()创建的session在commit或rollback时会自动关闭，而采用openSession()创建的session必须手动关闭（建议不管是用哪个，最好都要手动关闭）；</li>
<li>使用getCurrentSession()需要在hibernate.cfg.xml文件中加入如下配置：</li>
</ol>
<pre><code>* 如果使用的是本地事务（jdbc事务：针对一个数据库的事务）*
&lt;property name=&quot;hibernate.current_session_context_class&quot;&gt;thread&lt;/property&gt;
* 如果使用的是全局事务（jta事务：卷数据库的事务）*
&lt;property name=&quot;hibernate.current_session_context_class&quot;&gt;jta&lt;/property&gt;
</code></pre>
<p><em>如何选择openSession()和getCurrentSession()</em></p>
<p><b>原则：</b></p>
<ul>
<li>如果需要在同一线程中，保证使用同一个Session，则使用getCurrentSession().</li>
<li>如果在一个线程中，需要使用不同的Session，则使用openSession().</li>
</ul>
<h4 id="32get-vs-load">3.2	get vs load</h4>
<p>　可以使用<code>session.get(Student.class,i)/session.load(…)</code>获取值</p>
<ol>
<li>如果查询不到数据，get会返回 null,但是不会报错, load如果查询不到数据，则报错ObjectNotFoundException</li>
<li>使用get 去查询数据，(先到一级/二级)会立即向db发出查询请求(select &hellip;), 如果你使用的是 load查询数据，(先到一级、二级))即使查询到对象，返回的是一个代理对象,如果后面没有使用查询结果，它不会真的向数据库发select ,当程序员使用查询结果的时候才真的发出select ,这个现象我们称为“懒加载”(lazy)</li>
<li>通过修改配置文件，我们可以取消“懒加载”；</li>
</ol>
<pre><code>&lt;class  name=&quot;Employee&quot; lazy=&quot;false&quot; table=&quot;employee&quot;&gt;
</code></pre>
<ol start="4">
<li>如何选择使用哪个: 如果你确定DB中有这个对象就用load(),不确定就用get()（这样效率高）.</li>
</ol>
<h3 id="4transaction事务接口">4、Transaction（事务）接口</h3>
<p>　　事务简单地说就是一组对数据库的操作集合，他们要么全部成功，要么全部失败，这个可以保证数据的一致性，事务具有原子性.</p>
<ol>
<li>Transaction是底层的事物实现中抽取出来的接口；</li>
<li>可能是一个jdbc或者jta的事务，这样有利于hibernate在不同执行环境的移植；</li>
<li>Hibernate要求显示的调用事务（如果仅仅是查询可以不调用）.</li>
</ol>
<pre><code>//增加删除修改如果发生异常要tx.rollback()回滚
Session sess = factory.openSession();
Transaction tx;
try {
    tx = sess.beginTransaction();
    //do some work
    ...
    tx.commit();
}
catch (Exception e) {
    if (tx!=null) tx.rollback();
    throw e;
}
finally {
    sess.close();
}
</code></pre>
<h3 id="5query-接口">5、Query 接口</h3>
<p>　　Query接口类型的对象可以对数据库操作，他可以使用Hql，Qbc，Qbe和原生SQL（native Sql）对数据库操作，官方推荐使用Hql语句.</p>
<pre><code>//获取query引用[这里Employee不是表名，而是domain类名]，where后面的条件最好使用类下的属性名
Query query = session.createQuery(&quot;from Employee where id=10&quot;);
//通过list方法获取结果，这个list会自动封装成对应的domain对象
List&lt;Employee&gt; list = query.list();
for(Employee e:list)
	...
</code></pre>
<h3 id="6criteria接口">6、Criteria接口</h3>
<p>　　什么是QBC：
QBC（Query By Criteria）按条件查询，通过Criteria构造查询条件，即通过调用Criteria的api实现各种查询.</p>
<p>　　通过Criteria对象拼装 查询条件，调用Criteria的add方法拼接查询条件，最终hibernate通过criteria对象自动生成sql语句.</p>
<p><em>（了解）纯面向对象的检索方式</em></p>
<pre><code>Session session=HibernateUtil.getCurrentSession();
Transaction ts=null;		
try {			
  ts=session.beginTransaction();			
  Criteria cri = session.createCriteria(Employee.class).
  setMaxResults(2).addOrder(Order.desc(&quot;id&quot;) );//按照升序   
  List&lt;Employee&gt; list=cri.list();
  for(Employee e: list){
    System.out.println(e.getAaaid());
  }			
  ts.commit();			
} catch (Exception e) {			
  if(ts!=null){
    ts.rollback();
  }
  throw new RuntimeException(e.getMessage());
}finally{
  //关闭session
  if(session!=null&amp;&amp;session.isOpen()){
    session.close();
  }
  
}
</code></pre>
<p><img src="./3.png" alt="png"></p>
<h3 id="mysql记录总数查询">MySQL记录总数查询</h3>
<ul>
<li>分页查询
<img src="./4.png" alt="png"></li>
<li>投影查询方法
<img src="./5.png" alt="png"></li>
<li>记录总数查询
<img src="./6.png" alt="png"></li>
</ul>
<h2 id="detachedcriteria">DetachedCriteria</h2>
<ul>
<li>DetachedCriteria是什么？离线的Criteria.</li>
<li>DetachedCriteria和Criteria区别：
<ul>
<li>Criteria创建方法：session.createCriteria</li>
<li>DetachedCriteria创建方法：不需要session．</li>
</ul>
</li>
<li>DetachedCriteria和Criteria相同点：实现查询条件拼装.</li>
</ul>
<p>　　建议使用DetachedCriteria，因为DetachedCriteria创建不需要session，在任何代码中通过DetachedCriteria 拼接查询条件.
<img src="./7.png" alt="png">
这里的HibernateUtil为打开SessionFactory.</p>
<h2 id="service">service</h2>
<p>　　接收servlet传入查询条件，将查询条件拼装成DetachedCritriea.
<img src="./8.png" alt="png"></p>
<pre><code>@Override
public Long findCustomerCount(CstCustomer cstCustomer) {
  
  //创建DetachedCriteria
  DetachedCriteria detachedCriteria = DetachedCriteria.forClass(CstCustomer.class);
  
  //根据cstCustomer中数据动态拼接查询条件
  if(cstCustomer!=null){
    //拼接客户名称查询条件，使用like
    if(cstCustomer.getCustName()!=null &amp;&amp; !cstCustomer.getCustName().equals(&quot;&quot;)){
      detachedCriteria.add(Restrictions.like(&quot;custName&quot;, &quot;%&quot;+cstCustomer.getCustName()+&quot;%&quot;));
    }
    //拼接联系人查询条件
    if(cstCustomer.getCustLinkman()!=null &amp;&amp; !cstCustomer.getCustLinkman().equals(&quot;&quot;)){
      detachedCriteria.add(Restrictions.eq(&quot;custLinkman&quot;,cstCustomer.getCustLinkman()));
    }
  }
  
  CstCustomerDao cstCustomerDao = new CstCustomerDaoImpl();
  
  return cstCustomerDao.findCustomerCount(detachedCriteria);
}
@Override
public List&lt;CstCustomer&gt; findCustomerList(CstCustomer cstCustomer, int firstResult, int maxResults) {
  CstCustomerDao cstCustomerDao = new CstCustomerDaoImpl();
  //创建DetachedCriteria
  DetachedCriteria detachedCriteria = DetachedCriteria.forClass(CstCustomer.class);
  
  //拼接查询条件
  //根据cstCustomer中数据动态拼接查询条件
  if(cstCustomer!=null){
    //拼接客户名称查询条件，使用like
    if(cstCustomer.getCustName()!=null &amp;&amp; !cstCustomer.getCustName().equals(&quot;&quot;)){
      detachedCriteria.add(Restrictions.like(&quot;custName&quot;, &quot;%&quot;+cstCustomer.getCustName()+&quot;%&quot;));
    }
    //拼接联系人查询条件
    if(cstCustomer.getCustLinkman()!=null &amp;&amp; !cstCustomer.getCustLinkman().equals(&quot;&quot;)){
      detachedCriteria.add(Restrictions.eq(&quot;custLinkman&quot;,cstCustomer.getCustLinkman()));
    }
  }
  
  return cstCustomerDao.findCustomerList(detachedCriteria, firstResult, maxResults);
}
</code></pre>
<h2 id="log4j学习">log4j学习</h2>
<p>目标：学会使用log4j自定义输出日志信息.</p>
<p>hibernate默认使用slf4j框架.</p>
<ul>
<li>slf4j：提供了一套日志记录接口规范.</li>
<li>log4j：日志接口的实现类.</li>
</ul>
<p>　　如果 使用log4j需要以classpath下添加log4j.properties文件.</p>
<p>Log4j包括三个主要部件，分别是：</p>
<ol>
<li>记录器（Loggers）：配置日志在哪记录.</li>
<li>输出源（Appenders）：配置日志输出到哪里.
<img src="./9.png" alt="png"></li>
<li>布局（Layouts），指定日志输出格式
<img src="./10.png" alt="png">
<em>记录器：</em></li>
</ol>
<pre><code>log4j.rootLogger=debug,A
log4j.appender.A=org.apache.log4j.ConsoleAppender
log4j.appender.A.layout=org.apache.log4j.PatternLayout
</code></pre>
<p><em>日志级别</em></p>
<ol>
<li>
<p>日志级别由低到高为：ALL &lt; TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL &lt; OFF.</p>
</li>
<li>
<p>日志级别越低输出日志越多，因为将系统调试信息设置级别低，系统的错误信息级别要高，设置成error.</p>
</li>
</ol>
<p><em>根据log4j.properties中级别设置，将级别高的日志输出.</em></p>
<p><em>在开发阶段设置为debug，在生产环境设置info或error.</em></p>
<h2 id="用myeclipse进行hibernate快速开发">用MyEclipse进行hibernate快速开发</h2>
<p>　　手动配置:</p>
<p>db(table )-&gt; 手写domain对象-&gt;对象关系映射文件.</p>
<p>现在我们希望用工具完成Domain对象和关系映射文件的工作.
<img src="./11.png" alt="png">
<img src="./12.png" alt="png">
<img src="./13.png" alt="png">
<img src="./14.png" alt="png"></p>
<p><b>错误信息</b></p>
<p><font color=red>java.lang.AbstractMethodError: com.microsoft.jdbc.base.BaseDatabaseMetaData.supportsGetGeneratedKeys()Z</font></p>
<p><b>解决</b>：microsoft提供的数据库驱动存在bug. 需要换一种驱动连接，使用jtds（<a href="http://sourceforge.net/projects/jtds/files/" target="_blank" rel="noopener">下载地址</a>）下载jtds1.2版，解压得到jtds-1.2.jar，引用到eclipse中项目目录下（去除原驱动引用），更改hibernate配置文件.</p>
<p>原驱动连接配置：</p>
<pre><code>&lt;property name=&quot;connection.driver_class&quot;&gt;com.microsoft.jdbc.sqlserver.SQLServerDriver&lt;/property&gt;
&lt;property name=&quot;connection.url&quot;&gt;jdbc:microsoft:sqlserver://127.0.0.1:1433;DatabaseName=hibernate&lt;/property&gt;
</code></pre>
<p>更改jtds连接：</p>
<pre><code>&lt;property name=&quot;connection.driver_class&quot;&gt;net.sourceforge.jtds.jdbc.Driver&lt;/property&gt;
&lt;property name=&quot;connection.url&quot;&gt;jdbc:jtds:sqlserver://127.0.0.1:1433;DatabaseName=hibernate&lt;/property&gt;
</code></pre>
<p>问题得到解决.</p>
<p><b>补充</b>：java代码调原驱动连接数据库是没有问题的，搭配hibernate会有此问题.</p>
<pre><code># HibernateUtil工具类：
package com.haibao.util;

import javax.persistence.Entity;
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.cfg.Configuration;

@Entity
final public class HibernateUtil {
  private static SessionFactory sessionFactory = null;
  private static ThreadLocal&lt;Session&gt; threadLocal = new ThreadLocal&lt;Session&gt;();

  private HibernateUtil(){};

  static{
    sessionFactory = new Configuration().configure().buildSessionFactory();
  }

  public static Session openSession(){
    return sessionFactory.openSession();
  }

  public static Session getCurrentSession(){
    Session session = threadLocal.get();
    if(session==null){
      session = sessionFactory.openSession();
      threadLocal.set(session);
    }
    return session;
  }
}
# 实现类：
package com.haibao.view;

import javax.persistence.Entity;

import org.hibernate.Session;
import org.hibernate.Transaction;

import com.haibao.bean.Person;
import com.haibao.util.HibernateUtil;

@Entity
public class Main {
  public static void main(String[] args) {

    Session session = null;
    Transaction ts = null;
    try {
      session = HibernateUtil.getCurrentSession();
      ts = session.beginTransaction();
      Person p = new Person();
      p.setName(&quot;asd&quot;);
      p.setSex(&quot;男&quot;);
      session.persist(p);
      ts.commit();
    } catch (Exception e) {
      if(ts!=null){
        ts.rollback();
      }
      throw new RuntimeException(e.getMessage());
    }finally{
      if(session!=null &amp;&amp; session.isOpen()){
        session.close();
      }
    }
  }
}
</code></pre>
<h2 id="hql语句hibernate-query-language">HQL语句（Hibernate Query Language）</h2>
<p>　　面向对象的查询语句，与SQL不同，HQl中的对象是区分大小写的（除了JAVA类和属性其他部分不区分大小写）；在HQL中查的是对象而不是表，并且支持多态；HQL主要通过Query来操作，Query的创建方式：</p>
<pre><code>Query query = session.createQuery(hql);
</code></pre>
<p>　　现在使用hibernate工具，自动生成 domain 对象 和映射文件,如果我们的表有主外键的关系，则应当先映射主表，再映射从表.</p>
<h2 id="uniqueresult方法">uniqueResult方法</h2>
<p>　　如果我们检索一个对象，明确知道最多只有一个对象，则建议使用该方法，简单高效. 具体用法如下:</p>
<pre><code>Student s=(Student) session.createQuery(&quot;from Student where sid='20050003'&quot;).uniqueResult();
System.out.println(s.getSname());
</code></pre>
<h2 id="distinct的用法">distinct的用法</h2>
<p>过滤重复的记录</p>
<pre><code>//比如，显示所有学生的性别和年龄.
List list=session.createQuery(&quot;select distinct sage,ssex from Student&quot;).list();
  for(int i=0;i&lt;list.size();i++){
    Object []  objs=(Object[]) list.get(i);
    System.out.println(objs[0].toString()+&quot; &quot;+objs[1].toString());
}
</code></pre>
<h2 id="between-and">between and..</h2>
<pre><code>List list=session.createQuery(&quot;select distinct sage,ssex,sname from Student where sage between 20 and 22&quot;).list();
  for(int i=0;i&lt;list.size();i++){
    Object []  objs=(Object[]) list.get(i);
    System.out.println(objs[0].toString()+&quot; &quot;+objs[1].toString()+objs[2].toString());
}
</code></pre>
<h2 id="innot-in">in/not in</h2>
<pre><code>//查询计算机系和外语系的学生信息
List&lt;Student&gt; list=session.createQuery(&quot;from Student where sdept in ('计算机系','外语系')&quot;).list();
//取出1. for 增强
for(Student s:list){
  System.out.println(s.getSname()+&quot; &quot;+s.getSaddress()+&quot; &quot;+s.getSdept());
}
</code></pre>
<h2 id="group-by使用">group by使用</h2>
<pre><code>//显示各个系的学生的平均年龄
List&lt;Object[]&gt; list=session.createQuery(&quot;select avg(sage),sdept from  Student group by sdept&quot;).list();
  //取出1. for 增强
  for(Object[] obj:list){
    System.out.println(obj[0].toString()+&quot; &quot;+obj[1].toString());
}
</code></pre>
<h2 id="having的使用">having的使用</h2>
<pre><code>//1.对分组查询后的结果，进行筛选:比如请显示人数大于3的系名称
//a. 查询各个系分别有多少学生.
List&lt;Object[]&gt; list=session.createQuery(&quot;select count(*) as c1,sdept from  Student group by sdept having count(*)&gt;3&quot;).list();
//取出1. for 增强
for(Object[] obj:list){
  System.out.println(obj[0].toString()+&quot; &quot;+obj[1].toString());
}
//2查询女生少于200人的系
//a.查询各个系的女生有多个个
List&lt;Object[]&gt; list=session. createQuery(&quot;select count(*) as c1,sdept from  Student where ssex='F' group by sdept&quot;).list();
//取出1. for 增强
for(Object[] obj:list){
  System.out.println(obj[0].toString()+&quot; &quot;+obj[1].toString());
}
//1.查询计算机系共多少人?-&gt;如果我们返回的是一列数据
//这时我们的取法是直接取出list-&gt;object 而不是 list-&gt;Object[]
List&lt;Object[]&gt; list=session.createQuery(&quot;select sage from  Student where sdept='计算机系'&quot;).list();
//取出1. for 增强
for(Object obj:list){
  System.out.println(obj.toString());
}
//3.查询选修11号课程的最高分和最低分.
List&lt;Object[]&gt; list=session.
createQuery(&quot;select 11,max(grade),min(grade) from Studcourse where course.cid=11&quot;).list();
//取出1. for 增强
for(Object[] obj:list){
  System.out.println(obj[0].toString()+&quot; max=&quot;+obj[1].toString()+&quot; min=&quot;+obj[2].toString());
}
//4.计算各个科目不及格的学生数量.
List&lt;Object[]&gt; list=session. createQuery(&quot;select count(*),student.sdept from StudCourse where grade&lt;60 group by student.sdept&quot;).list();
//取出1. for 增强
for(Object[] obj:list){
  System.out.println(obj[0].toString()+&quot; &quot;+obj[1].toString());
}
</code></pre>
<h2 id="分页显示对象">分页显示对象：</h2>
<p>　　根据用户输入的pageNow和pageSize现实对象</p>
<pre><code>Query query = session.createQuery(hql);
query.setFirdtRequest(从第几条取//从0开始计算);
query.setMaxRequest(取出几条);
List list = query.list();
//list就是结果
query = session.createQuery(得到count(*)的查询语句);
int pageRow = (Integer)query.list().get(0).intValue();
</code></pre>
<h3 id="参数绑定">参数绑定</h3>
<p>　　可以用setParameter()方法来确定变量的值：</p>
<pre><code>Query query = session.createQuery(&quot;from Student where sdept = :dept and sage&gt;:age&quot;);
query.setParameter(参数名，值);
</code></pre>
<p>使用绑定参数的好处：</p>
<ul>
<li>可读性好</li>
<li>性能提高</li>
<li>防止SQL注入（where 1=1）</li>
</ul>
<p>提示：也可以使用setInteger().setString()…来指定值.</p>
<p>另外：hql语句也可以用“?”来指定带绑定的参数.</p>
<pre><code>Query query = session.createQuery(“from Student where sdept = ? and sage&gt;?”);
query.setParameter(0，值);
query.setParameter(1，值);
</code></pre>
<h2 id="在映射文件中得到hql语句">在映射文件中得到hql语句</h2>
<p>　　可以从某些映射文件中得到hql语句，执行查询语句，这样可以更加灵活，在某种情况下，可以考虑使用. 比如：在Student.hbm.xml中.</p>
<pre><code>&lt;query name=”myquerytest”&gt;
&lt;![CDATA[select sname,ssex from Student where sage&gt;22]]&gt;
&lt;/query&gt;
如何使用：
List list = session.getNameQuery(“myQuerytest”).lise();
  System.out.println(list.size());
Iterator iterator = list.iterator();
while(iterator.hasNext()){
  Object obj[] = (Object[])iterator.next();
  System.out.println(“N=”+obj[0]);
}
</code></pre>
<h2 id="使用子查询">使用子查询</h2>
<h3 id="hibernate中的对象存在三种关系">hibernate中的对象存在三种关系</h3>
<ol>
<li>one-to-one：身份证←→人</li>
<li>one-to-many【many-to-one】部门←→员工</li>
<li>many-to-many：老师←→学生（尽量化简）
实际开发中，如果出现了many-to-many关系，用将其装换成两个one-to-many或者many-to-one，这样程序好控制，同时不会冗余.</li>
</ol>
<p>criterial使用:</p>
<pre><code>//查询年龄大于10岁的学生 criteria
Session s=HibernateUtil.getCurrentSession();
Transaction tx=s.beginTransaction();
Criteria cri=s.createCriteria(Student.class);
//添加检索条件
cri.add(Restrictions.gt(&quot;sage&quot;, new Long(10)));
List&lt;Student&gt; list=cri.list();
for(Student s1: list){
  System.out.println(s1.getSname());
}
tx.commit();      
</code></pre>
<h2 id="hibernate开发的三种方式中的">hibernate开发的三种方式中的</h2>
<p>　　编写domain object + 映射文件 &mdash;&mdash;&gt; 创建出对应的数据库,这里我们说明如果要自动的创建出对应的数据库，需要做配置(hibernate.cfg.xml).</p>
<pre><code>&lt;property name=&quot;hbm2ddl.auto&quot;&gt;create&lt;/property&gt;
</code></pre>
<p>这里有四个配置值: create , update , create-drop, validate</p>
<ul>
<li>create:当我们的应用程序加载hibernate.cfg.xml[new Configuration().config();]就会根据映射文件，创建出数据库, 每次都会重新创建， 原来表中的数据就没有!!!</li>
<li>update: 如果数据库中没有该表，则创建，如果有表，则看有没有变化，如果有变化，则更新.</li>
<li>create-drop: 在显示关闭 sessionFactory时，将drop掉数据库的schema</li>
<li>validate: 相当于每次插入数据之前都会验证数据库中的表结构和hbm文件的结构是否一致</li>
</ul>
<p>　　在开发测试中，我们配置哪个都可以测试，但是如果项目发布后，最好自己配置一次，让对应的数据库生成，完后取消配置.</p>
<p>domain对象的细节:</p>
<ol>
<li>需要一个无参的构造函数(用于hibernate反射该对象)</li>
<li>应当有一个无业务逻辑的主键属性.</li>
<li>给每个属性提供 get/set方法.</li>
<li>在domian对象中的属性，只有配置到了对象映射文件xxx.hbm.xml后，才会被hiberante管理.</li>
<li>属性一般是private范围</li>
</ol>
<p>对象关系映射文件的说明：</p>
<p>　　对象关系文件中，有些属性是可以不配，hibernate会采用默认机制，比如<code>&lt;class table=&quot;?&quot; &gt;</code> table 值不配，则以类的小写做表名；<code>&lt;property type=&quot;?&quot;&gt; </code>type不配置，则hibernate会根据类的属性类型，选择一个适当的类型.</p>
<p>Hibernate的三种状态：</p>
<ol>
<li>瞬时态：对象刚刚被创建，没有处于session的管理下，同时在数据库没有记录；</li>
<li>持久态：既处于session的管理下，同时又被保存到数据库中（在数据库中有记录）；</li>
<li>脱管/游离态：没有在session管理下，但在数据库中有记录.
<img src="./15.png" alt="png">
<b>如何判断一个对象处于怎样的状态？</b></li>
</ol>
<p>主要的依据是:</p>
<ol>
<li>看该对象是否处于session管理；</li>
<li>看在数据库中有没有对应的记录.</li>
</ol>
<ul>
<li>
<p>瞬时态: 没有session管理,同时数据库没有对应记录;new了一个对象，此时对象就是瞬时态;瞬时态对象和数据库记录没有对关系，和session没有关系.</p>
</li>
<li>
<p>持久态: 有session管理，同时在数据库中有记录; 瞬时态对象执行save变化持久层;持久态对象和数据库记录存在对应关系，和session有关系.修改对象的属性，直接将数据保证到数据库.</p>
</li>
<li>
<p>管态/游离态： 没有session管理，但是在数据库中有记录.当session关闭后，持久态对象变为托管态;	托管态对象和session没有关系，可能和数据库存在对象也可能不对应.</p>
</li>
</ul>
<p>托管态和瞬时态区别</p>
<ol>
<li>托管态对象:	和session没有关联，可能和数据库存在对应关系，托管态对象中存在主键的值.</li>
<li>持久态对象:	和session有状态</li>
<li>瞬时态对象:	和session没有关联，和数据库记录没有对象关系，没有主键.</li>
</ol>
<p>将瞬时态对象设置一个主键值，它就变为了托管态对象！！！</p>
<h3 id="saveorupdate方法测试">saveOrUpdate方法测试：</h3>
<ol>
<li>对瞬时态对象执行insert操作</li>
<li>对持久态对象执行update操作</li>
<li>对托管态对象执行update操作</li>
</ol>
<h2 id="懒加载">懒加载:</h2>
<p>　　简述: 当我们查询一个对象的时候，在默认情况下,返回的只是该对象的普通属性（直接属性，不需要通过外键等查询得到）,当用户去使用对象属性时，才会向数据库发出再一次的查询.这种现象我们称为 lazy现象.
解决方法可以这样:</p>
<ol>
<li>显示初始化代理对象： Hibernate.initized(student.getDepart())；与直接属性相连的对象.</li>
<li>修改对象关系文件 lazy  改写 lazy=false（说明：不要再one-to-many的one中设置false，在many中设置可以提高效率）
以上两种方法 不能直接解决懒加载问题.</li>
<li>通过过滤器(web项目) openSessionInView
添加一个过滤器</li>
</ol>
<h3 id="懒加载详解">懒加载详解：</h3>
<p>　　懒加载（Load On Demand）是一种独特而又强大的数据获取方法，是指程序推迟访问数据库，这样可以保证有时候不必要的访问数据库，因为一次访问数据库是比较耗时的.
懒加载的几种情况：
首先明确一点：Domain Object是非finally的，才能实现懒加载. 解决方法：（因为要重写集合Set…）</p>
<ol>
<li>明确初始化
在session还没有关闭时，访问一次xxx.getXxx()，强制访问数据库. 或者Hibernate.initialize(xxx)；</li>
<li>openSessionView
这个往往需要过滤器配合使用(web程序)；</li>
<li>在ssh中，可以实现在service层，标准方式解决懒加载；</li>
<li>在映射文件中配置，lazy=false.</li>
</ol>
<h2 id="hibernate的关系映射">Hibernate的关系映射：</h2>
<h3 id="mang-to-one">mang-to-one：</h3>
<pre><code>&lt;!-- 对于private Department depart就不能用property many-to-one 的name=“变量名” column name=“将来生成表的名” --&gt;
&lt;many-to-one name=&quot;depart&quot;&gt;
  &lt;column name=&quot;depart_id&quot;&gt;&lt;/column&gt;
&lt;/many-to-one&gt;
</code></pre>
<p><img src="./16.png" alt="png"></p>
<h3 id="one-to-many">one-to-many</h3>
<p>需求：查询所有一号部门的学生.</p>
<p>常规思维：<code>String hql = “from Student where dept.id=1”</code>;</p>
<p>还可以采用一对多：</p>
<ol>
<li>现在Department中添加一个Set集合，并生成get/set方法；
private Set<Student> stu;//一个部门可以对应多个学生</li>
<li>在Department.hbm.xml文件中添加</li>
</ol>
<pre><code>&lt;set name=“集合对象属性名”&gt;
  &lt;key column=“外键名”&gt;
  &lt;one-to-many class=“集合存放的类名”&gt;
&lt;/set&gt;
&lt;!-- 配置onne-to-many关系 --&gt;
  &lt;set name=“stus” cascade=“联级”&gt;
  &lt;key column=“depart_id”&gt;
  &lt;one-to-many class=“Student”&gt;
</code></pre>
<h3 id="one-to-one">one-to-one</h3>
<p>一对一有两种方式：</p>
<ol>
<li>基于主键的一对一:</li>
</ol>
<ul>
<li>主键关联映射：其中一个表的主键依赖于另一张表的主键而建立起的一对一的关系，这两张互相关联的表的主键一致.</li>
<li>必须为one-to-one元素增加constrained=&ldquo;true&quot;属性，表明该类的主键由关联类生成.</li>
</ul>
<p><b>【要点】</b>Person - IdCard</p>
<p><img src="./17.png" alt="png">
<img src="./18.png" alt="png"></p>
<pre><code>&lt;id name=”id”&gt;
&lt;generator class=”foreign”&gt;
&lt;param name=”property”&gt;idCard&lt;/param&gt;
&lt;/generator&gt;
&lt;/id&gt;
&lt;one-to-one name=”idCard” constrained=”true”/&gt;
</code></pre>
<ol start="2">
<li>基于外键的一对一
和<many-to-one>N-1相同，多添加一个unique=&ldquo;true&rdquo; 属性，用以表示N的一端必须唯一，加了唯一约束，即成了1-1</li>
</ol>
<p><b>【举例】</b></p>
<pre><code>&lt;one-to-one name=”idCard” property-ref=“person”/&gt;             
&lt;many-to-one name=”person” unique=”true” /&gt;
# property-ref：用于指定关联类的一个属性，这个属性将会和本外键相对应
</code></pre>
<h3 id="many-to-many">many-to-many</h3>
<p>　　学生←→课程   顾客←→商品
student:one-to-mangy
<img src="./19.png" alt="png"></p>
<pre><code>class Student{
  private Integer id;
  private String name;
  private Set&lt;StuCourse&gt; stuCourses;
}
</code></pre>
<p>从stucourse的角度看是 many-to-one
<img src="./20.png" alt="png"></p>
<pre><code>class StuCourse{
  private Integer id;
  private Student student;
  private Course course;
  private Integer grade;
}
</code></pre>
<p>courset:one-to-mangy
<img src="./21.png" alt="png"></p>
<pre><code>class Course{
  private Integer id;
  private String name;
  private Set&lt;StuCourse&gt; stuCourses;
}
</code></pre>
<h3 id="cascadeemployee-departmentbbs项目等">cascade（Employee-Department、bbs项目等）</h3>
<p>所谓级联操作就是说，当进行某个操作（添加/删除/修改…），就有hibernate自动完成. 例如：Department←→Employee当某个部门被删除后，员工也不会存在. 常用的cascade：none、all、save-update、delete、lock、refresh、evict、replic、persist、merge、delete-orphan(one-to-many). 一般对many-to-many，many-to-one不设置联级，在one-to-many和one-to-one中设置联级.</p>
<h3 id="在jsp页面中获取项目名称">在JSP页面中获取项目名称：</h3>
<pre><code>&lt;%=this.getServletContext().getContextPath()%&gt; //java片段
${ pageContext.request.contextPath } //通过标签
</code></pre>
<h2 id="缓存">缓存</h2>
<p>　　缓存的作用主要用来提高性能，可以简单的理解成一个Map；使缓存涉及到三个操作：把数据放入缓存、从缓存获取数据、删除缓存中的无效数据.</p>
<h3 id="一级缓存session级共享">一级缓存（Session级共享）</h3>
<p>一级缓存是 session对象中一块内存.
在同一个session中，查询一个对象是不会发出sql语句.
session关闭一级缓存不存在了，再查询对象，会发出sql.</p>
<p>save，update，saveOrUpdate，load，get，list，iterator，lock这些方法都会将对象放在一级缓存中，一级缓存不能控制缓存的数量，所以要注意将大批量操作数据时可能造成内存溢出；可以用evict(清楚一个对象)，clear(清除所有对象)方法清除缓存的内容.
用HashMap来模拟一个Session缓存，加深对缓存的深入.</p>
<pre><code>package com.hsp.view;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
public class MyCache {
  //使用map来模拟缓存
  static Map&lt;Integer,Student&gt; maps=new HashMap&lt;Integer,Student&gt;();
  public static void main(String[] args) {
    // TODO Auto-generated method stub

    getStudent(1);
    getStudent(1);
    getStudent(1);
    getStudent(1);
    getStudent(3);
    getStudent(3);
  }

  public static Student getStudent(Integer id){  //s.get()
    //先到缓存去
    if(maps.containsKey(id)){
      //在缓存有
      System.out.println(&quot;从缓存取出&quot;);
      return maps.get(id);
    }else{
      System.out.println(&quot;从数据库中取&quot;);
      //到数据库取
      Student stu=MyDB.getStudentFromDB(id);
      //放入缓存
      maps.put(id, stu);
      return stu;
    }
  }
}

//我的数据库
class MyDB{	
  static List&lt;Student&gt; lists=new  ArrayList&lt;Student&gt;();
  //初始化数据库,假设有三个学生
  static{
    Student s1=new Student();
    s1.setId(1);
    s1.setName(&quot;aaa&quot;);
    Student s2=new Student();
    s2.setId(2);
    s2.setName(&quot;bbb&quot;);
    Student s3=new Student();
    s3.setId(3);
    s3.setName(&quot;ccc&quot;);
    lists.add(s1);
    lists.add(s2);
    lists.add(s3);
  }
  public static Student getStudentFromDB(Integer id){
    for(Student s: lists){
      if(s.getId().equals(id)){
        return s;
      }
    }
    return null;// 在数据库中没有.
  }
}

class Student{
  private Integer id;
  private String name;
  public Integer getId() {
    return id;
  }
  public void setId(Integer id) {
    this.id = id;
  }
  public String getName() {
    return name;
  }
  public void setName(String name) {
    this.name = name;
  }
}
</code></pre>
<h3 id="二级缓存sessionfactory级共享">二级缓存（SessionFactory级共享）</h3>
<p><b>为什么需要二级缓存?</b></p>
<p>　　因为一级缓存有限(生命周期短),所以我们需要二级缓存(SessionFactory缓存)来弥补这个问题</p>
<ol>
<li>需要配置</li>
<li>二级缓存是交给第三方去处理,常见的Hashtable , OSCache , EHCache</li>
<li>二级缓存的原理；</li>
<li>二级缓存的对象可能放在内存，也可能放在磁盘.</li>
</ol>
<p>使用OsCache来演示二级缓存的使用.</p>
<ol>
<li>配置二级缓存</li>
</ol>
<p>对配置说明:</p>
<pre><code>&lt;property name=&quot;hbm2ddl.auto&quot;&gt;update&lt;/property&gt;
  &lt;!-- 启动二级缓存 --&gt;
  &lt;property name=&quot;cache.use_second_level_cache&quot;&gt;true&lt;/property&gt;
  &lt;!-- 指定使用哪种二级缓存 --&gt;
  &lt;property name=&quot;cache.provider_class&quot;&gt;org.hibernate.cache.OSCacheProvider&lt;/property&gt;
  &lt;mapping resource=&quot;com/hsp/domain/Department.hbm.xml&quot; /&gt;
  &lt;mapping resource=&quot;com/hsp/domain/Student.hbm.xml&quot; /&gt;
  &lt;!-- 指定哪个domain启用二级缓存 
  特别说明二级缓存策略:
  1. read-only
  2. read-write
  3. nonstrict-read-write
  4. transcational
  --&gt;
  &lt;class-cache class=&quot;com.hsp.domain.Student&quot; usage=&quot;read-write&quot;/&gt;
</code></pre>
<ol start="2">
<li>可以把oscache.properties文件放在 src目录下，这样你可以指定放入二级缓存的对象capacity 大小. 默认1000.</li>
<li>使用</li>
</ol>
<pre><code>// TODO Auto-generated method stub
//通过获取一个sesion,让hibernate框架运行(config-&gt;加载hibernate.cfg.xml)
Session s=null;
Transaction tx=null;		
try {
//我们使用基础模板来讲解.
s=HibernateUtil.openSession();
tx=s.beginTransaction();			
//查询45号学生		
Student stu1=(Student) s.get(Student.class, 45);//45-&gt;一级缓存		System.out.println(stu1.getName());
tx.commit();			
} catch (Exception e) {
  e.printStackTrace();
  if(tx!=null){
    tx.rollback();
  }
}finally{			
  if(s!=null &amp;&amp; s.isOpen()){
    s.close();
  }
}		
System.out.println(&quot;*********************************&quot;);
try {
  //我们使用基础模板来讲解.
  s=HibernateUtil.openSession();
  tx=s.beginTransaction();			
  //查询45号学生		
  Student stu1=(Student) s.get(Student.class, 45);	
  System.out.println(stu1.getName());			
  Student stu3=(Student) s.get(Student.class, 46);	
  System.out.println(stu3.getName());
    tx.commit();			
} catch (Exception e) {
  e.printStackTrace();
  if(tx!=null){
    tx.rollback();
  }
}finally{
  
  if(s!=null &amp;&amp; s.isOpen()){
    s.close();
  }
}

//完成一个统计，统计的信息在Sessfactory
//SessionFactory对象.
Statistics statistics= HibernateUtil.getSessionFactory().getStatistics();
System.out.println(statistics);
System.out.println(&quot;放入&quot;+statistics.getSecondLevelCachePutCount());
System.out.println(&quot;命中&quot;+statistics.getSecondLevelCacheHitCount());
System.out.println(&quot;错过&quot;+statistics.getSecondLevelCacheMissCount());
</code></pre>
<ol start="4">
<li>在配置了二级缓存后，请大家要注意可以通过 Statistics,查看你的配置命中率高不高.</li>
</ol>
<h2 id="事务管理">事务管理</h2>
<ol>
<li>在hibernate设置隔离级别
在hibernate.cfg.xml中设置隔离级别：</li>
</ol>
<pre><code>&lt;!-- 事务隔离级别 --&gt;
&lt;property name=&quot;hibernate.connection.isolation&quot;&gt;4&lt;/property&gt;
</code></pre>
<ol start="2">
<li>事务控制在哪里进行？</li>
</ol>
<pre><code>service(){
  session.beginTransaction;//开启事务
  try{
  调用dao方法1
  调用dao方法2
  .....
    session.getTransaction().commit();//提交事务
  }catch(Exception ex){
    session.getTransaction().rollback();//回滚事务
  }
}
</code></pre>
<h3 id="session如何管理">session如何管理</h3>
<p>　　在service接口中，每个dao请求中使用同一个session即使用同一个数据库连接，保证多个dao调用在一个事务中. 在service执行开始处开启一个新session，将session和当前线程绑定，在每个dao调用中获取当前线程绑定的session，实现每个dao获取到的session是同一个session.
<img src="./23.png" alt="png"></p>
<h2 id="主键增长策略">主键增长策略</h2>
<ol>
<li>increment:
自增，每次增长1, 适用于所有数据库. 但是不要使用在多进程,主键类型是数值型 select max(id) from Student</li>
<li>identity :
自增，每次增长1, 适用于支持identity的数据(mysql,sql server), 主键类型是数值</li>
<li>sequence</li>
<li>native:会根据数据类型来选择，使用identity,sequence ,hilo select hibernate_sequence.nextval from dual.主键类型是数值long , short ,int</li>
</ol>
<pre><code>&lt;id name=&quot;id&quot; type=&quot;java.lang.Integer&quot;&gt; 
&lt;generator class=&quot;native&quot;/&gt;
&lt;/id&gt;
</code></pre>
<ol start="5">
<li>hilo:hilo标识符生成器由Hibernate按照一种high/low算法生成标识符.</li>
</ol>
<p><b>用法:</b></p>
<pre><code>&lt;id name=”id” type=”java.lang.Integer” column=”ID”&gt;
&lt;generator class=”hilo”&gt;
  &lt;param name=”table”&gt;my_hi_value&lt;/param&gt;
  &lt;param name=”column”&gt;next_value&lt;/param&gt;
&lt;/generator&gt;
&lt;/id&gt;
</code></pre>
<ol start="6">
<li>uuid:
会根据uuid算法，生成128-bit的字串
主键属性类型不能是数值型，而是字串型</li>
<li>assigned:
用户自己设置主键值，所以主键属性类型可以是数值，字串</li>
<li>映射复合主键</li>
<li>foreign:
在one-to-one的关系中，有另一张表的主键(Person) 来决定 自己主键/外键( IdCard)</li>
</ol>
<p><em>给出一个简单原则:</em></p>
<ul>
<li>针对oracle [主键是int/long/short 建议使用 sequence] 主键是String 使用uuid或者assinged</li>
<li>针对 mysql [主键是 int/long/short 建议使用increment/assigend ,如果是字串 UUId/assigned]</li>
<li>针对 sql server [主键是 int/long/short 建议使用identity/native/assinged ,如果主键是字串，使用uuid/assigned ]</li>
<li>one-to-one 又是基于主键的则使用foreign</li>
</ul>
<h2 id="hibernate不适合的场景">Hibernate不适合的场景</h2>
<p>　　不适合OLAP（On-Line-Analytical Processing联机分析处理），已查询分析数据为主流的系统，适合OLTP（On-line transaction Processing联机事务处理）</p>
<table>
<thead>
<tr>
<th></th>
<th>OLTP</th>
<th>OLAP</th>
</tr>
</thead>
<tbody>
<tr>
<td>用户</td>
<td>操作人员，底层管理人员</td>
<td>决策人员，高级管理人员</td>
</tr>
<tr>
<td>功能</td>
<td>日常操作管理</td>
<td>分析决策</td>
</tr>
<tr>
<td>DB设计</td>
<td>面向应用</td>
<td>面向主题</td>
</tr>
<tr>
<td>数据</td>
<td>当前的，最新的，细节的，二维的分立的</td>
<td>历史的、聚集的、多维的集成的，统一的</td>
</tr>
<tr>
<td>存取</td>
<td>读/写数十条记录</td>
<td>读/写上百万 条记录</td>
</tr>
<tr>
<td>工作单位</td>
<td>简单事务</td>
<td>复杂查询</td>
</tr>
<tr>
<td>用户</td>
<td>上千个</td>
<td>上百个</td>
</tr>
<tr>
<td>DB大小</td>
<td>100M-GB</td>
<td>100GB-TB</td>
</tr>
</tbody>
</table>

    </div>

    






<div class="article-tags">
  
  <a class="badge badge-light" href="/tag/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>
  
  <a class="badge badge-light" href="/tag/java/">Java</a>
  
  <a class="badge badge-light" href="/tag/hibernate/">Hibernate</a>
  
</div>













  
  
    



  
  
  
    
  
  
  
  <div class="media author-card content-widget-hr">
    
      
      <a href="https://CoMath21.github.io/"><img class="avatar mr-3 avatar-circle" src="/authors/admin/avatar_hu229ab2ae4b832f0d41c08e3dce763b22_681268_270x270_fill_q75_lanczos_center.jpg" alt="Xin态好先生"></a>
    

    <div class="media-body">
      <h5 class="card-title"><a href="https://CoMath21.github.io/">Xin态好先生</a></h5>
      
      <p class="card-text">机会是给有准备的人的.</p>
      <ul class="network-icon" aria-hidden="true">
  
    
    
    
      
    
    
    
    
    
    <li>
      <a href="mailto:comath@qq.com" >
        <i class="fas fa-envelope"></i>
      </a>
    </li>
  
    
    
    
      
    
    
    
    
    
      
    
    <li>
      <a href="http://wpa.qq.com/msgrd?v=3&amp;uin=1375264022&amp;site=qq&amp;menu=yes" target="_blank" rel="noopener">
        <i class="fab fa-qq"></i>
      </a>
    </li>
  
    
    
    
      
    
    
    
    
    
      
    
    <li>
      <a href="https://github.com/CoMath21" target="_blank" rel="noopener">
        <i class="fab fa-github"></i>
      </a>
    </li>
  
    
    
    
      
    
    
    
    
    
      
    
    <li>
      <a href="/" >
        <i class="fas fa-graduation-cap"></i>
      </a>
    </li>
  
</ul>

    </div>
  </div>


  
    



  
  
  
    
  
  
  
  <div class="media author-card content-widget-hr">
    
      
      <a href="https://CoMath21.github.io/"><img class="avatar mr-3 avatar-circle" src="/authors/comath/avatar_hu5dbed3c1e225bfb246e59dc7d66e77de_260503_270x270_fill_lanczos_center_2.png" alt="CoMath"></a>
    

    <div class="media-body">
      <h5 class="card-title"><a href="https://CoMath21.github.io/">CoMath</a></h5>
      <h6 class="card-subtitle">微信公众号</h6>
      
      <ul class="network-icon" aria-hidden="true">
  
</ul>

    </div>
  </div>


  














  
  
  <div class="article-widget content-widget-hr">
    <h3>相关</h3>
    <ul>
      
      <li><a href="/post/1-struts2/">Struts2学习笔记</a></li>
      
      <li><a href="/post/1-spring2.5/">Spring2.5学习笔记</a></li>
      
      <li><a href="/post/0-python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%904/">Python数据分析（四）</a></li>
      
      <li><a href="/post/0-python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%903/">Python数据分析（三）</a></li>
      
      <li><a href="/post/0-python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%902/">Python数据分析（二）</a></li>
      
    </ul>
  </div>
  





  </div>
</article>
  </div>

  <div class="page-footer">
    
    
    <div class="container">
      <footer class="site-footer">
  

  <p class="powered-by">
    © 2021 CoMath Powered by Hugo Theme Academic
  </p>

  
  






  <p class="powered-by">
    
    
    
    Published with
    <a href="https://wowchemy.com/?utm_campaign=poweredby" target="_blank" rel="noopener">Wowchemy</a>  —
    the free, <a href="https://github.com/wowchemy/wowchemy-hugo-modules" target="_blank" rel="noopener">
    open source</a> website builder that empowers creators.
    
  </p>
</footer>

    </div>
    
  </div>

  
<div id="modal" class="modal fade" role="dialog">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">引用</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
        <pre><code class="tex hljs"></code></pre>
      </div>
      <div class="modal-footer">
        <a class="btn btn-outline-primary my-1 js-copy-cite" href="#" target="_blank">
          <i class="fas fa-copy"></i> 复制
        </a>
        <a class="btn btn-outline-primary my-1 js-download-cite" href="#" target="_blank">
          <i class="fas fa-download"></i> 下载
        </a>
        <div id="modal-error"></div>
      </div>
    </div>
  </div>
</div>

      

    
    
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>

      
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.4/imagesloaded.pkgd.min.js" integrity="sha256-lqvxZrPLtfffUl2G/e7szqSvPBILGbwmsGE1MKlOi0Q=" crossorigin="anonymous"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.6/isotope.pkgd.min.js" integrity="sha256-CBrpuqrMhXwcLLUd5tvQ4euBHCdh7wGlDfNz8vbu/iI=" crossorigin="anonymous"></script>
      

      <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/instant.page/5.1.0/instantpage.min.js" integrity="sha512-1+qUtKoh9XZW7j+6LhRMAyOrgSQKenQ4mluTR+cvxXjP1Z54RxZuzstR/H9kgPXQsVB8IW7DMDFUJpzLjvhGSQ==" crossorigin="anonymous"></script>

      

      
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/highlight.min.js" integrity="sha512-TDKKr+IvoqZnPzc3l35hdjpHD0m+b2EC2SrLEgKDRWpxf2rFCxemkgvJ5kfU48ip+Y+m2XVKyOCD85ybtlZDmw==" crossorigin="anonymous"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/r.min.js"></script>
        
      

    

    
    

    
    
    <script>const code_highlighting = true;</script>
    

    
    
    
    
    
    
    <script>
      const search_config = {"indexURI":"/index.json","minLength":1,"threshold":0.3};
      const i18n = {"no_results":"没有找到结果","placeholder":"搜索...","results":"搜索结果"};
      const content_type = {
        'post': "文章",
        'project': "项目",
        'publication' : "出版物",
        'event' : "演讲",
        'slides' : "Slides"
        };
    </script>
    

    
    

    
    
    <script id="search-hit-fuse-template" type="text/x-template">
      <div class="search-hit" id="summary-{{key}}">
      <div class="search-hit-content">
        <div class="search-hit-name">
          <a href="{{relpermalink}}">{{title}}</a>
          <div class="article-metadata search-hit-type">{{type}}</div>
          <p class="search-hit-description">{{snippet}}</p>
        </div>
      </div>
      </div>
    </script>
    

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.1/fuse.min.js" integrity="sha256-VzgmKYmhsGNNN4Ph1kMW+BjoYJM2jV5i4IlFoeZA9XI=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js" integrity="sha256-4HLtjeVgH0eIB3aZ9mLYF6E8oU5chNdjU6p6rrXpl9U=" crossorigin="anonymous"></script>
    

    
    

    
    
    

    
    

    
    

    
    
    
    
    
    
    
    
    
    
      
      
    
    
    <script src="/js/wowchemy.min.aeecf26c1eff6b9588dbafc1a9f3953c.js"></script>

    






</body>
</html>
