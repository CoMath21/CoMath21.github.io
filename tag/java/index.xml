<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java | CoMath</title>
    <link>https://CoMath21.github.io/tag/java/</link>
      <atom:link href="https://CoMath21.github.io/tag/java/index.xml" rel="self" type="application/rss+xml" />
    <description>Java</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh-Hans</language><copyright>© 2021 CoMath Powered by Hugo Theme Academic</copyright><lastBuildDate>Sun, 31 Jan 2021 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://CoMath21.github.io/images/logo_hud8da91bfe93f3d7d35fd2296e35ef0bf_39934_300x300_fit_lanczos_2.png</url>
      <title>Java</title>
      <link>https://CoMath21.github.io/tag/java/</link>
    </image>
    
    <item>
      <title>SSH框架整合基本步骤</title>
      <link>https://CoMath21.github.io/post/1-ssh%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88/</link>
      <pubDate>Sun, 31 Jan 2021 00:00:00 +0000</pubDate>
      <guid>https://CoMath21.github.io/post/1-ssh%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88/</guid>
      <description>&lt;h2 id=&#34;准备工作&#34;&gt;准备工作&lt;/h2&gt;
&lt;p&gt;　　首先需要找到开发软件：Eclipse-J2EE版本，并且安装相应插件（最好安装，便于初期简单编程）.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：云盘中一个压缩包中有完整软件.&lt;/p&gt;
&lt;p&gt;安装插件步骤：
打开Eclipse-J2EE版本，找到Help→Install New SoftWare → Work with右面的Add ，在Archive…中找到对应软件的路径，点集OK即可.
需要的软件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;hibernate的插件：hibernatetools-Update-4.1.1.Final_2013-12-08_01-06-33-B605.zip&lt;/li&gt;
&lt;li&gt;Spring的插件：springsource-tool-suite-3.4.0.RELEASE-e4.3.1-updatesite.zip&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果没有服务器，需要安装Tomcat服务器.&lt;/p&gt;
&lt;h2 id=&#34;springhibernatestruts的顺序整合框架&#34;&gt;Spring→Hibernate→Struts的顺序整合框架&lt;/h2&gt;
&lt;h3 id=&#34;1-加入spring&#34;&gt;1. 加入Spring&lt;/h3&gt;
&lt;h4 id=&#34;1加入-spring-所需要的-jar-包文件&#34;&gt;1)	加入 Spring 所需要的 Jar 包文件&lt;/h4&gt;
&lt;p&gt;　　找到 Spring 的 jar 包文件夹，\Jar包文件\Spring4.0.0\spring-framework-4.0.0.RELEASE\required，大约15个左右；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;com.springsource.net.sf.cglib-2.2.0.jar&lt;/li&gt;
&lt;li&gt;com.springsource.org.aopalliance-1.0.0.jar&lt;/li&gt;
&lt;li&gt;com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar&lt;/li&gt;
&lt;li&gt;commons-logging-1.2.jar&lt;/li&gt;
&lt;li&gt;spring-aop-4.0.0.RELEASE.jar&lt;/li&gt;
&lt;li&gt;spring-aspects-4.0.0.RELEASE.jar&lt;/li&gt;
&lt;li&gt;spring-beans-4.0.0.RELEASE.jar&lt;/li&gt;
&lt;li&gt;spring-context-4.0.0.RELEASE.jar&lt;/li&gt;
&lt;li&gt;spring-core-4.0.0.RELEASE.jar&lt;/li&gt;
&lt;li&gt;spring-expression-4.0.0.RELEASE.jar&lt;/li&gt;
&lt;li&gt;spring-jdbc-4.0.0.RELEASE.jar&lt;/li&gt;
&lt;li&gt;spring-orm-4.0.0.RELEASE.jar&lt;/li&gt;
&lt;li&gt;spring-tx-4.0.0.RELEASE.jar&lt;/li&gt;
&lt;li&gt;spring-web-4.0.0.RELEASE.jar&lt;/li&gt;
&lt;li&gt;spring-webmvc-4.0.0.RELEASE.jar&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2配置-webxml-文件&#34;&gt;2)	配置 web.xml 文件&lt;/h4&gt;
&lt;p&gt;　　配置web.xml文件可以找到ContextLoaderListener会自动生成以下代码，随后将Location改为applicationContext（Spring配置文件）的路径.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 配置  Spring 配置文件的名称和位置 --&amp;gt;
&amp;lt;context-param&amp;gt;
  &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
  &amp;lt;param-value&amp;gt;classpath:applicationContext.xml&amp;lt;/param-value&amp;gt;
&amp;lt;/context-param&amp;gt;
		
&amp;lt;!-- 启动 IOC 容器的  ServletContextListener --&amp;gt;
&amp;lt;listener&amp;gt;
&amp;lt;listener-class&amp;gt;
org.springframework.web.context.ContextLoaderListener
&amp;lt;/listener-class&amp;gt;
&amp;lt;/listener&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3加入-spring-的配置文件&#34;&gt;3)	加入 Spring 的配置文件&lt;/h4&gt;
&lt;p&gt;　　可以先创建一个资源文件conf，将资源文件放入其中（也可以直接在src下创建），在资源文件下创建一个Spring的配置文件点击右键找到Spring Bean Configuration File，输入配置文件的名字，（注意这里面的名字要与web.xml下的的配置文件的名字相同，也就是一个文件）；然后选中aop、beans、context、tx等选项，（注意这里面所选取的是最基本的，根据需要可以自行添加其他选项）；最后Finish即可.
&lt;img src=&#34;./1.png&#34; alt=&#34;png&#34;&gt;
&lt;img src=&#34;./2.png&#34; alt=&#34;png&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;2加入hibernate&#34;&gt;2.	加入Hibernate&lt;/h3&gt;
&lt;h4 id=&#34;1-建立持久化类-和其对应的-hbmxml-文件-生成对应的数据表&#34;&gt;1). 建立持久化类, 和其对应的 .hbm.xml 文件, 生成对应的数据表&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;i. 配置hibernate.cfg.xml文件：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　鼠标右键找到Hibernate Configuration File(cfg.xml)创建hibernate.cfg.xml配置文件并配置基本信息（可根据需求自行添加）.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;hibernate-configuration&amp;gt;
&amp;lt;session-factory&amp;gt;
    &amp;lt;!-- 配置基本属性 --&amp;gt;
    &amp;lt;!-- 方言 --&amp;gt;
&amp;lt;property name=&amp;quot;hibernate.dialect&amp;quot;&amp;gt;org.hibernate.dialect.SQLServer2008Dialect
&amp;lt;/property&amp;gt;
&amp;lt;property name=&amp;quot;hibernate.dialect&amp;quot;&amp;gt; org.hibernate.dialect.MySQL5InnoDBDialect&amp;lt;/property&amp;gt;

    &amp;lt;!-- 是否显示及格式化SQL --&amp;gt;
    &amp;lt;property name=&amp;quot;hibernate.show_sql&amp;quot;&amp;gt;true&amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;hibernate.format_sql&amp;quot;&amp;gt;true&amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;hibernate.temp.use_jdbc_metadata_defaults&amp;quot;&amp;gt;false&amp;lt;/property&amp;gt;  
    &amp;lt;!-- 生成数据表的策略 --&amp;gt;
    &amp;lt;property name=&amp;quot;hibernate.hbm2ddl.auto&amp;quot;&amp;gt;update&amp;lt;/property&amp;gt;
    &amp;lt;!-- 生成二级缓存 --&amp;gt;
  &amp;lt;/session-factory&amp;gt;
&amp;lt;/hibernate-configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;ii. 建立持久化类&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;　　也就是平时所说的对象类、beans（一般创建在domain包下或者entities下），并生成对应参数的getter and setter；之后鼠标右键创建Hibernate XML Mapping file (hbm.xml)文件，直接创建即可. 就会生成对应的*. hbm.xml文件（根据不同的需求可能够对*. hbm.xml文件进行适当的修改）&lt;/p&gt;
&lt;h4 id=&#34;2-spring-整合-hibernate&#34;&gt;2). Spring 整合 Hibernate&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;步骤&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;①  加入 jar 包: 找到 Hibernate 的 jar 包文件夹，\Jar包文件\Jar包文件\Hibernate4.2.21\hibernate-release-4.2.21.Final\lib\required路径下的所有 jar 包.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;antlr-2.7.7.jar&lt;/li&gt;
&lt;li&gt;dom4j-1.6.1.jar&lt;/li&gt;
&lt;li&gt;hibernate-commons-annotations-4.0.2.Final.jar&lt;/li&gt;
&lt;li&gt;hibernate-core-4.2.21.Final.jar&lt;/li&gt;
&lt;li&gt;hibernate-jpa-2.0-api-1.0.1.Final.jar&lt;/li&gt;
&lt;li&gt;javassist-3.18.1-GA.jar&lt;/li&gt;
&lt;li&gt;jboss-logging-3.1.0.GA.jar&lt;/li&gt;
&lt;li&gt;jboss-transaction-api_1.1_spec-1.0.1.Final.jar&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;②  在类路径下加入 hibernate.cfg.xml 文件，并在其中配置   hibernate 的基本属性&lt;/p&gt;
&lt;p&gt;③  建立持久化类和其对应的  .hbm.xml 文件（过）&lt;/p&gt;
&lt;p&gt;④  和 Spring 进行整合（过）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加入c3p0和SQLServer的驱动（需要引入相关jar包文件：c3p0-0.9.2.1.jar、sqljdbc4.jar（SQL2005））&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;（c3p0:是一个 数据库连接池 ，利用 sqljdbc4 建立与数据库的连接 ， 并且管理这些连接，不用每次访问数据库都 重新发出数据库连接请求；大大提升性能）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;具体实现：
首先要创建*.properties文件，并对其进行配置，主要为数据库的相关参数设置.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 资源文件样式 --&amp;gt;
  jdbc.user=sa
  jdbc.password=sa123
  jdbc.driverClass=com.microsoft.sqlserver.jdbc.SQLServerDriver
  jdbc.jdbcUrl=jdbc:sqlserver://localhost:1433; DatabaseName=PwdManagerTest

  jdbc.initialPoolSize=5
  jdbc.maxPoolSize=10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后在applicationContext.xml中添加&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 导入资源文件 --&amp;gt;
  &amp;lt;context:property-placeholder location=&amp;quot;classpath:db.properties&amp;quot; /&amp;gt;
&amp;lt;!-- 配置 C3P0 数据源 --&amp;gt;
&amp;lt;bean id=&amp;quot;dataSource&amp;quot; class=&amp;quot;com.mchange.v2.c3p0.ComboPooledDataSource&amp;quot;&amp;gt;
  &amp;lt;property name=&amp;quot;user&amp;quot; value=&amp;quot;${jdbc.user}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
  &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;${jdbc.password}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
  &amp;lt;property name=&amp;quot;driverClass&amp;quot; value=&amp;quot;${jdbc.driverClass}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
  &amp;lt;property name=&amp;quot;jdbcUrl&amp;quot; value=&amp;quot;${jdbc.jdbcUrl}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    
  &amp;lt;property name=&amp;quot;initialPoolSize&amp;quot; value=&amp;quot;${jdbc.initialPoolSize}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
  &amp;lt;property name=&amp;quot;maxPoolSize&amp;quot; value=&amp;quot;${jdbc.maxPoolSize}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;font color=red&gt;这里会报一个错误：Error creating bean with name &amp;lsquo;dataSource&amp;rsquo; defined in class path resource [applicationContext.xml]:&amp;hellip;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;错误原因&lt;/strong&gt;：缺少mchange-commons-java-0.2.3.4.jar包.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;：mchange-commons-java-0.2.3.4.jar包是c3p0数据库连接池的辅助包，如果没有这个包系统启动时会报classnotfoundexception，这是更新c3p0-0.9.2版本后分离出来的包，0.9.1的时候还是只是一个包.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方法&lt;/strong&gt;：导入mchange-commons-java-0.2.3.4.jar包即可.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;路径&lt;/strong&gt;：Jar包文件\C3P0\C3P0-0.9-2.1JAR\c3p0-0.9.2.1\lib...&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在Spring 的配置文件中配置:数据源dataSource,SessionFactory,声明式事务（先了解事务，包括事务隔离级别等）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 配置 SessionFactory --&amp;gt;
&amp;lt;bean id=&amp;quot;sessionFactory&amp;quot;					class=&amp;quot;org.springframework.orm.hibernate4.LocalSessionFactoryBean&amp;quot;&amp;gt;
  &amp;lt;property name=&amp;quot;dataSource&amp;quot; ref=&amp;quot;dataSource&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
  &amp;lt;property name=&amp;quot;configLocation&amp;quot; value=&amp;quot;classpath:hibernate.cfg.xml&amp;quot;/&amp;gt;
  &amp;lt;property name=&amp;quot;mappingLocations&amp;quot; value=&amp;quot;classpath:com/PwdManager/domain/*.hbm.xml&amp;quot; /&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;font color=blue&gt;说明：执行到当前操作即可打开服务器，运行当前项目检测，正常情况下，不会报错，没有错误信息，而且在数据库中会生成对应的表结构. &lt;/font&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 配置 Spring 的声明式事务 --&amp;gt;
&amp;lt;!-- 1. 配置 Hibernate 的事务管理器 --&amp;gt;
&amp;lt;bean id=&amp;quot;transactionManager&amp;quot; class=&amp;quot;org.springframework.orm.hibernate4.HibernateTransactionManager&amp;quot;&amp;gt;
  &amp;lt;property name=&amp;quot;sessionFactory&amp;quot; ref=&amp;quot;sessionFactory&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
      
&amp;lt;!-- 2. 配置事务属性 --&amp;gt;
&amp;lt;tx:advice id=&amp;quot;txAdvice&amp;quot; transaction-manager=&amp;quot;transactionManager&amp;quot;&amp;gt;
    &amp;lt;tx:attributes&amp;gt;
      &amp;lt;tx:method name=&amp;quot;get*&amp;quot; read-only=&amp;quot;true&amp;quot;/&amp;gt;
      &amp;lt;tx:method name=&amp;quot;*&amp;quot;/&amp;gt;
    &amp;lt;/tx:attributes&amp;gt;
&amp;lt;/tx:advice&amp;gt;
	
&amp;lt;!-- 3. 配置事务切入点,再把事务属性和事务切入点关联起来 --&amp;gt;
  &amp;lt;aop:config&amp;gt;
  &amp;lt;!-- 任一修饰符,任意返回值 ..下的所有类下的所有方法,参数值任意--&amp;gt;
  &amp;lt;aop:pointcut expression=&amp;quot;execution(* com.PwdManager.service.*.*(..))&amp;quot; id=&amp;quot;txPointcut&amp;quot;/&amp;gt;
  &amp;lt;!-- 把事务属性和事务切入点关联起来 --&amp;gt;
  &amp;lt;aop:advisor advice-ref=&amp;quot;txAdvice&amp;quot; pointcut-ref=&amp;quot;txPointcut&amp;quot;/&amp;gt;
&amp;lt;/aop:config&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-加入-stuts2&#34;&gt;3. 加入 Stuts2&lt;/h3&gt;
&lt;h4 id=&#34;1-加入--jar-包&#34;&gt;1) 加入  jar 包&lt;/h4&gt;
&lt;p&gt;　　找到 Stuts2 的 jar 包文件夹，\Jar包文件 \Jar包文件\Struts2.3.34\struts-2.3.34\apps\struts2-blank\WEB-INF\lib路径下的所有 jar 包.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;xwork-core-2.3.34.jar&lt;/li&gt;
&lt;li&gt;struts2-spring-plugin-2.3.34.jar&lt;/li&gt;
&lt;li&gt;struts2-json-plugin-2.3.34.jar&lt;/li&gt;
&lt;li&gt;struts2-core-2.3.34.jar&lt;/li&gt;
&lt;li&gt;ognl-3.0.21.jar&lt;/li&gt;
&lt;li&gt;log4j-core-2.3.jar&lt;/li&gt;
&lt;li&gt;log4j-api-2.3.jar&lt;/li&gt;
&lt;li&gt;javassist-3.11.0.GA.jar&lt;/li&gt;
&lt;li&gt;freemarker-2.3.22.jar&lt;/li&gt;
&lt;li&gt;commons-lang3-3.2.jar&lt;/li&gt;
&lt;li&gt;commons-io-2.2.jar&lt;/li&gt;
&lt;li&gt;commons-fileupload-1.3.2.jar&lt;/li&gt;
&lt;li&gt;asm-tree-3.3.jar&lt;/li&gt;
&lt;li&gt;asm-commons-3.3.jar&lt;/li&gt;
&lt;li&gt;asm-3.3.jar&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-在webxml文件中配置struts2的filter&#34;&gt;2) 在web.xml文件中配置Struts2的Filter&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 配置 Struts2 的 Filter --&amp;gt;
&amp;lt;filter&amp;gt;
  &amp;lt;filter-name&amp;gt;struts2&amp;lt;/filter-name&amp;gt;
  &amp;lt;filter-class&amp;gt;
    org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter
  &amp;lt;/filter-class&amp;gt;
&amp;lt;/filter&amp;gt;

&amp;lt;filter-mapping&amp;gt;
  &amp;lt;filter-name&amp;gt;struts2&amp;lt;/filter-name&amp;gt;
  &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;
&amp;lt;/filter-mapping&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3-加入-struts2-的配置文件&#34;&gt;3) 加入 Struts2 的配置文件&lt;/h4&gt;
&lt;p&gt;　　可以拷贝例子下的struts.xml文件，例子可以在Jar包文件\Struts2.3.34\struts-2.3.34\apps\struts2-blank\WEB-INF\src\java\struts.xml文件参考.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE struts PUBLIC
  &amp;quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&amp;quot;
  &amp;quot;http://struts.apache.org/dtds/struts-2.3.dtd&amp;quot;&amp;gt;
&amp;lt;struts&amp;gt;
  &amp;lt;constant name=&amp;quot;struts.enable.DynamicMethodInvocation&amp;quot; value=&amp;quot;false&amp;quot; /&amp;gt;
  &amp;lt;constant name=&amp;quot;struts.devMode&amp;quot; value=&amp;quot;true&amp;quot; /&amp;gt;
  &amp;lt;package name=&amp;quot;default&amp;quot; namespace=&amp;quot;/&amp;quot; extends=&amp;quot;struts-default&amp;quot;&amp;gt;
      &amp;lt;action name=&amp;quot;index&amp;quot;&amp;gt;
        &amp;lt;result type=&amp;quot;redirectAction&amp;quot;&amp;gt;
            &amp;lt;param name=&amp;quot;actionName&amp;quot;&amp;gt;HelloWorld&amp;lt;/param&amp;gt;
        &amp;lt;/result&amp;gt;
    &amp;lt;/action&amp;gt;
&amp;lt;/package&amp;gt;
&amp;lt;!-- Add packages here --&amp;gt;
&amp;lt;/struts&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4-整合-spring&#34;&gt;4) 整合 Spring&lt;/h4&gt;
&lt;p&gt;① 加入 Struts2 的 Spring 插件的 jar 包  struts2-spring-plugin-2.3.34.jar.&lt;/p&gt;
&lt;p&gt;② 在 Spring 的配置文件中正常配置 Action ,注意 Action 中需要配置 scope 属性为 prototype 不是单例的.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;bean id=&amp;quot;XxxAction&amp;quot;&amp;gt; class=&amp;quot;&amp;quot; scope=&amp;quot;prototype&amp;quot;&amp;gt;
  &amp;lt;property name=&amp;quot;&amp;quot; ref=&amp;quot;&amp;quot; &amp;gt;&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&amp;lt;!-- 实例  --&amp;gt;
&amp;lt;bean id=&amp;quot;userloginDao&amp;quot; class=&amp;quot;com.dao.userLoginDao&amp;quot;&amp;gt;
  &amp;lt;property name=&amp;quot;sessionFactory&amp;quot; ref=&amp;quot;sessionFactory&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;

&amp;lt;bean id=&amp;quot;userloginService&amp;quot; class=&amp;quot;com.service.userLoginService&amp;quot;&amp;gt;
  &amp;lt;property name=&amp;quot;userLoginDao&amp;quot; ref=&amp;quot;userloginDao&amp;quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
  
&amp;lt;bean id=&amp;quot;userloginAction&amp;quot; class=&amp;quot;com.action.userLoginAction&amp;quot; scope=&amp;quot;prototype&amp;quot;&amp;gt;
  &amp;lt;property name=&amp;quot;userLoginService&amp;quot; ref=&amp;quot;userloginService&amp;quot;/&amp;gt;	
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;font color=red&gt;这里面需要注意的是&lt;/font&gt;：如果是在搭建初期只是为了测试是否成功，在创建对应的Package和Class后，在属性值为sessionFactory的Class下要创建sessionFactory的实例对象并设置setter方法，即&lt;code&gt;&amp;lt;property name=&amp;quot;sessionFactory&amp;quot; ref=&amp;quot;sessionFactory&amp;quot;/&amp;gt;&lt;/code&gt;的&lt;code&gt;&amp;lt;bean id=&amp;quot;userloginDao&amp;quot; class=&amp;quot;com.dao.userLoginDao&amp;quot;&amp;gt;&lt;/code&gt;需要在类userLoginDao下实例：&lt;code&gt;private SessionFactory sessionFactory&lt;/code&gt;;并设置&lt;code&gt;setter&lt;/code&gt;方法（可以带上&lt;code&gt;getter&lt;/code&gt;方法），以下其他bean相同. （依赖注入相关知识）&lt;/p&gt;
&lt;p&gt;③ 在Struts2的配置文件中配置Action时,class 属性指向该 Action 在Spring IOC中的id.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先要定义拦截器&lt;/strong&gt;
I. 在JSP页面如果没有采用Ajax可以直接使用以下action&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;action name=&amp;quot;XxxName&amp;quot; class=&amp;quot;XxxAction&amp;quot;&amp;gt;
  &amp;lt;result&amp;gt;/success.jsp&amp;lt;/result&amp;gt;
&amp;lt;/action&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JSP	页面form表单提交直接交给XxxName，即：&lt;code&gt;&amp;lt;form action=&amp;quot;XxxName&amp;quot;&amp;gt;&lt;/code&gt;
这种情况需要接受的action中提供form表单中input的name所对应的getter和setter
然后可以直接获取到form表单中的值.
II. 如果JSP页面使用了Ajax则需要使用以下action&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;action name=&amp;quot;userJson-*&amp;quot; class=&amp;quot;com.action.userJsonAction&amp;quot; method=&amp;quot;{1}&amp;quot;&amp;gt;
  &amp;lt;result name=&amp;quot;success&amp;quot; type=&amp;quot;json&amp;quot;&amp;gt;
    &amp;lt;param name=&amp;quot;root&amp;quot;&amp;gt;result&amp;lt;/param&amp;gt;
  &amp;lt;/result&amp;gt;
&amp;lt;/action&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;result为返回ajax的data数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里需要注意的是在使用Ajax搭配Json实现数据的交互时，需要定义拦截器的时候继承json-default拦截器，同时继承两者也可以.
这里要是采用AJAX的方式，可能需要引入JSON的相关Jar包：
但是这里需要注意的是存在两种不同的JSON的Jar包，主要区别在于实现构造方法的变量不同.&lt;/p&gt;
&lt;p&gt;例如：
&lt;font color=red&gt;√&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;JSONObject json = new JSONObject(map);&lt;/code&gt;带参构造需要引入org.json.JSONObject; &lt;code&gt;JSONObject json = new JSONObject();&lt;/code&gt;   无参构造引入的是net.sf.json.JSONObject
org.json.JSONObject类在json.jar包下—— \Jar包文件\JSON\org.json
net.sf.json.JSONObject其他包中—— \Jar包文件\JSON\net.sf.json&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;commons-beanutils-1.7.0.jar&lt;/li&gt;
&lt;li&gt;commons-collections-3.2.1.jar&lt;/li&gt;
&lt;li&gt;commons-httpclient-3.1.jar&lt;/li&gt;
&lt;li&gt;commons-lang-2.3.jar&lt;/li&gt;
&lt;li&gt;commons-logging-1.1.1.jar&lt;/li&gt;
&lt;li&gt;ezmorph-1.0.3.jar&lt;/li&gt;
&lt;li&gt;json-lib-2.2.3-jdk15.jar&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;获取ajax传过来的参数需要使用：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 用于获取data数据，定义request
HttpServletRequest request = null;
request = ServletActionContext.getRequest();
String UserID = request.getParameter(&amp;quot;UserID&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;struts&amp;gt;				
  &amp;lt;constant name=&amp;quot;struts.i18n.encoding&amp;quot; value=&amp;quot;UTF-8&amp;quot;&amp;gt;&amp;lt;/constant&amp;gt;
  &amp;lt;constant name=&amp;quot;struts.enable.DynamicMethodInvocation&amp;quot; value=&amp;quot;false&amp;quot; /&amp;gt;
  &amp;lt;constant name=&amp;quot;struts.devMode&amp;quot; value=&amp;quot;true&amp;quot; /&amp;gt;
  &amp;lt;package name=&amp;quot;default&amp;quot; namespace=&amp;quot;/&amp;quot; extends=&amp;quot;json-default,struts-default&amp;quot;&amp;gt;
  &amp;lt;!-- 定义新的拦截器栈, 配置prepare拦截器栈的alwaysInvokePrepare参数值为false --&amp;gt;
    &amp;lt;interceptors&amp;gt;
      &amp;lt;interceptor-stack name=&amp;quot;sshStack&amp;quot;&amp;gt;
        &amp;lt;interceptor-ref name=&amp;quot;paramsPrepareParamsStack&amp;quot;&amp;gt;
          &amp;lt;param name=&amp;quot;prepare.alwaysInvokePrepare&amp;quot;&amp;gt;false&amp;lt;/param&amp;gt;
        &amp;lt;/interceptor-ref&amp;gt;
      &amp;lt;/interceptor-stack&amp;gt;
    &amp;lt;/interceptors&amp;gt;
    &amp;lt;!-- 使用新的拦截器栈 --&amp;gt;
    &amp;lt;default-interceptor-ref name=&amp;quot;sshStack&amp;quot;&amp;gt;&amp;lt;/default-interceptor-ref&amp;gt;
                  
    &amp;lt;action name=&amp;quot;userJson-*&amp;quot; class=&amp;quot;com.action.userJsonAction&amp;quot; method=&amp;quot;{1}&amp;quot;&amp;gt;
      &amp;lt;result name=&amp;quot;success&amp;quot; type=&amp;quot;json&amp;quot;&amp;gt;
        &amp;lt;param name=&amp;quot;root&amp;quot;&amp;gt;result&amp;lt;/param&amp;gt;
      &amp;lt;/result&amp;gt;
    &amp;lt;/action&amp;gt;
  &amp;lt;/package&amp;gt;			
  &amp;lt;/struts&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;$.ajax({
  url : &amp;quot;blogJson-readArticle&amp;quot;,
  type : &amp;quot;POST&amp;quot;,	
  data : {
    userID : &amp;quot;132&amp;quot;,
    artID : $(&amp;quot;input:hidden[name=&#39;artID&#39;]&amp;quot;).val()
  },
  timeout : 30000,
  dataType : &amp;quot;json&amp;quot;,// 设置需要返回的数据类型
  scriptCharset : &#39;utf-8&#39;,
  success : function(data) {
    var obj = $.parseJSON(data);
    var data = obj.data;
    
  },
  error : function(XMLHttpRequest, textStatus, errorThrown) {
    alert(errorThrown + 123);
  }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4-完成功能&#34;&gt;4. 完成功能&lt;/h3&gt;
&lt;p&gt;　　具体方式可以按照自己的要求实施，&lt;strong&gt;大致方法&lt;/strong&gt;：
在dao层可以直接管理有关数据库的一切方法，通过service层调用dao层的方法，在action层对service方法进行调用即可；这里需要注意一点，就是关于一些属性的设置问题，具体跟上述使用JSON时注意的事项一样.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JSP简介</title>
      <link>https://CoMath21.github.io/post/1-jsp%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Sat, 30 Jan 2021 00:00:00 +0000</pubDate>
      <guid>https://CoMath21.github.io/post/1-jsp%E7%AE%80%E4%BB%8B/</guid>
      <description>&lt;h2 id=&#34;为什么要jsp技术&#34;&gt;为什么要JSP技术?&lt;/h2&gt;
&lt;p&gt;　　开发web网站的时候，servlet做界面比较麻烦. JSP 是基于 Servlet API 的，所以拥有 Servlet 拥有的一系列好处.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;jsp运行在服务器端&lt;/li&gt;
&lt;li&gt;jsp（java service page）&lt;/li&gt;
&lt;li&gt;jsp的基础是servlet&lt;/li&gt;
&lt;li&gt;jsp是一个综合技术  jsp=html+css+javascript+java代码+jsp标签(Servlet)&lt;/li&gt;
&lt;li&gt;jsp无需配置，可以直接使用；如果修改了jsp文件，不需要重新reload web应用&lt;/li&gt;
&lt;li&gt;jsp访问方法：http://ip:8080/web应用名/jsp路径&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;特点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内容的生成和显示相分离&lt;/li&gt;
&lt;li&gt;可移植性&lt;/li&gt;
&lt;li&gt;采用标签简化页面开发&lt;/li&gt;
&lt;li&gt;使用可重用组件&lt;/li&gt;
&lt;li&gt;完善的存储管理和安全性
&lt;img src=&#34;./1.png&#34; alt=&#34;png&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;jsp语法基础&#34;&gt;JSP语法基础：&lt;/h2&gt;
&lt;h3 id=&#34;基本元素&#34;&gt;基本元素：&lt;/h3&gt;
&lt;h4 id=&#34;注释jsp自带的注释规范是隐式注释htmlxml的注释是显示注释&#34;&gt;注释(JSP自带的注释规范是隐式注释,HTML/XML的注释是显示注释)&lt;/h4&gt;
&lt;p&gt;HTML/XML的注释(显示注释)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 个注释 --&amp;gt;
&amp;lt;!-- 个注释 ：&amp;lt;%counter++;%&amp;gt;--&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里会对counter++进行编译,显示编译后的结果
隐式注释：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%-- 注释 --%&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JSP在编译时不会对&amp;lt;%&amp;ndash;和&amp;ndash;%&amp;gt;中的进行编译;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Scriptlets中的注释：跟java注释一致.
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;指令元素&#34;&gt;指令元素&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;页面(page)指令：
页面page指令用于定义JSP文件中的全局属性,一个JSP页面可以包含多个页面指令.除了import指令外其他的页面指令定义的属性或值只能出现一次.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%@ page attribute=&amp;quot;value&amp;quot;%&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中attribute的可取值为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;language(定义使用的脚本&amp;mdash;语言默认java)、import(定义JSP网页使用的java API)、&lt;/li&gt;
&lt;li&gt;contentType(定义MIME类型和JSP网页的编码方式—默认TYPE=text/html CHARSET=iso-8859-1)、&lt;/li&gt;
&lt;li&gt;pageEncoding(JSP页面的字符编码&amp;mdash;默认pageEncoding=&amp;ldquo;iso-8859-1&amp;rdquo;)、
　&lt;strong&gt;区别&lt;/strong&gt;：contentType—pageEncoding.
&lt;ul&gt;
&lt;li&gt;contentType：只能指定网页以什么方式显示&lt;/li&gt;
&lt;li&gt;pageEncoding：除了显示之外还可以以指定形式保存&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;session(定义该JSP网页是否可以使用session对象—-默认true)、&lt;/li&gt;
&lt;li&gt;buffer(指定客户输出流的缓冲模式,如果是none,则不缓冲,如果指定数值,就定义了缓冲区的大小)、默认8K&lt;/li&gt;
&lt;li&gt;autoFlush(定义输出流的缓存区是否要自动清除-—默认true)、&lt;/li&gt;
&lt;li&gt;isThreadSafe(定义该JSP页面是否能处理多个请求&amp;mdash;默认true)、&lt;/li&gt;
&lt;li&gt;info(定义该JSP网页的相关信息-—默认忽略)、&lt;/li&gt;
&lt;li&gt;errorPage(定义此页面出现意外时的调用的页面—-默认忽略)、跳转到错误页面&lt;/li&gt;
&lt;li&gt;isErrorPage(定义该JSP网页是否为处理意外错误的网页—-默认false)、&lt;/li&gt;
&lt;li&gt;extends().&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;include指令：
include指令通知容器在当前JSP页面中指定位置包含另一个文件的内容. 被包含的文件内容可以被JSP引擎解析,这种解析发生在编译期间
&amp;lt;%@ include file=&amp;ldquo;filename&amp;rdquo;%&amp;gt;
include只有这一个属性. 其中filename为包含的文件路径,一般来说是指相对路径.
由于被包含的内容常常是代码片断,因此代码片断的后缀名最好以“f”(表示fragment)结尾,例如.htmlf&lt;/li&gt;
&lt;li&gt;标签库taglib指令：
taglib指令允许页面使用者自定义标签. 先用户开发标签库，为标签库编写.tld配置文件，然后再JSP页面使用自定义标签.
&amp;lt;%@ taglib uri=&amp;ldquo;URL&amp;rdquo; prefix=&amp;ldquo;tagPrefix&amp;rdquo;%&amp;gt;
uri 用来表示标签描述符，也就是如何找到标签文件和标签库；
tagPrefix 定义了子JSP页面里引用这个标签的前缀.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;脚本元素&#34;&gt;脚本元素&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;声明(Declaration)
声明就是在JSP程序中声明合法的变量和方法,用&amp;lt;%!和%&amp;gt;来表示)：
当代码只用于单一页面时：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%!
  variable declaration;
    method declaration(paramType param,...)
%&amp;gt;

&amp;lt;%!
  private static int counter;
  public void counterInit(){
    counter = 0 ;
  };
%&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;表达式(Expression)—用来吧java数据直接插入到输出：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;font color=red&gt;表达式&lt;/font&gt;是位于&lt;font color=red&gt;&amp;lt;%=&lt;/font&gt;和&lt;font color=red&gt;%&amp;gt;&lt;/font&gt;之间的代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%= &amp;quot;你是第&amp;quot;+counter+&amp;quot;次访问&amp;quot; %&amp;gt;
&amp;lt;%= &amp;quot;hello world&amp;quot; %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Web服务器将其编译成Servlet后，变成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;out.wreite(String.valueOf(&amp;quot;hello world&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;相当于JSP页面中的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;out.println(&amp;quot;hello world&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;font color=red&gt;注：表达式结束处可以不使用省略号，表达式可以包含表达式.&lt;/font&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;脚本小程序(Scriptlet)&amp;mdash;可以在处理请求时间执行的java代码：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Scriptlet则位于&amp;lt;%和%&amp;gt;之间,他们是合法的java代码
&lt;code&gt;&amp;lt;%counter++;%&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;动作元素&#34;&gt;动作元素&lt;/h4&gt;
&lt;p&gt;　　JSP规范定义了一系列的标准动作. 以jsp作为前缀,例如使用JavaBean的动作元素&amp;lt;jsp:useBean&amp;gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 格式： --&amp;gt;
&amp;lt;jsp:tag attribute=value attribute=value.../&amp;gt;
&amp;lt;!-- 或者 --&amp;gt;
&amp;lt;jsp:tag attribute=value attribute=value...&amp;gt;
...
&amp;lt;/jsp:tag&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;动作元素是在请求处理阶段起作用的.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文本导入标签&amp;lt;jsp:include&amp;gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 格式： --&amp;gt;
&amp;lt;jsp:include page=&amp;quot;filename&amp;quot; flush=&amp;quot;true&amp;quot;/&amp;gt;
&amp;lt;!-- 或者 --&amp;gt;
&amp;lt;jsp:include page=&amp;quot;filename&amp;quot; flush=&amp;quot;true&amp;quot;&amp;gt;
  &amp;lt;jsp:param name=&amp;quot;paramName&amp;quot; value=&amp;quot;paramValue&amp;quot;/&amp;gt;
  ...
&amp;lt;/jsp:include&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;　　&amp;lt;jsp:param&amp;gt;用于传递一个或者多个参数给动态页面;&amp;lt;jsp:include&amp;gt;动作与&amp;lt;%@include%&amp;gt;指令的不同是：前者包含的内容可以是动态改变的，它在执行时才确定；而后者包含的内容是固定不变的，在编译阶段就已经确定而不能改变.&lt;/p&gt;
&lt;p&gt;案例：Login.html、Ex1.jsp、Ex2.jsp&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;页面转发标签&amp;lt;jsp:forward&amp;gt;该操作允许将请求转发到另一个JSP、Servlet或者其他静态资源文件. 请求被转至的资源必须位于同JSP发送请求相同的上下文环境之中. 每当遇到&amp;lt;jsp:forward&amp;gt;操作时，就停止执行当前的JSP，转至执行被转发的资源.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 格式： --&amp;gt;
&amp;lt;jsp:forward page=&amp;quot;uri&amp;quot;/&amp;gt;
&amp;lt;!-- 或者 --&amp;gt;
&amp;lt;jsp:forward&amp;gt;
  &amp;lt;jsp:param name=&amp;quot;paramName&amp;quot; value=&amp;quot;paramValue&amp;quot;/&amp;gt;
  ...
&amp;lt;/jsp:forward&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中page=&amp;ldquo;uri&amp;rdquo; 指明将要定向的文件或url地址,&lt;code&gt;&amp;lt;jsp:param name=&amp;quot;paramName&amp;quot; value=&amp;quot;paramValue&amp;quot;/&amp;gt;&lt;/code&gt;中name指定参数名，value指定参数值. 参数被发送到一个动态文件，参数可以是一个或多个值，而这个文件却必须是动态文件.&lt;/p&gt;
&lt;p&gt;案例：Ex3.jsp、Ex4.jsp、Ex5.jsp&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实例化JavaBean标签&lt;a href=&#34;jsp:useBean&#34;&gt;jsp:useBean&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 格式： --&amp;gt;
&amp;lt;jsp:useBean id=&amp;quot;id&amp;quot; scope=&amp;quot;page|request|session|application typeSpec&amp;quot;/&amp;gt;
&amp;lt;!-- id 是大小写相关的名字,用来表示这个实例;scope表示此对象作用的范围；typeSpace可以是以下四者之一：class=&amp;quot;className&amp;quot; --&amp;gt;
class=&amp;quot;className&amp;quot; type=&amp;quot;typeName&amp;quot;
          beanName=&amp;quot;beanName&amp;quot; type=&amp;quot;typeName&amp;quot;
          type=&amp;quot;typeName&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;scope表示Bean的作用域，此属性是可选的，默认是page.&lt;/p&gt;
&lt;p&gt;① &lt;strong&gt;page&lt;/strong&gt;：
能够在包含&amp;lt;jsp:useBean&amp;gt;标签的JSP文件以及此文件中的所有静态包含文件中使用Bean，直到页面执行完毕客户端发回响应或转到另一个文件为止. 超出这个范围Bean就失效了.&lt;/p&gt;
&lt;p&gt;② &lt;strong&gt;request&lt;/strong&gt;：
如果该Bean不是请求上下文的一部分，将在请求上下文中创建并保存该Bean.&lt;/p&gt;
&lt;p&gt;③ &lt;strong&gt;session&lt;/strong&gt;：
从创建Bean开始，就开始在session有效范围内使用这个Bean，这个Bean对于JSP来说是共享的. 但在创建Bean的JSP文件里，page指令必须指定session=True.&lt;/p&gt;
&lt;p&gt;④ &lt;strong&gt;application&lt;/strong&gt;：
如果此Bean尚不存在于Web应用程序上下文中，则在应用程序上下文中创建并储存此Bean. application对象在应用服务器启东市就创建了，直到应用服务器关闭. 这个Bean存在于整个application生命周期内，任何在此分享application的JSP文件都能使用同一个Bean. class=&amp;ldquo;className&amp;quot;代表的是Bean的类路径和类名. 这个class不是抽象的，必须有一个公用的、没有参数的构造器. beanName=&amp;ldquo;beanName&amp;rdquo; 表示Bean的名称，而Type=&amp;ldquo;typeName&amp;quot;则用于指定Bean的类型. type=&amp;ldquo;typeName&amp;quot;指定雷鸣，既可以是本身，也可以是一个类的父类，或者是一个类的接口. 如果没有使用class或者BeanName指定type，Bean将不会被实例化.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置JavaBean属性标签&amp;lt;jsp:setProperty&amp;gt;
　　该动作主要用于设定JavaBean的属性，因此必须和useBean一起协作. &amp;lt;jsp:setProperty&amp;gt;标签通过JavaBean给定的&lt;code&gt;setXXX()&lt;/code&gt;方法，在javaBean中设置一个或多个属性值. 利用此动作标签设置属性值有多种方法：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 格式： --&amp;gt;
&amp;lt;jsp:setProperty name=&amp;quot;beanInstanceName&amp;quot; propertyDetails/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中beanInstanceName是必选属性，即JavaBean实例的名字，在使用前通过&amp;lt;jsp:useBean&amp;gt;引入. propertyDetails指可以通过三种不同的方式来指定属性信息：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;property=&amp;quot;*&amp;quot;&lt;/strong&gt;:
这种赋值方式表示请求参数的所有值. 在Bean中的属性名字必须和Request对象中的参数名一致.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;property=&amp;ldquo;propertyName&amp;rdquo;[param=&amp;ldquo;parameterName&amp;rdquo;]&lt;/strong&gt;:
这种赋值方式使用request中的一个参数值来指定Bean中的一个属性值. property指定Bean的属性名，param指定request中的参数名. 如果Bean属性和request参数的名字不同，name就必须指定property和param的值；若果同名，则需要指明property就可以了. 参数值为空，那么对应的属性值也不会被设定.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;property=&amp;ldquo;propertyName&amp;rdquo; value=&amp;ldquo;propertyValue&amp;rdquo;&lt;/strong&gt;:
这种赋值方式使用指定的值来设定Bean属性. propertyValue可以是字符串也可以是表达式. 如果是字符串，那么他就会被转换成Bean属性类型. 如果是表达式，那么它的类型就必须和它将要设定的属性值类型保持一致.
注：不能在一个&amp;lt;jsp:setProperty&amp;gt;中同时使用param和value.&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;获取JavaBean对象属性标签&amp;lt;jsp:getproperty&amp;gt;
　　与&amp;lt;jsp:setproperty&amp;gt;相对应，访问一个JavaBean属性，因此使用该动作标签之前必须用&amp;lt;jsp:useBean&amp;gt;引入一个JavaBean对象.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 格式： --&amp;gt;
&amp;lt;jdp:getProperty name=&amp;quot;beanInstanceName&amp;quot; property=&amp;quot;propertyName&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中beanInstanceName对应&amp;lt;jsp:useBean&amp;gt;的id，因此name要和&amp;lt;jsp:useBean&amp;gt;的id相同.
propertyName是要获得的属性值.&lt;/p&gt;
&lt;p&gt;c.d.e.的案例：Zhuce.jsp、Ex6.jsp、StudentBean.java&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;追加参数标签&amp;lt;jsp:param&amp;gt;
　　＼&lt;a href=&#34;jsp:param&#34;&gt;jsp:param&lt;/a&gt;标签用来提供key/value的值，与&lt;a href=&#34;jsp:inclde&#34;&gt;jsp:inclde&lt;/a&gt;、&lt;a href=&#34;jsp:forwadrd&#34;&gt;jsp:forwadrd&lt;/a&gt;等标签一起搭配使用.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 格式： --&amp;gt;
&amp;lt;jsp:param name=&amp;quot;parameterName&amp;quot; value=&amp;quot;parameterValue&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;name=&amp;ldquo;parameterName&amp;rdquo; ：该属性表示参数的名字
value=&amp;ldquo;parameterValue&amp;rdquo;：表示参数的值．&lt;/p&gt;
&lt;h2 id=&#34;servlet容器概念&#34;&gt;Servlet容器概念&lt;/h2&gt;
&lt;p&gt;　　Servlet容器为Java_Web应用提供运行时环境,它负责管理Servlet和JSP的生命周期,以及管理他们的共享数据.
Servlet容器也称为Java_Web应用容器,或者Servlet/JSP容器．&lt;/p&gt;
&lt;p&gt;流行的Servlet容器软件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;—Tomcat&lt;/li&gt;
&lt;li&gt;—Resin
&lt;img src=&#34;./2.png&#34; alt=&#34;png&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;部署tomcat服务器&#34;&gt;部署tomcat服务器：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;解压文件apache-tomcat&lt;/li&gt;
&lt;li&gt;启动：startup.bat&amp;mdash;&amp;mdash;启动服务器&lt;/li&gt;
&lt;li&gt;需要配置环境：JAVA_HOME   java   jdk的根目录&lt;/li&gt;
&lt;li&gt;想在任意目录下打开服务器
&lt;ul&gt;
&lt;li&gt;设置环境CATALINA_HOME&amp;mdash;-bin/catalina.bat&lt;/li&gt;
&lt;li&gt;Tomcat的管理程(manager)：要访问manager web应用程序,需要添加具有管理员权限的账号,编辑conf目录下的tomcat-users.xml文件,添加manager角色设置用户名密码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;第一个web程序&#34;&gt;第一个web程序：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在Eclipse新建一个Java Project&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在Java项目下创建Web开发的目录结构
&lt;img src=&#34;./3.png&#34; alt=&#34;png&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在WebContent目录下新建一个JSP文件：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;把WebContent 目录复制到Tomcat的webapps目录下&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最后在浏览器打开&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;javaeen版-eclipse开发web&#34;&gt;JavaEEn版 Eclipse开发web&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;显切换到JavaEE&lt;/li&gt;
&lt;li&gt;Servers下新建一个Tomcat服务器&amp;ndash;&amp;gt;关联到Tomcat根目录&lt;/li&gt;
&lt;li&gt;新建一个Dynamic Web Project 其中Target Runtime需选中&lt;/li&gt;
&lt;li&gt;开发应用&lt;/li&gt;
&lt;li&gt;可以通过run so server 来运行WEB项目&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;servlet-的helloworld&#34;&gt;Servlet 的HelloWorld&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;创建一个Servlet接口的实现类&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;public class HelloWorld implements Servlet
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;在web.xml 文件中配置和映射这个Servlet&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 配置和映射Servlet --&amp;gt;
&amp;lt;Servlet&amp;gt;
  &amp;lt;!—Servlet 注册的名字 –&amp;gt;
  &amp;lt;servlet-name&amp;gt;类名&amp;lt;/servlet-name&amp;gt;
  &amp;lt;!—Servlet 的全类名 --&amp;gt;
  &amp;lt;servlet-class&amp;gt;包名&amp;lt;/servlet-class&amp;gt;
&amp;lt;/Servlet&amp;gt;
&amp;lt;servlet-mapping&amp;gt;
  &amp;lt;!—需要和某一个Servlet 节点的servlet-name 子节点的文本节点一致–&amp;gt;
  &amp;lt;servlet-name&amp;gt;类名&amp;lt;/servlet-name&amp;gt;
&amp;lt;!—映射具体的访问路径：/代表当前WEB应用的根目录 –&amp;gt;
  &amp;lt;url-pattern&amp;gt;/hello&amp;lt;/url-pattern&amp;gt;
&amp;lt;/servlet-mapping&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;关于servlet-mapping&#34;&gt;关于servlet-mapping：&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;同一个Servlet可以被映射到多个URL上,即多个&lt;servlet-mapping&gt;元素的&lt;servlet-name&gt;子元素的设置值可以是同一个Servlet的注册名.&lt;/li&gt;
&lt;li&gt;在Servlet映射到的URL中也可以使用&lt;em&gt;通配符,但是只能有两种固定的格式：一种格式是“&lt;/em&gt;.扩展名”,另一种格式是以正斜杠（/）开头并以“/*”结尾.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;servlet-容器&#34;&gt;Servlet 容器：&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;可以创建Servlet,并调用Servlet的相关生命周期&lt;/li&gt;
&lt;li&gt;JSP,Filter,Listener&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;servlet-生命周期方法以下方法都是servlet容器负责调用&#34;&gt;Servlet 生命周期方法：以下方法都是Servlet容器负责调用&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;构造器：只被调用一次,只有第一次请求Servlet时,创建Servlet的实例,调用构造器,这说明Servlet是单实例的.&lt;/li&gt;
&lt;li&gt;init方法：只被调用一次,在创建好的实例后即被调用,用于初始化当前Servlet.&lt;/li&gt;
&lt;li&gt;service：被多次调用. 每次请求都会调用service方法,实际响应请求的.&lt;/li&gt;
&lt;li&gt;destroy：只被调用一次,在当前Servlet所在的Web应用被卸载前调用,用于释放当前的Servlet所占用的资源&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;loda-on-start-up参数&#34;&gt;loda-on-start-up参数：&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;配置在servlet节点中&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;Servlet&amp;gt;
  &amp;lt;!—Servlet 注册的名字 –&amp;gt;
    &amp;lt;servlet-name&amp;gt;类名1&amp;lt;/servlet-name&amp;gt;
    &amp;lt;!—Servlet 的全类名 --&amp;gt;
    &amp;lt;servlet-class&amp;gt;包名&amp;lt;/servlet-class&amp;gt;
    &amp;lt;!—可以指定Servlet 被创建的时机 --&amp;gt;
&amp;lt;load-on-startup&amp;gt;2&amp;lt;/load-on-startup&amp;gt;
&amp;lt;/Servlet&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;load-on-startup：可以指定Servlet被创建的时机.如为负数,则在第一次请求时创建;若为0或正数,则在当前WEB应用被Servlet 容器加载时创建实例,且越小越早被创建.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Spring2.5学习笔记</title>
      <link>https://CoMath21.github.io/post/1-spring2.5/</link>
      <pubDate>Sat, 30 Jan 2021 00:00:00 +0000</pubDate>
      <guid>https://CoMath21.github.io/post/1-spring2.5/</guid>
      <description>&lt;h2 id=&#34;1什么是spring&#34;&gt;1、什么是Spring&lt;/h2&gt;
&lt;p&gt;　　Spring是一个开源的控制反转(Inversion of Control,IoC)和面向切面(AOP)的容器框架，它的主要目的是简化企业开发. 用于配置bean,并维护bean之间关系的框架.&lt;/p&gt;
&lt;p&gt;　　在SSH框架中spring充当了管理容器的角色. 我们都知道Hibernate用来做持久层，因为它将JDBC做了一个良好的封装，程序员在与数据库进行交互时可以不用书写大量的SQL语句. Struts是用来做应用层的，他它负责调用业务逻辑serivce层. 所以SSH框架的流程大致是：Jsp页面&amp;mdash;-Struts&amp;mdash;&amp;mdash;Service（业务逻辑处理类）&amp;mdash;Hibernate（左到右）. Struts负责控制Service（业务逻辑处理类），从而控制了Service的生命周期，这样层与层之间的依赖很强，属于耦合. 这时，使用spring框架就起到了控制Action对象（Strus中的）和Service类的作用，两者之间的关系就松散了，Spring的Ioc机制（控制反转和依赖注入）正是用在此处.&lt;/p&gt;
&lt;p&gt;　　Spring的Ioc（控制反转和依赖注入）&lt;/p&gt;
&lt;p&gt;　　控制反转：就是由容器控制程序之间的（依赖）关系，而非传统实现中，由程序代码直接操控. 应用本身不负责以来对象的而创建和维护，以来对象的创建和维护是由外部容器负责的. 这样控制权就有应用转到了外部容器，控制权的转移就是所谓反转.&lt;/p&gt;
&lt;p&gt;　　依赖注入：组件之间的依赖关系由容器在运行期决定 ，由容器动态的将某种依赖关系注入到组件之中 .&lt;/p&gt;
&lt;h2 id=&#34;2为什么要使用springspring的好处&#34;&gt;2、为什么要使用Spring（Spring的好处）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;降低组建之间的耦合度，实现软件隔层之间的解耦；&lt;/li&gt;
&lt;li&gt;可以使用容器提供的众多服务，如：事务管理服务、消息服务等等. 当我们使用容器管理服务时，开发人员就不在需要手工控制事务，也不需要处理复杂的事务传播；&lt;/li&gt;
&lt;li&gt;容器提供单例模式支持，开发人员不需要自己编写实现代码；&lt;/li&gt;
&lt;li&gt;容器提供AOP技术，利用这些类能够够加快应用的开发，如：JdbcTemplate、HibernateTemplate；&lt;/li&gt;
&lt;li&gt;Spring对于主流的应用框架提供了集成支持，如：集成Hibernate、JPA、Struts等，这样更便于应用开发.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;轻量级与重量级概念的区分&lt;/p&gt;
&lt;p&gt;　　主要看它使用了多少服务，使用服务越多，容器为java对象做的工作就越多，必然会影响到应用的发布时间或者运行性能.&lt;/p&gt;
&lt;p&gt;　　对于Spring容器，它提供了很多服务，但这些服务并不是默认应用打开的，应用需要某种服务，还需要知名使用该服务，如果应用使用的服务很少，如：只是用了Spring的核心服务，那么我们可以认为此时应用属于轻量级的，如果使用了Spring提供的大部分服务，这时应用属于重量级的，目前EJB容器就因为它默认为应用提供了EJB规范中的所有功能，所以它属于重量级的.&lt;/p&gt;
&lt;h2 id=&#34;3配置spring所需要的jar包&#34;&gt;3、配置spring所需要的jar包&lt;/h2&gt;
&lt;p&gt;　　spring.jar是包含有完整发布的单个jar 包，spring.jar中包含除了spring-mock.jar里所包含的内容外其它所有jar包的内容，因为只有在开发环境下才会用到 spring-mock.jar来进行辅助测试，正式应用系统中是用不得这些类的.&lt;/p&gt;
&lt;p&gt;　　除了spring.jar文件，Spring还包括有其它13个独立的jar包，各自包含着对应的Spring组件，用户可以根据自己的需要来选择组合自己的jar包，而不必引入整个spring.jar的所有类文件.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;b&gt;spring-core.jar&lt;/b&gt;：这个jar文件包含Spring框架基本的核心工具类，Spring其它组件要都要使用到这个包里的类，是其它组件的基本核心，当然你也可以在自己的应用系统中使用这些工具类.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;spring-beans.jar&lt;/b&gt;：这个jar文件是所有应用都要用到的，它包含访问配置文件、创建和管理bean以及进行Inversion of Control / Dependency Injection（IoC/DI）操作相关的所有类. 如果应用只需基本的IoC/DI支持，引入spring-core.jar及spring-beans.jar文件就可以了.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;spring-aop.jar&lt;/b&gt;：这个jar文件包含在应用中使用Spring的AOP特性时所需的类. 使用基于AOP的Spring特性，如声明型事务管理（Declarative Transaction Management），也要在应用里包含这个jar包.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;spring-context.jar&lt;/b&gt;：这个jar文件为Spring核心提供了大量扩展. 可以找到使用Spring ApplicationContext特性时所需的全部类，JDNI所需的全部类，UI方面的用来与模板（Templating）引擎如Velocity、FreeMarker、JasperReports集成的类，以及校验Validation方面的相关类.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;spring-dao.jar&lt;/b&gt;：这个jar文件包含Spring DAO、Spring Transaction进行数据访问的所有类. 为了使用声明型事务支持，还需在自己的应用里包含spring-aop.jar.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;spring-hibernate.jar&lt;/b&gt;：这个jar文件包含Spring对Hibernate 2及Hibernate 3进行封装的所有类.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;spring-jdbc.jar&lt;/b&gt;：这个jar文件包含对Spring对JDBC数据访问进行封装的所有类.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;spring-orm.jar&lt;/b&gt;：这个jar文件包含Spring对DAO特性集进行了扩展，使其支持 iBATIS、JDO、OJB、TopLink，因为Hibernate已经独立成包了，现在不包含在这个包里了. 这个jar文件里大部分的类都要依赖spring-dao.jar里的类，用这个包时你需要同时包含spring-dao.jar包.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;spring-remoting.jar&lt;/b&gt;：这个jar文件包含支持EJB、JMS、远程调用Remoting（RMI、Hessian、Burlap、Http Invoker、JAX-RPC）方面的类.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;spring-support.jar&lt;/b&gt;：这个jar文件包含支持缓存Cache（ehcache）、JCA、JMX、邮件服务（Java Mail、COS Mail）、任务计划Scheduling（Timer、Quartz）方面的类.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;spring-web.jar&lt;/b&gt;：这个jar文件包含Web应用开发时，用到Spring框架时所需的核心类，包括自动载入WebApplicationContext特性的类、Struts与JSF集成类、文件上传的支持类、Filter类和大量工具辅助类.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;spring-webmvc.jar&lt;/b&gt;：这个jar文件包含Spring MVC框架相关的所有类. 包含国际化、标签、Theme、视图展现的FreeMarker、JasperReports、Tiles、Velocity、XSLT相关类. 当然，如果你的应用使用了独立的MVC框架，则无需这个JAR文件里的任何类.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;spring-mock.jar&lt;/b&gt;：这个jar文件包含Spring一整套mock类来辅助应用的测试. Spring测试套件使用了其中大量mock类，这样测试就更加简单. 模拟HttpServletRequest和HttpServletResponse类在Web应用单元测试是很方便的.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如何选择这些发布包，决定选用哪些发布包其实相当简单.&lt;/p&gt;
&lt;p&gt;　　如果你正在构建Web应用并将全程使用Spring，那么最好就使用单个全部的spring.jar文件；
如果你的应用仅仅用到简单的Inversion of Control / Dependency Injection（IoC/DI）容器，那么只需spring-core.jar与spring-beans.jar即可；&lt;/p&gt;
&lt;p&gt;　　如果你对发布的大小要求很高，那么就得精挑细选了，只取包含自己所需特性的jar文件了.
采用独立的发布包你可以避免包含自己的应用不需要的全部类. 当然你可以采用其它的一些工具来设法令整个应用包变小，节省空间的重点在于准确地找出自己所需的Spring依赖类，然后合并所需的类与包就可以了.&lt;/p&gt;
&lt;p&gt;Eclispe有个插件叫ClassPath Helper可以帮你找找所依赖的类.&lt;/p&gt;
&lt;h2 id=&#34;4spring包依赖说明&#34;&gt;4、Spring包依赖说明:&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;spring-core.jar需commons-collections.jar，spring-core.jar是以下其它各个的基本.&lt;/li&gt;
&lt;li&gt;spring-beans.jar需spring-core.jar，cglib-nodep-2.1_3.jar&lt;/li&gt;
&lt;li&gt;spring-aop.jar需spring-core.jar，spring-beans.jar，cglib-nodep-2.1_3.jar，aopalliance.jar&lt;/li&gt;
&lt;li&gt;spring-context.jar需spring-core.jar，spring-beans.jar，spring-aop.jar，commons-collections.jar，aopalliance.jar&lt;/li&gt;
&lt;li&gt;spring-dao.jar需spring-core.jar，spring-beans.jar，spring-aop.jar，spring-context.jar&lt;/li&gt;
&lt;li&gt;spring-jdbc.jar需spring-core.jar，spring-beans.jar，spring-dao.jar&lt;/li&gt;
&lt;li&gt;spring-web.jar需spring-core.jar，spring-beans.jar，spring-context.jar&lt;/li&gt;
&lt;li&gt;spring-webmvc.jar需spring-core.jar/spring-beans.jar/spring-context.jar/spring-web.jar&lt;/li&gt;
&lt;li&gt;spring-hibernate.jar需spring-core.jar，spring- beans.jar，spring-aop.jar，spring-dao.jar，spring-jdbc.jar，spring- orm.jar，spring-web.jar，spring-webmvc.jar&lt;/li&gt;
&lt;li&gt;spring-orm.jar需spring-core.jar，spring-beans.jar，spring-aop.jar，spring-dao.jar，spring-jdbc.jar，spring-web.jar，spring-webmvc.jar&lt;/li&gt;
&lt;li&gt;spring-remoting.jar需spring-core.jar，spring-beans.jar，spring- aop.jar，spring-dao.jar，spring-context.jar，spring-web.jar，spring- webmvc.jar&lt;/li&gt;
&lt;li&gt;spring-support.jar需spring-core.jar，spring-beans.jar，spring-aop.jar，spring-dao.jar，spring-context.jar，spring-jdbc.jar&lt;/li&gt;
&lt;li&gt;spring-mock.jar需spring-core.jar，spring-beans.jar，spring-dao.jar，spring-context.jar，spring-jdbc.jar&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;b&gt;一、只是使用spring框架&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;dist\spring.jar&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;lib\jakarta-commons\commons-logging.jar&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果使用到了切面编程(AOP)，还需要下列jar文件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;lib\aspectj\aspectjweaver.jsr 和 aspectjrt.jar&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;lib\cglib\cglib-nodep-2.1_3.jar&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果使用了JSR-250中的注解如&lt;code&gt;@Resource/@PostConstruct/@PreDestroy&lt;/code&gt;,还需下列jar文件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;lib\j2ee\common-annotations.jar&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;二、只是使用spring框架若使用注解方式&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;　　只要加一些命名空间和开启解析器,并且@Resource需要加lib\j2ee\common-annotations.jar&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;context:annotation-config/&amp;gt;&lt;/code&gt;打开处理器&lt;/p&gt;
&lt;p&gt;&lt;b&gt;三、要自动扫描&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;　　只要开启解析器和一些命名空间
&lt;code&gt;&amp;lt;context:component-scan base-package=&amp;quot;&amp;quot;/&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;四、spring框架采用aop编程&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;需要导入一些命名空间
xmlns:aop&amp;hellip;&amp;hellip;.
&lt;code&gt;&amp;lt;aop:aspectj-autoproxy/&amp;gt;&lt;/code&gt;开启解析器
如果使用到了切面编程(AOP)，还需要下列jar文件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;lib\aspectj\aspectjweaver.jsr 和 aspectjrt.jar&lt;/li&gt;
&lt;li&gt;lib\cglib\cglib-nodep-2.1_3.jar&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;五、spring+Jdbc开发&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;　　需要数据源文件 lib\jakarta-commons\commons-pool.jar、lib\jakarta-commons\commons-dbcp.jar&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;spring文件 ：
dist\spring.jar、
lib\jakarta-commons\commons-logging.jar&lt;/li&gt;
&lt;li&gt;jdbc驱动文件 mysql**** sql*** ：
导入tx命名空间
&amp;lt;tx:annotation-driven transaction-manager=&amp;quot;&amp;quot;/&amp;gt;
对事务注解的解析器&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;b&gt;六、spring2.5+hibernate3.3+struts1.3&lt;/b&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;hibernate核心包&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;hibernate3.jar&lt;/li&gt;
&lt;li&gt;lib\required*.jar&lt;/li&gt;
&lt;li&gt;lib\optional\ehcache-1.2.3.jar (二级缓存文件)&lt;/li&gt;
&lt;li&gt;hibernate注解包
l+ ib\test\slf4j-log4j12.jar&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;spring包&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;dist\spring.jar&lt;/li&gt;
&lt;li&gt;lib\jakarta-commons\commons-logging.jar 和commons-pool.jar、commons-dbcp.jar(后为数据源文件)&lt;/li&gt;
&lt;li&gt;dist\modules\spring-webmvc-struts.jar (与struts1的集成)&lt;/li&gt;
&lt;li&gt;lib\aspectj\aspectjweaver.jsr 和 aspectjrt.jar (Aop文件)&lt;/li&gt;
&lt;li&gt;lib\cglib\cglib-nodep-2.1_3.jar     (Aop文件)&lt;/li&gt;
&lt;li&gt;lib\j2ee\common-annotations.jar     (注解文件)&lt;/li&gt;
&lt;li&gt;lib\log4j\log4j-1.2.15.jar&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;sturs1.3.8&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;　　建议将jstl-1.0.2.jar和standard-1.0.2.jar文件更换为1.1版本，此时JSTL文件．还有spring已存在antlr-2.7.6.jar文件所以将struts中的antlr-2.7.6.jar文件删除以免冲突．&lt;/p&gt;
&lt;p&gt;&lt;b&gt;七、spring2.5+hibernate3.3+struts2整合开发&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;　　struts2文件lib里面所有不带-plugin结尾的jar文件，但除了struts2-spring-plugin-2.0.11.1.jar.&lt;/p&gt;
&lt;h2 id=&#34;5实例化spring容器&#34;&gt;5、实例化Spring容器&lt;/h2&gt;
&lt;h3 id=&#34;51实例化spring容器的方式有两种&#34;&gt;5.1、实例化Spring容器的方式有两种：&lt;/h3&gt;
&lt;p&gt;方法一：
在类路径下寻找配置文件来实例化容器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ApplicationContext ctx =
 new ClassPathXmlApplicationContext(&amp;quot;beans.xml&amp;quot;);
//1.创建Spring的IOC容器对象ApplicationContext代表IOC容器
// ClassPathXmlApplicationContext:类路径下的XML格式的配置文件
ApplicationContext ctx = new ClassPathXmlApplicationContext(&amp;quot;applicationContext.xml&amp;quot;);
//2.从IOC容器对象中获取Bean实例
HelloWorld helloWorld2 = (HelloWorld) ctx.getBean(&amp;quot;helloworld&amp;quot;);
//3.调用hello方法
helloWorld2.hello();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方法二：
在文件内系统路径下寻找配置文件来实现容器：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ApplicationContext ctx =
new FileSystemXmlApplicationContext(&amp;quot;beans.xml&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Spring配置文件可以指定多个，可以通过String数组传入.
配置Spring环境&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
  xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; 
  xmlns:context=&amp;quot;http://www.springframework.org/schema/context&amp;quot;
  xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd&amp;quot;&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;./1.png&#34; alt=&#34;png&#34;&gt;
测试是否搭建成功:项目右键新建Junit Test Case.
&lt;img src=&#34;./2.png&#34; alt=&#34;png&#34;&gt;
&lt;img src=&#34;./3.png&#34; alt=&#34;png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;6如何将业务bean交给spring管理&#34;&gt;6、如何将业务bean交给Spring管理&lt;/h2&gt;
&lt;p&gt;　　在Spring配置中添加&lt;code&gt;&amp;lt;bean id=”名称” name=”名称” class=””&amp;gt;&amp;lt;/bean&amp;gt;&lt;/code&gt;，此时bean就可以由Spring容器帮助创建和维护，当我们要用到bean的时候只需要从Spring容器中获取即可，获取的时候可以用ApplicationContext.getBean(id);（返回值为 Object），可以通过bean的接口对其进行引用，之后即可调用其方法.&lt;/p&gt;
&lt;p&gt;注意：id中不能包含特殊字符例如&lt;code&gt;“/”&lt;/code&gt;，而name中可以包含. 如果包含特殊字符则用&lt;code&gt;name=””&lt;/code&gt;；其他可以用&lt;code&gt;id=””&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;实例：首先创建一个业务bean&amp;ndash;PersonServiceBean，建议使用面向接口编程（要实现软件之间的解耦），所以可以抽取接口，然后交给Spring管理.
&lt;img src=&#34;./4.png&#34; alt=&#34;png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;7三种实例化bean的方式&#34;&gt;7、三种实例化bean的方式：&lt;/h2&gt;
&lt;h3 id=&#34;71实用类构造器实例化&#34;&gt;7.1、实用类构造器实例化&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;bean id=&amp;quot;personService&amp;quot;
  class=&amp;quot;com.haibao.service.impl.PersonServiceBean&amp;quot;/&amp;gt; 
&amp;lt;!--  配置bean
  class:bean的全类名，通过反射的方式在IOC容器中创建Bean，所以Bean中必须有无参构造器
  id:表示容器中的bean唯一
--&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;72使用静态工厂方法实例化&#34;&gt;7.2、使用静态工厂方法实例化&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;bean id=&amp;quot;personService2&amp;quot; 
  class=&amp;quot;com.haibao.service.impl.PersonServiceFactory&amp;quot; 
  factory-method=&amp;quot;createPersonService&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;./5.png&#34; alt=&#34;png&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class PersonServiceFactory {
  public static PersonServiceBean createPersonService() {
    return new PersonServiceBean();
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;73使用实例化工厂实例化&#34;&gt;7.3、使用实例化工厂实例化&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;bean id=&amp;quot;personServiceFactory&amp;quot; 
  class=&amp;quot;com.haibao.service.impl.PersonServiceFactory&amp;quot;/&amp;gt;
&amp;lt;bean id=&amp;quot;personService3&amp;quot; 
factory-bean=&amp;quot;personServiceFactory&amp;quot; 
factory-method=&amp;quot;createPersonService2&amp;quot;/&amp;gt;
public class PersonServiceFactory {
  public PersonServiceBean createPersonService() {
    return new PersonServiceBean();
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;8bean的作用域及bean的生命周期&#34;&gt;8、Bean的作用域及bean的生命周期&lt;/h2&gt;
&lt;p&gt;　　.sigleton（单例模式，Spring容器启动的时候bean就被实例化）
在每个Spring IoC容器中一个bean定义只有一个对象实例. 默认情况下会在容器启动时初始化bean，我们可以指定Bean节点的laz-init=”true”来延迟初始化bean，这时候，只有第一次获取bean才会初始化bean.
例如：&lt;code&gt;&amp;lt;bean id=”XXX” class=”XXX” lazy-init=“true”/&amp;gt; &lt;/code&gt;,
（设置lazy-init=“true”后Spring容器启动的时候bean不会被实例化）.如果想所有的应用都应用延迟初始化，可以在根节点beans设置default-lazy-init=”true”;即：&lt;code&gt;&amp;lt;bean id=”XXX” class=”XXX” default-lazy-init=“true”/&amp;gt;&lt;/code&gt;,.prototype(调用getBean()方法的时候bean才会被实例化).每次从容器获取bean都是新对象.
&lt;code&gt;&amp;lt;bean id=”XXX” class=”XXX” scope=” prototype”/&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;初始化：初始化方法可以在bean的配置中用&lt;code&gt;init-method=&amp;quot;&amp;quot;&lt;/code&gt;方法调用初始化函数.&lt;/p&gt;
&lt;p&gt;销毁：默认情况下只有Spring容器北校关闭才会销毁. 可以在bean的配置中用&lt;code&gt;destroy-method=&amp;quot;&amp;quot;&lt;/code&gt;方法销毁.&lt;/p&gt;
&lt;h2 id=&#34;9依赖注入对象&#34;&gt;9、依赖注入对象：&lt;/h2&gt;
&lt;p&gt;　　所谓依赖注入是指：在运行期，外部容器动态的将以来对象注入到组件.&lt;/p&gt;
&lt;p&gt;基本类型对象注入：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;bean id=&amp;quot;orderService&amp;quot; class=&amp;quot;orderServiceBean&amp;quot;&amp;gt;
  //构造器注入
  &amp;lt;constructor-arg index=&amp;quot;0&amp;quot; type=&amp;quot;java.lang.String&amp;quot; value=&amp;quot;XXX&amp;quot;&amp;gt;
  //属性setter方法注入
  &amp;lt;property name=&amp;quot;name&amp;quot; value=&amp;quot;value&amp;quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方式一：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;bean id=&amp;quot;orderDao&amp;quot; class=&amp;quot;PersonDaoBean&amp;quot;/&amp;gt;
&amp;lt;bean id=&amp;quot;orderService&amp;quot; class=&amp;quot;PersonServiceBean&amp;quot;&amp;gt;
  &amp;lt;property name=&amp;quot;orderDao&amp;quot; ref=&amp;quot;orderDao&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
// ref：指向其他bean
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方式二：(使用内部bean，但该bean不能被其他bean使用)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;bean id=&amp;quot;orderService&amp;quot; class=&amp;quot;PersonServiceBean&amp;quot;&amp;gt;
  &amp;lt;property name=&amp;quot;orderDao&amp;quot; ref=&amp;quot;orderDao&amp;quot;&amp;gt;
&amp;lt;bean class=&amp;quot; orderDao&amp;quot;/&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当我们把依赖对象注入交给外部容器负责创建，namePersonServiceBean类可以改成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class PersonServiceBean implements PersonService {
  private  PersonDao personDao;
  public PersonDao getPerson(){
    return personDao;
}
	
  public void getPersonDao(PersonDao personDao){
    this.personDao = personDao;
  }
	
  public void save(){
    personDao.add();
  }
}

public class PersonDaoBean implements PersonDao{
  public void add(){
    System.out.println(&amp;quot;add()方法&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;beans.xml配置中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;bean id=&amp;quot;personDaoname&amp;quot; class=&amp;quot;PersonDaoBean&amp;quot;/&amp;gt;
&amp;lt;bean id=&amp;quot;personService&amp;quot; class=&amp;quot;PersonServiceBean&amp;quot;&amp;gt;
  &amp;lt;property name=&amp;quot;personDao&amp;quot; ref=&amp;quot;personDaoname &amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;属性setter方法注入&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对基本类型进行注入：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;property name=&amp;quot;name&amp;quot; value=&amp;quot;value&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;集合类型的装配&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public calss orderServiceBean{
  private Set&amp;lt;String&amp;gt; sets = new HashSet&amp;lt;Striing&amp;gt;();
  private List&amp;lt;String&amp;gt; lists = new ArrayList&amp;lt;Striing&amp;gt;();
  private Properties properties = new Properties ();
  private Map&amp;lt;String,String&amp;gt; maps = new HashMap&amp;lt;String,Striing&amp;gt;();
  // 一定要生成getter、setter方法
} 
&amp;lt;property name=&amp;quot;sets&amp;quot;&amp;gt;
  &amp;lt;set&amp;gt;
    &amp;lt;value&amp;gt;值1&amp;lt;/value&amp;gt;
    &amp;lt;value&amp;gt;值2&amp;lt;/value&amp;gt;
    &amp;lt;value&amp;gt;值3&amp;lt;/value&amp;gt;.
  &amp;lt;/set&amp;gt;
&amp;lt;property/&amp;gt;
&amp;lt;property name=&amp;quot;lists&amp;quot;&amp;gt;
  &amp;lt;list&amp;gt;
    &amp;lt;value&amp;gt;值1&amp;lt;/value&amp;gt;
    &amp;lt;value&amp;gt;值2&amp;lt;/value&amp;gt;
    &amp;lt;value&amp;gt;值3&amp;lt;/value&amp;gt;
  &amp;lt;/list&amp;gt;
&amp;lt;property/&amp;gt;
 

&amp;lt;property name=&amp;quot;properties&amp;quot;&amp;gt;
  &amp;lt;props&amp;gt;
    &amp;lt;prop key=&amp;quot;key1&amp;quot;&amp;gt;值1&amp;lt;/prop&amp;gt;
    &amp;lt;prop key=&amp;quot;key2&amp;quot;&amp;gt;值2&amp;lt;/prop&amp;gt;
    &amp;lt;prop key=&amp;quot;key3&amp;quot;&amp;gt;值3&amp;lt;/prop&amp;gt;.
  &amp;lt;/props&amp;gt;
&amp;lt;property/&amp;gt;
&amp;lt;property name=&amp;quot;maps&amp;quot;&amp;gt;
  &amp;lt;map&amp;gt;
    &amp;lt;entry key=&amp;quot;key1&amp;quot; value=&amp;quot;1&amp;quot;/&amp;gt;
    &amp;lt;entry key=&amp;quot;key2&amp;quot; value=&amp;quot;2&amp;quot;/&amp;gt;
    &amp;lt;entry key=&amp;quot;key3&amp;quot; value=&amp;quot;3&amp;quot;/&amp;gt;.
  &amp;lt;/map&amp;gt;
&amp;lt;property/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;构造器参数注入&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;constructor-arg index=&amp;quot;0&amp;quot; type=&amp;quot;java.lang.String&amp;quot; value=&amp;quot;XXX&amp;quot;/&amp;gt;
&amp;lt;constructor-arg index=&amp;quot;1&amp;quot; type=&amp;quot;java.lang.String&amp;quot; value=&amp;quot;XXX&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;使用Field注入（用于注解方式）
　　注入以来对象可以采用手工装配或自动装配，在实际应用中建议使用手工装配，因为自动装配会产生未知情况，开发人员无法预见最终结果.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;91依赖注入---手工装配&#34;&gt;9.1、依赖注入&amp;mdash;手工装配&lt;/h3&gt;
&lt;p&gt;手工装配依赖对象，在这种方式中有两种变成方式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在xml配置文件中通过bean节点下配置. 如：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;bean id=&amp;quot;orderDao&amp;quot; class=&amp;quot;PersonDaoBean&amp;quot;/&amp;gt;
&amp;lt;bean id=&amp;quot;orderService&amp;quot; class=&amp;quot;PersonServiceBean&amp;quot;&amp;gt;
  &amp;lt;property name=&amp;quot;orderDao&amp;quot; ref=&amp;quot;orderDao&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;在java代码中使用@Autowire或@Resource注解方式进行装配. 但我们需要在xml配置文件中配置以下信息：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;			 xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; 
  xmlns:context=http://www.springframework.org/schema/context 	xsi:schemaLocation=&amp;quot;http://www.  springframework.org/schema/beans         http://www.springframework.org/schema/beans/spring-beans.xsd
http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd&amp;quot;&amp;gt;
&amp;lt;context:annotation-config/&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个配置也是注册了多个对注释进行解析处理的处理器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AutwiredAnnotationBeanProcessor&lt;/li&gt;
&lt;li&gt;CommonAnnotationBeanPostProcessor&lt;/li&gt;
&lt;li&gt;PersistenceAnnotationBeanPostProcessor&lt;/li&gt;
&lt;li&gt;RequiredAnnotationBeanProcessor&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;font color=red&gt;注：@Resource注解在Spring安装目录下的lib\j2ee\common-annotation.jar&lt;/font&gt;
　　在java代码中使用@Autowire或@Resource注解方式进行装配，这两个注解的区别是：@Autowire默认按类型装配，@Resource，默认按名称装配，当找不到与名称匹配的bean才会按类型装配.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Autowire
private PersonDao personDao;//用于字段上
@Autowire
public void setOrderDao(PersonDao personDao){
//用于属性的setter方法上
	this.orderDao = orderDao；
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;@Autowire注解是按类型装配依赖对象，默认情况下他要求对象必须存在，如果允许为null值，可以设置它的required属性为false. 如果想使用按名称装配，可以结合@Qualifier注解一起使用. 如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Autowire @Qualifier(“personDaoBean”)
private PersonDao personDao；
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;@Resource注解和@Autowire一样，也可以标注在字段或属性的setter方法上，但他默认按名称装配. 名称可以通过@Resource的name属性指定，如果没有指定name属性，当注解标注在字段上，即默认取字段的名称作为bean名称寻找依赖对象，当注解标注在属性的setter方法上，即默认取属性名作为bean名称寻找依赖对象.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Resource(name=”personDaoBean”)
private PersonDao personDao;//用于字段上
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：如果没有指定name属性，并且按照默认名称仍然找不到依赖对象时，@Resource注解会回退到安类型装配，但一旦指定了name属性，就只能按名称装配了.&lt;/p&gt;
&lt;h2 id=&#34;10aop--代理对象主要用在权限&#34;&gt;10、AOP&amp;ndash;代理对象（主要用在权限）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;环绕通知&lt;/li&gt;
&lt;li&gt;前置通知&lt;/li&gt;
&lt;li&gt;后置通知&lt;/li&gt;
&lt;li&gt;例外通知&lt;/li&gt;
&lt;li&gt;最终通知&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;public Object invoke(Object proxy, Method method,Object[] args)
    throws Throwable {
  PersonServiceBean bean = (PersonServiceBean) this.targetObject;
  Object result = null;//环绕通知
  if(bean.getUser () != null {
    // ..... advice ( )--&amp;gt;前置通知
    try {
      result = method.invoke (targetObject, args);
        //afteradvice() --&amp;gt;后置通知
  } catch(RuntimeException e){
      // exceptionadvice ()--&amp;gt;例外通知
  }finally{
    // tinallyadvice () : --&amp;gt;最终通知
  }
    }
  return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;101aop中的概念基于注解方式声明切面&#34;&gt;10.1、AOP中的概念：（基于注解方式声明切面）&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Aspect(切面)：指横切性关注点的抽象即为切面，它与类相似，只是两者的关注点不一样，类是对物体特征的抽象，而切面是横切性关注点的抽象.&lt;/li&gt;
&lt;li&gt;joinpoint(连接点)：所谓连接点是指那些被拦截到的点. 在spring中，这些点指的是方法，因为spring只支持方法类型的连接点，实际上joinpoint还可以是field或类构造器.&lt;/li&gt;
&lt;li&gt;Pointcut(切入点)：所为切入点是我们要对那些joinpoint进行拦截的定义.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注解：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Pointcut (“execution(* com.haibao.service.*.*(..))”)
private void anyMethod(){}//声明一个切入点
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;font color=red&gt;说明&lt;/font&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 配置事务拦截器拦截哪些类的哪些方法,一般设置成拦截Service --&amp;gt;
&amp;lt;aop:config&amp;gt;
  &amp;lt;aop:pointcut expression=&amp;quot;execution(* com.xy.service.*.*(..))&amp;quot;
                              id=&amp;quot;allDaoMethod&amp;quot; /&amp;gt;
  &amp;lt;aop:advisor advice-ref=&amp;quot;txAdvice&amp;quot; pointcut-ref=&amp;quot;allDaoMethod&amp;quot; /&amp;gt; 
&amp;lt;/aop:config&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;表示com.xy.service包下的所有方法为为事务管理.&lt;/p&gt;
&lt;p&gt;execution(&lt;font color=green&gt;*&lt;/font&gt; com.aptech.jb.epet.dao.hibimpl.&lt;font color=red&gt;*&lt;/font&gt;.&lt;font color=blue&gt;*&lt;/font&gt;(..))
这是com.aptech.jb.epet.dao.hibimpl包下所有的类的所有方法.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个&lt;font color=green&gt;*&lt;/font&gt;代表所有的返回值类型&lt;/li&gt;
&lt;li&gt;第二个&lt;font color=red&gt;*&lt;/font&gt;代表所有的类&lt;/li&gt;
&lt;li&gt;第三个&lt;font color=blue&gt;*&lt;/font&gt;代表类所有方法 最后一个..代表所有的参数.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;一些常见切入点表达式的例子：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任意公共方法的执行：&lt;code&gt;execution(public * *(..))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;任何一个以“set”开始的方法的执行：&lt;code&gt;execution(* set*(..))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;AccountService 接口的任意方法的执行：
&lt;code&gt;execution(* com.xyz.service.AccountService.*(..))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;定义在service包里的任意方法的执行：
&lt;code&gt;execution(* com.xyz.service.*.*(..))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;定义在service包或者子包里的任意类的任意方法的执行：
&lt;code&gt;execution(* com.xyz.service..*.*(..))&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;Advice(通知)：所谓通知是指拦截到joinpoint之后所做的事情，通知分为前置通知（@Before(“anyMethod()”)）、&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;后置通知（@AfterReturning(“anyMethod()”)）、&lt;/li&gt;
&lt;li&gt;最终通知（@After(“anyMethod()”)）、&lt;/li&gt;
&lt;li&gt;例外通知（@AfterThrowing(“anyMethod()”)）、&lt;/li&gt;
&lt;li&gt;环绕通知（@Around(“anyMethod()”)）.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;public Object doBasicProfiling(ProceedingJoinPoint p) throws Throwable{
  Object result = p.proceed();//必须执行该方法
return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Target(目标对象)：代理的目标对象.&lt;/p&gt;
&lt;p&gt;Weave(织入)：指将aspects应用到target对象并导致proxy对象创建的过程称为织入.&lt;/p&gt;
&lt;p&gt;Introduction(引入)：在不修改代码的前提下，Introduction可以在运行期间为类动态的添加一些方法或Field.&lt;/p&gt;
&lt;h3 id=&#34;102基于xml配置方式声明切面&#34;&gt;10.2、基于XML配置方式声明切面&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;aop:aspectj-autoproxy /&amp;gt;
  &amp;lt;bean id=&amp;quot;aspetbean&amp;quot; class=&amp;quot;...&amp;quot;&amp;gt;&amp;lt;/bean&amp;gt;
  &amp;lt;aop:config&amp;gt;
    &amp;lt;aop:aspect id=&amp;quot;asp&amp;quot; ref=&amp;quot;aspetbean&amp;quot;&amp;gt;
      &amp;lt;!-- 定义切入点 id=名称 expression 表示拦截... --&amp;gt;
      &amp;lt;aop:pointcut id=&amp;quot;mycut&amp;quot; expression=  &amp;quot;execution(* com.xy.service.*.*(..))&amp;quot;/&amp;gt;
      &amp;lt;!-- 前置通知 --&amp;gt;
      &amp;lt;aop:before pointcut-ref=&amp;quot;mycut&amp;quot;  method=&amp;quot;&amp;quot;/&amp;gt;
      &amp;lt;!-- 后置通知 --&amp;gt;
      &amp;lt;aop:after-returning pointcut-ref=  &amp;quot;mycut&amp;quot;  method=&amp;quot;&amp;quot;/&amp;gt;
      &amp;lt;!-- 例外通知 --&amp;gt;
      &amp;lt;aop:after-throwing pointcut-ref=&amp;quot;mycut&amp;quot;  method=&amp;quot;&amp;quot;/&amp;gt;
      &amp;lt;!-- 最终通知 --&amp;gt;
      &amp;lt;aop:after pointcut-ref=&amp;quot;mycut&amp;quot;  method=&amp;quot;&amp;quot;/&amp;gt;
      &amp;lt;!-- 环绕通知 --&amp;gt;
      &amp;lt;aop:around pointcut-ref=&amp;quot;mycut&amp;quot;  method=&amp;quot;&amp;quot;/&amp;gt;
  &amp;lt;/aop:aspect&amp;gt;
&amp;lt;/aop:config&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;11springjdbc组合开发&#34;&gt;11、Spring+JDBC组合开发&lt;/h2&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;配置数据源，如：
依赖的jar文件： commons-dbcp.jar、
commons-logging.jar、
commons-pool.jar&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;bean id=&amp;quot;dataSource&amp;quot; 
class=&amp;quot;org.apach.commons.dbcp.BasicDataSource&amp;quot; 
destroy-method=&amp;quot;close&amp;quot;&amp;gt;
  &amp;lt;property name=&amp;quot;driveClassName&amp;quot; 
value=&amp;quot;org.gjt.mm.mysql.Driver&amp;quot;/&amp;gt;
&amp;lt;property name=&amp;quot;url&amp;quot;
value=&amp;quot;jdbc:mysql://localhost:3306/dbname?useUnicode=true
转义&amp;amp;←&amp;amp;amp;characterEncoding=UTF-8&amp;quot;/&amp;gt;
&amp;lt;property name=&amp;quot;username&amp;quot; value=&amp;quot;root&amp;quot;/&amp;gt;
&amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;root&amp;quot;/&amp;gt;
&amp;lt;!-- 连接池启动时的初始值 --&amp;gt;
&amp;lt;property name=&amp;quot;initialSize&amp;quot; value=&amp;quot;1&amp;quot;/&amp;gt;
&amp;lt;!-- 连接池最大值 --&amp;gt;
&amp;lt;property name=&amp;quot;maxActive&amp;quot; value=&amp;quot;500&amp;quot;/&amp;gt;
&amp;lt;!-- 最大空闲值，当经历过一个高峰时间后，连接池可以慢慢将已经用不到的连接慢慢释放一部分，一直减少到maxIdle为止 --&amp;gt;
&amp;lt;property name=&amp;quot;maxIdle&amp;quot; value=&amp;quot;2&amp;quot;/&amp;gt;
&amp;lt;!-- 最小空闲值，当空闲的连接数少于阙值时，连接池会预申请去一些连接，以免洪峰来时不及申请 --&amp;gt;
&amp;lt;property name=&amp;quot;minIdle&amp;quot; value=&amp;quot;1&amp;quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
或者使用属性文件保存参数值
&amp;lt;context:property-placeholder location=&amp;quot;classpath.properties&amp;quot;/&amp;gt;
classpath:在类路径下
&amp;lt;bean id=&amp;quot;dataSource&amp;quot; 
class=&amp;quot;org.apach.commons.dbcp.BasicDataSource&amp;quot; 
destroy-method=&amp;quot;close&amp;quot;&amp;gt;
  &amp;lt;property name=&amp;quot;driveClassName&amp;quot; value=&amp;quot;${ driveClassName}&amp;quot;/&amp;gt;
&amp;lt;property name=&amp;quot;url&amp;quot;value=&amp;quot;${ url }&amp;quot;/&amp;gt;
&amp;lt;property name=&amp;quot;username&amp;quot; value=&amp;quot;${ username}&amp;quot;/&amp;gt;
&amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;${ password }&amp;quot;/&amp;gt;
&amp;lt;!-- 连接池启动时的初始值 --&amp;gt;
&amp;lt;property name=&amp;quot;initialSize&amp;quot; value=&amp;quot;${ initialSize }&amp;quot;/&amp;gt;
&amp;lt;!-- 连接池最大值 --&amp;gt;
&amp;lt;property name=&amp;quot;maxActive&amp;quot; value=&amp;quot;${ maxActive }&amp;quot;/&amp;gt;
&amp;lt;!-- 最大空闲值，当经历过一个高峰时间后，连接池可以慢慢将已经用不到的连接慢慢释放一部分，一直减少到maxIdle为止 --&amp;gt;
&amp;lt;property name=&amp;quot;maxIdle&amp;quot; value=&amp;quot;${ maxIdle }&amp;quot;/&amp;gt;
&amp;lt;!-- 最小空闲值，当空闲的连接数少于阙值时，连接池会预申请去一些连接，以免洪峰来时不及申请 --&amp;gt;
&amp;lt;property name=&amp;quot;minIdle&amp;quot; value=&amp;quot;${ minIdle }&amp;quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;配置事务：配置事务时，需要在XML配置文件中引入声明事务的tx命名空间，事务的配置方式有两种：注解方式和基于XML配置方式.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;111采用注解方式配置事务在xml文件中配置事务管理器&#34;&gt;11.1、采用注解方式配置事务：在XML文件中配置事务管理器&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;bean id=&amp;quot;txManager&amp;quot; 
class=&amp;quot;org.springframework.jdbc.datasource.DataSourceTranszctionManager&amp;quot;&amp;gt;
&amp;lt;property name=&amp;quot;dataSource&amp;quot; ref=&amp;quot;dataSource&amp;quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&amp;lt;!-- 采用@Transactional注解方式使用事务 --&amp;gt;
&amp;lt;tx:annotation-driven transaction-manager=&amp;quot;txManager&amp;quot;&amp;gt;   
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;tx命名空间.&lt;/p&gt;
&lt;p&gt;xmlns:tx=&amp;ldquo;&lt;a href=&#34;http://www.springframework.org/schema/tx%22&#34;&gt;http://www.springframework.org/schema/tx&amp;quot;&lt;/a&gt;
&lt;a href=&#34;http://www.springframework.org/schema/tx&#34;&gt;http://www.springframework.org/schema/tx&lt;/a&gt;
&lt;a href=&#34;http://www.springframework.org/schema/tx/spring-tx-2.5.xsd&#34;&gt;http://www.springframework.org/schema/tx/spring-tx-2.5.xsd&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;12采用基于xml方式配置事务&#34;&gt;12、采用基于XML方式配置事务&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;bean id=&amp;quot;txManager&amp;quot; class=&amp;quot;org.springframework.jdbc.datasource.DatasourceTransactionManager&amp;quot;&amp;gt;
  &amp;lt;property name=&amp;quot;dataSource&amp;quot; ref=&amp;quot;dataSource&amp;quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&amp;lt;aop:config&amp;gt;
  &amp;lt;aop:pointcut id=&amp;quot;transactionPointcut&amp;quot; expression=&amp;quot;execute()…&amp;quot;/&amp;gt;
  &amp;lt;aop:advisor advice=&amp;quot;txAdvice&amp;quot; point-ref=&amp;quot;transactionPointcut&amp;quot;/&amp;gt;
&amp;lt;/aop:config&amp;gt;
&amp;lt;tx:advice id=&amp;quot;txAdvice&amp;quot; transaction-manager=&amp;quot;txManager&amp;quot;&amp;gt;
  &amp;lt;tx:attributes&amp;gt;
    &amp;lt;tx:method name=&amp;quot;get*&amp;quot; read-only=&amp;quot;true&amp;quot; proportion=&amp;quot;NOT_SUPPORTED&amp;quot;/&amp;gt;
    &amp;lt;tx:method name=&amp;quot;*&amp;quot;/&amp;gt;
  &amp;lt;/tx:attributes&amp;gt;
&amp;lt;/tx:advice&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;13spring管理事务提交的规则&#34;&gt;13、Spring管理事务提交的规则：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;遇到unckecked（运行期例外）事物会发生回滚，即：执行无效.&lt;/li&gt;
&lt;li&gt;遇到checked事物不会发生回滚.&lt;/li&gt;
&lt;li&gt;要求回滚：@Transcation(rollbackFor=Exception.class)&lt;/li&gt;
&lt;li&gt;事物传播属性：@Transcation(propagation=Propagation. NOT_SUPPORTED)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;REQUIRED&lt;/strong&gt;:（默认）业务方法需要在一个事务中运行. 如果方法运行时，已经处在一个事务中，那么加入到该事务中，否则自己创建一个新事务.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NOT_SUPPORTED&lt;/strong&gt;:声明方法不需要事务. 如果方法没有关联一个事务，容器不会为它开启事务；如果方法在一个事务中被调用，该事务会挂起，在方法调用结束后，原先的事务便会恢复执行.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;REQUIRESNEW&lt;/strong&gt;:属性表明不管是否存在事务，业务方法总会为自己发起一个新的事务. 如果方法已经运行在一个事务中，则原事务会被挂起，新事务会被日创建，直到方法结束，新事务才算结束，原先的事务才会恢复.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MANDATORY&lt;/strong&gt;:该属性指定业务方法在某个事务范围，业务方法不能发起自己的事务. 如果业务方法在事务范围外被调用，则方法在没有事务的环境下执行.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SUPPORKTS&lt;/strong&gt;：这一事务属性表明，如果业务方法在某个事务范围内被调用，则方法成为该事务的一部分. 如果业务方法在没有事务的环境下调用，则方法在没有事务的环境下执行.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Never&lt;/strong&gt;:指定业务方法绝对不能在事务范围内执行. 若果业务方法在某个事务中执行，容器会抛出例外，只有业务方法没有关联到任何事务，才能正常执行.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NESTED&lt;/strong&gt;:如果一个活动的事务存在，则运行在一个嵌套的事务中，如果没有活动事务，则按REQUIRED属性执行，它使用了一个人单独的事务，这个事务拥有多个可以回滚的保存点. 内部事务的回滚不会对外部事务造成影响. 他只对DataSourceTransactionManager事务管理器起效.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;14数据库系统提供了四种事务隔离级&#34;&gt;14、数据库系统提供了四种事务隔离级&lt;/h2&gt;
&lt;p&gt;　　数据库系统提供了四级事务隔离级别供用户选择. 不同的隔离级别采用不同的所类型实现，在四级隔离级别中，Serislixstion的隔离级别最高，Read Uncommited的隔离级别最低. 大多数据库默认的隔离级别为Read Commited，如SQLServer 2000 &amp;hellip;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Read Uncommited&lt;/strong&gt;：读未提交数据（会出现脏读，不可重复读和幻读）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Read Commited&lt;/strong&gt;：读已提交数据（会出现不可重复读和幻读）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Repeatable Read&lt;/strong&gt;：可重复读（会出现幻读）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Serializable&lt;/strong&gt;：串行化&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;脏读&lt;/strong&gt;：一个事务读取到另一个事务未提交的更新数据.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可重复读&lt;/strong&gt;：在同一个事务中多次读取数据时，能够保证所读数据一样，也就是，后续读取不能读到另外一个事务已提交的更新数据.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不可重复读&lt;/strong&gt;：在同一个事务中多次读取同一数据返回的结果有所不同，也就是，后续读取能读到另外一个事务已提交的更新数据.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;幻读&lt;/strong&gt;：一个事务读取到另一事务已提交的insert数据.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Hibernate学习笔记</title>
      <link>https://CoMath21.github.io/post/1-hibernate/</link>
      <pubDate>Fri, 29 Jan 2021 00:00:00 +0000</pubDate>
      <guid>https://CoMath21.github.io/post/1-hibernate/</guid>
      <description>&lt;h2 id=&#34;hibernate-是什么&#34;&gt;Hibernate 是什么？&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;hibernate是一个轻量级JavaEE应用的持久层框架（framework）&lt;/li&gt;
&lt;li&gt;hibernate是一个ORM（object relation mapping对象关系映射）框架
&lt;ul&gt;
&lt;li&gt;o object -&amp;gt; 业务层(只对对象操作)&lt;/li&gt;
&lt;li&gt;r relation-&amp;gt; 关系数据库，关系型数据库中二维表&lt;/li&gt;
&lt;li&gt;m mapping 对象关系映射文件
&lt;ul&gt;
&lt;li&gt;java类&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-&amp;gt;表&lt;/li&gt;
&lt;li&gt;java对象&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;&amp;gt;表中记录&lt;/li&gt;
&lt;li&gt;java对象属性&amp;mdash;&amp;mdash;-&amp;gt;表中字段&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;hibernate 处于我们项目的持久层位置(正因为如此，所以有人又把hibernate称为 持久层框架)&lt;/li&gt;
&lt;li&gt;hibernate 实际上就是对jdbc进行了轻量级的封装.&lt;/li&gt;
&lt;li&gt;hibernate 的基础还是我们java反射机制&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;手动配置hibernate方式完成crud操作&#34;&gt;手动配置hibernate方式完成crud操作&lt;/h2&gt;
&lt;p&gt;　　首先创建项目，再引入jar包. hibernate开发的三种方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;由domain object –&amp;gt; mapping -&amp;gt; db (官方推荐).&lt;/li&gt;
&lt;li&gt;由DB开始，用工具生成mapping和domain object (使用较多).&lt;/li&gt;
&lt;li&gt;由映射开始.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;employeehbmlxml配置文件&#34;&gt;Employee.hbml.xml配置文件&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE hibernate-mapping PUBLIC &amp;quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&amp;quot;
	&amp;quot;http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd&amp;quot;&amp;gt;
&amp;lt;hibernate-mapping package=&amp;quot;com.hsp.domain&amp;quot;&amp;gt;
  &amp;lt;class name=&amp;quot;Employee&amp;quot; table=&amp;quot;employee&amp;quot;&amp;gt;
    &amp;lt;!-- id元素用于指定主键属性 --&amp;gt;
    &amp;lt;id name=&amp;quot;id&amp;quot; column=&amp;quot;id&amp;quot; type=&amp;quot;java.lang.Integer&amp;quot;&amp;gt;
    &amp;lt;!-- 该元素用于指定主键值生成策略hilo native increment sequence uuid --&amp;gt;
      &amp;lt;generator class=&amp;quot;sequence&amp;quot;&amp;gt;
        &amp;lt;param name=&amp;quot;sequence&amp;quot;&amp;gt;emp_seq&amp;lt;/param&amp;gt;
      &amp;lt;/generator&amp;gt;
    &amp;lt;/id&amp;gt;
    &amp;lt;!-- 对其它属性还有配置 --&amp;gt;
    &amp;lt;property name=&amp;quot;name&amp;quot; type=&amp;quot;java.lang.String&amp;quot;&amp;gt;
      &amp;lt;column name=&amp;quot;name&amp;quot; not-null=&amp;quot;false&amp;quot;  /&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;email&amp;quot; type=&amp;quot;java.lang.String&amp;quot; &amp;gt;
      &amp;lt;column name=&amp;quot;email&amp;quot; not-null=&amp;quot;false&amp;quot;/&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;hiredate&amp;quot; type=&amp;quot;java.util.Date&amp;quot;&amp;gt;
      &amp;lt;column name=&amp;quot;hiredate&amp;quot; not-null=&amp;quot;false&amp;quot; /&amp;gt;
    &amp;lt;/property&amp;gt;
  &amp;lt;/class&amp;gt;	
&amp;lt;/hibernate-mapping&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;./1.png&#34; alt=&#34;png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;hibernatecfgxml配置文件&#34;&gt;hibernate.cfg.xml配置文件&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;!DOCTYPE hibernate-configuration PUBLIC
        &amp;quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&amp;quot;
        &amp;quot;http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd&amp;quot;&amp;gt;
&amp;lt;hibernate-configuration&amp;gt;
  &amp;lt;session-factory&amp;gt;
    &amp;lt;!-- hibernate 设计者，给我们提供了一写常用的配置 --&amp;gt;
    &amp;lt;!-- 配置使用的driver --&amp;gt;
    &amp;lt;property name=&amp;quot;connection.driver_class&amp;quot;&amp;gt;oracle.jdbc.driver.OracleDriver&amp;lt;/property&amp;gt;
    &amp;lt;!-- 配置使用的账户密码 --&amp;gt;
    &amp;lt;property name=&amp;quot;connection.username&amp;quot;&amp;gt;scott&amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;connection.password&amp;quot;&amp;gt;tiger&amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;connection.url&amp;quot;&amp;gt;jdbc:oracle:thin:@127.0.0.1:1521:orclhsp&amp;lt;/property&amp;gt;
    &amp;lt;!-- 配置dialect方言,明确告诉hibernate连接是哪种数据库 --&amp;gt;
    &amp;lt;property name=&amp;quot;dialect&amp;quot;&amp;gt;org.hibernate.dialect.OracleDialect&amp;lt;/property&amp;gt;
    &amp;lt;!-- 显示出对于sql语句 --&amp;gt;
    &amp;lt;property name=&amp;quot;show_sql&amp;quot;&amp;gt;true&amp;lt;/property&amp;gt;
    &amp;lt;!-- 指定管理的对象映射文件 --&amp;gt;
    &amp;lt;mapping resource=&amp;quot;com/hsp/domain/Employee.hbm.xml&amp;quot;/&amp;gt;
  &amp;lt;/session-factory&amp;gt;
&amp;lt;/hibernate-configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;connection.driver_class:在etc下可以找到；&lt;/li&gt;
&lt;li&gt;hibernate.cfg.xml文件可以不写，但要在spring中配置.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;测试文件testmainjava&#34;&gt;测试文件TestMain.java&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;package com.hsp.view;
import com.hsp.util.*;
import java.util.Date;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.cfg.*;

import com.hsp.domain.Employee;
public class TestMain {
  public static void main(String[] args) {
    //查询[load]-&amp;gt;hql语句(hibernate query language)
  }
  public static void delEmp() {
    //删除
    //获取一个session
    Session session=MySessionFactory.getSessionFactory().openSession();
    Transaction ts=session.beginTransaction();
    //删除1.先获取该雇员，然后删除
    Employee emp=(Employee) session.load(Employee.class, 3);
    session.delete(emp);
    ts.commit();
    session.close();
  }

  public static void updateEmp() {
    // TODO Auto-generated method stub
    //修改用户
    //获取一个会话
    Session session=MySessionFactory.getSessionFactory().openSession();
    
    Transaction ts=session.beginTransaction();
    //修改用户1. 获取要修改的用户，2.修改
    //load是通过主键属性，获取该对象实例.&amp;lt;---&amp;gt;表的记录对应
    Employee emp=(Employee) session.load(Employee.class, 3);
    emp.setName(&amp;quot;韩顺平8&amp;quot;);//update...
    emp.setEmail(&amp;quot;abc@sohu.com&amp;quot;);
    ts.commit();
    session.close();
  }

  public static void addEmployee() {
    //我们使用hibernate完成crud操作[这里我们只见对象，不见表]
    //现在我们不是用service ,直接测试.
    //1. 创建Configuration,该对象用于读取hibernate.cfg.xml,并完成初始化
    Configuration configuration=new Configuration().configure();
    //2.创建SessoinFactory[这是一个会话工厂，是一个重量级的对象]
    SessionFactory sessionFactory=configuration.buildSessionFactory();
    //3.创建Sessoin 相当于jdbc Connection[ servelt HttpSession ,也不是 jsp session]
    Session session=sessionFactory.openSession();
    //4.对hiberate而言，要求在进行 增加，删除，修改的时候使用事务提交，
    Transaction transaction = session.beginTransaction();
    //添加一个雇员
    Employee employee=new Employee();
    employee.setName(&amp;quot;shunping&amp;quot;);
    employee.setEmail(&amp;quot;shunping@sohu.com&amp;quot;);
    employee.setHiredate(new Date());
    //insert .............
    //保存
    session.save(employee);//save employee就是持久化该对象 (把对象保存到了数据库中称为一条记录)
    //==&amp;gt;insert into ....[被hiberante封装]
    //提交
    transaction.commit();
    session.close();
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;./2.png&#34; alt=&#34;png&#34;&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;code&gt;&amp;lt;Hibernate-mapping&amp;gt;&lt;/code&gt;标签的属性如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;package：指定一个包前缀，如果在映射文档中(就是在class标签的那么属性里没有指定全类名)没有指定全限定的类名，就使用这个作为包名.&lt;/li&gt;
&lt;li&gt;schema：数据库schema的名称.&lt;/li&gt;
&lt;li&gt;catalog：数据库catalog的名称.&lt;/li&gt;
&lt;li&gt;default-cascade：默认的级联风格,默认为none.&lt;/li&gt;
&lt;li&gt;default-access：Hibernate用来访问属性的策略.&lt;/li&gt;
&lt;li&gt;default-lazy：指定了此属性，未明确注明lazy属性的Java属性和集合类，Hibernate会采取的默认使用这个属性加载风格,默认为true.&lt;/li&gt;
&lt;li&gt;auto-import：指定我们是否可以在查询语言中使用非全限定的类名,默认为true,如果项目中有两个同名的持久化类,则最好在这两个类的对应的映射文件中配置为false.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;　　Hibernate的子标签class标签：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;class 元素用于指定类和表的映射 .&lt;/li&gt;
&lt;li&gt;name:指定该持久化类映射的持久化类的类名.
&lt;ul&gt;
&lt;li&gt;example:&lt;code&gt;&amp;lt;class name=&amp;quot;com.jeremy.hibernate.example.News&amp;quot; table=&amp;quot;NEWS&amp;quot;&amp;gt;&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;table:指定该持久化类映射的表名, Hibernate 默认以持久化类的类名作为表名 .
&lt;ul&gt;
&lt;li&gt;example:&lt;code&gt;&amp;lt;class name=&amp;quot;com.jeremy.hibernate.example.News&amp;quot; table=&amp;quot;NEWS&amp;quot;&amp;gt;&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;dynamic-insert: 若设置为 true, 表示当（调用Session的save()方法时）保存一个对象时, 会动态生成 insert 语句, insert 语句中仅包含所有取值不为 null 的字段. 默认值为 false.&lt;/li&gt;
&lt;li&gt;Example:这个跟dynamic-update一个意思.&lt;/li&gt;
&lt;li&gt;dynamic-update: 若设置为 true, 表示当(调用对象的set()方法)更新一个对象时, 会动态生成 update 语句, update 语句中仅包含所有取值需要更新的字段. 默认值为 false.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　Hibernate映射文件主要内容:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;映射内容的定义:
Hibernate映射文件由&lt;code&gt;&amp;lt;hibernate-mapping package=&amp;quot;JavaBean所在包的全路径&amp;quot;&amp;gt;&lt;/code&gt;节点定义映射内容并指定所对应的JavaBean的位置(也可以不在该节点中用package属性指定对应的JavaBean位置,而在该节点下的class节点中的name属性中指定).&lt;/li&gt;
&lt;li&gt;数据库和JavaBean的关联:
Hibernate映射文件中用&lt;code&gt;&amp;lt;hibernate-mapping&amp;gt;&lt;/code&gt;节点下的
&lt;code&gt;&amp;lt;class name=&amp;quot;JavaBean名称&amp;quot; table=&amp;quot;对应数据库中的表名&amp;quot;&amp;gt;&lt;/code&gt;节点指定数据库表和JavaBean的关联. ( 该节点的父节点中用package属性指定了JavaBean的包名时用)/全路径(该节点的父节点中没用package属性指定JavaBean的包名时用).&lt;/li&gt;
&lt;li&gt;主键映射:
在&lt;code&gt;&amp;lt;class &amp;gt;&lt;/code&gt;节点下用&lt;code&gt;&amp;lt;id name=&amp;quot;数据库中主键在JavaBean中的属性名称&amp;quot; column=&amp;quot;数据库中主键名&amp;quot; type=&amp;quot;string&amp;quot;&amp;gt;&lt;/code&gt;节点映射对应的主键,该节点必须有且只有一个(因为主键只有一个),同时必须放在&lt;code&gt;&amp;lt;property ...&amp;gt;&lt;/code&gt;节点前.&lt;/li&gt;
&lt;li&gt;普通字段映射:
在&lt;code&gt;&amp;lt;class ...&amp;gt;&lt;/code&gt;节点下用&lt;code&gt;&amp;lt;property name=&amp;quot;数据库中字段在JavaBean中的属性名称&amp;quot; column=&amp;quot;数据库中的字段名&amp;quot; type=&amp;quot;string&amp;quot;/&amp;gt;&lt;/code&gt;节点映射普通字段,该节点可有多个(一个字段用一个该节点来映射).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;　　Heibernate的主键映射方式：&lt;/p&gt;
&lt;p&gt;　　在&lt;code&gt;&amp;lt;id ...&amp;gt;节点下用&amp;lt;generator class=&amp;quot;映射方式&amp;quot;/&amp;gt;&lt;/code&gt;节点指定Hibernate向数据库插入数据时主键的生成方式.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;assigned：应用程序自身对id赋值. 当设置&lt;code&gt;&amp;lt;generator class=&amp;quot;assigned&amp;quot;/&amp;gt;&lt;/code&gt;时，应用程序自身需要负责主键id的赋值，由外部程序负责生成(在session.save()之前为对象的主键设置值),无需Hibernate参与，一般应用在主键为自然主键时. 例如XH为主键时，当添加一个学生信息时，就需要程序员自己设置学号的值，这时就需要应用该id生成器.&lt;/li&gt;
&lt;li&gt;native：由数据库对id赋值. 当设置&lt;code&gt;&amp;lt;generator class=&amp;quot;native&amp;quot;/&amp;gt;&lt;/code&gt;时，数据库负责主键id的赋值，最常见的是int型的自增型主键. 例如，在SQLServer中建立表的id字段为identity，配置了该生成器，程序员就不用为该主键设置值，它会自动设置.&lt;/li&gt;
&lt;li&gt;identity：采用数据库提供的主键生成机制，为long/short/int型列生成唯一标识如SQL Server、MySQL中的自增主键生成机制.&lt;/li&gt;
&lt;li&gt;hilo：通过hi/lo算法实现的主键生成机制，需要额外的数据库表保存主键生成历史状态.&lt;/li&gt;
&lt;li&gt;seqhilo：与hi/lo类似，通过hi/lo算法实现的主键生成机制，只是主键历史状态保存在sequence中，适用于支持sequence的数据库，如Oracle.&lt;/li&gt;
&lt;li&gt;increment：主键按数值顺序递增. 此方式的实现机制为在当前应用实例中维持一个变量，以保存当前的最大值，之后每次需要生成主键的时候将此值加1作为主键. 这种方式可能产生的问题是：如果当前有多个实例访问同一个数据库，由于各个实例各自维护主键状态，不同实例可能生成同样的主键，从而造成主键重复异常. 因此，如果同一个数据库有多个实例访问，这种方式应该避免使用.&lt;/li&gt;
&lt;li&gt;sequence：采用数据库提供的sequence机制生成主键，用于用序列方式产生主键的数据库(如:Oracle、DB2等的Sequence),用于为long/short/int型列生成唯一标识,如:&lt;code&gt;&amp;lt;generator class=&amp;quot;sequence&amp;quot;&amp;gt;&amp;lt;param name=&amp;quot;sequence&amp;quot;&amp;gt;序列名&amp;lt;/param&amp;gt;&amp;lt;/generator&amp;gt;&lt;/code&gt;如Oracle sequence.&lt;/li&gt;
&lt;li&gt;uuid.hex：由Hibernate基于128位唯一值产生算法，根据当前设备IP、时间、JVM启动时间、内部自增量等4个参数生成十六进制数值（编码后长度为32位的字符串表示）作为主键. 即使是在多实例并发运行的情况下，这种算法在最大程度上保证了产生id的唯一性. 当然，重复的概率在理论上依然存在，只是概率比较小. 一般而言，利用uuid.hex方式生成主键将提供最好的数据插入性能和数据平台适应性.&lt;/li&gt;
&lt;li&gt;uuid.string：与uuid.hex类似，只是对生成的主键进行编码（长度为16位）. 在某些数据库中可能出现问题.&lt;/li&gt;
&lt;li&gt;foreign：使用外部表的字段作为主键. 该主键一般应用在表与表之间的关系上，会在后面的表对应关系上进一步讲解.&lt;/li&gt;
&lt;li&gt;select：Hibernate 3新引入的主键生成机制，主要针对遗留系统的改造工程.
由于常用的数据库，如SQLServer、MySQL等，都提供了易用的主键生成机制（如auto-increase字段），可以在数据库提供的主键生成机制上，采用native生成器来配置主键生成方式.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;hibernate的核心类和接口&#34;&gt;Hibernate的核心类和接口&lt;/h2&gt;
&lt;h3 id=&#34;1configuration类&#34;&gt;1、Configuration类&lt;/h3&gt;
&lt;p&gt;它的作用是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;负责管理hibernate的配置信息；&lt;/li&gt;
&lt;li&gt;读取hibernate.cfg.xml文件；&lt;/li&gt;
&lt;li&gt;加载hibernate.cfg.xml配置文件中配置的驱动文件，url，用户名，密码，连接池；&lt;/li&gt;
&lt;li&gt;管理 *.hbm.xml对象关系文件.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2hibernatecfgxml文件&#34;&gt;2、hibernate.cfg.xml文件&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;该文件主要用于制定各个参数，值hibernate核心文件；&lt;/li&gt;
&lt;li&gt;默认放在src目录下，也可以在别的目录下；&lt;/li&gt;
&lt;li&gt;指定连接数据库的驱动、用户名、url、密码、连接池；&lt;/li&gt;
&lt;li&gt;制定对象关系映射文件位置；&lt;/li&gt;
&lt;li&gt;也可以使用hibernate,properties文件来替代该文件.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3sessionfactory-接口&#34;&gt;3、SessionFactory 接口&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;可以缓存SQL语句或者数据（称为）.&lt;/li&gt;
&lt;li&gt;在应用程序化的时候创建，是一个重量级的类，一般用单例模式保证一个应用只需要一个SessionFactory实例.&lt;/li&gt;
&lt;li&gt;如果某个应用访问多个数据库，则要创建多个回话工厂实例，一般一个数据库一个会话工厂实例.&lt;/li&gt;
&lt;li&gt;通过SessionFactory接口可以获得Session实例.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;Configuration cf = new Configuration().configure();
SessionFactory sf = cf.buildSessionFactory();
Session s = sf.getCurrentSession();
//或者：Session  s = sf.openSession(); 
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;31-opensession和getcurrentsession区别&#34;&gt;3.1 openSession()和getCurrentSession()区别&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;采用getCurrentSession()创建的session会绑定到当前线程中，而采用openSession()创建的Session则不会；&lt;/li&gt;
&lt;li&gt;采用getCurrentSession()创建的session在commit或rollback时会自动关闭，而采用openSession()创建的session必须手动关闭（建议不管是用哪个，最好都要手动关闭）；&lt;/li&gt;
&lt;li&gt;使用getCurrentSession()需要在hibernate.cfg.xml文件中加入如下配置：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;* 如果使用的是本地事务（jdbc事务：针对一个数据库的事务）*
&amp;lt;property name=&amp;quot;hibernate.current_session_context_class&amp;quot;&amp;gt;thread&amp;lt;/property&amp;gt;
* 如果使用的是全局事务（jta事务：卷数据库的事务）*
&amp;lt;property name=&amp;quot;hibernate.current_session_context_class&amp;quot;&amp;gt;jta&amp;lt;/property&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;如何选择openSession()和getCurrentSession()&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;原则：&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果需要在同一线程中，保证使用同一个Session，则使用getCurrentSession().&lt;/li&gt;
&lt;li&gt;如果在一个线程中，需要使用不同的Session，则使用openSession().&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;32get-vs-load&#34;&gt;3.2	get vs load&lt;/h4&gt;
&lt;p&gt;　可以使用&lt;code&gt;session.get(Student.class,i)/session.load(…)&lt;/code&gt;获取值&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果查询不到数据，get会返回 null,但是不会报错, load如果查询不到数据，则报错ObjectNotFoundException&lt;/li&gt;
&lt;li&gt;使用get 去查询数据，(先到一级/二级)会立即向db发出查询请求(select &amp;hellip;), 如果你使用的是 load查询数据，(先到一级、二级))即使查询到对象，返回的是一个代理对象,如果后面没有使用查询结果，它不会真的向数据库发select ,当程序员使用查询结果的时候才真的发出select ,这个现象我们称为“懒加载”(lazy)&lt;/li&gt;
&lt;li&gt;通过修改配置文件，我们可以取消“懒加载”；&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;class  name=&amp;quot;Employee&amp;quot; lazy=&amp;quot;false&amp;quot; table=&amp;quot;employee&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;如何选择使用哪个: 如果你确定DB中有这个对象就用load(),不确定就用get()（这样效率高）.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;4transaction事务接口&#34;&gt;4、Transaction（事务）接口&lt;/h3&gt;
&lt;p&gt;　　事务简单地说就是一组对数据库的操作集合，他们要么全部成功，要么全部失败，这个可以保证数据的一致性，事务具有原子性.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Transaction是底层的事物实现中抽取出来的接口；&lt;/li&gt;
&lt;li&gt;可能是一个jdbc或者jta的事务，这样有利于hibernate在不同执行环境的移植；&lt;/li&gt;
&lt;li&gt;Hibernate要求显示的调用事务（如果仅仅是查询可以不调用）.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;//增加删除修改如果发生异常要tx.rollback()回滚
Session sess = factory.openSession();
Transaction tx;
try {
    tx = sess.beginTransaction();
    //do some work
    ...
    tx.commit();
}
catch (Exception e) {
    if (tx!=null) tx.rollback();
    throw e;
}
finally {
    sess.close();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;5query-接口&#34;&gt;5、Query 接口&lt;/h3&gt;
&lt;p&gt;　　Query接口类型的对象可以对数据库操作，他可以使用Hql，Qbc，Qbe和原生SQL（native Sql）对数据库操作，官方推荐使用Hql语句.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//获取query引用[这里Employee不是表名，而是domain类名]，where后面的条件最好使用类下的属性名
Query query = session.createQuery(&amp;quot;from Employee where id=10&amp;quot;);
//通过list方法获取结果，这个list会自动封装成对应的domain对象
List&amp;lt;Employee&amp;gt; list = query.list();
for(Employee e:list)
	...
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;6criteria接口&#34;&gt;6、Criteria接口&lt;/h3&gt;
&lt;p&gt;　　什么是QBC：
QBC（Query By Criteria）按条件查询，通过Criteria构造查询条件，即通过调用Criteria的api实现各种查询.&lt;/p&gt;
&lt;p&gt;　　通过Criteria对象拼装 查询条件，调用Criteria的add方法拼接查询条件，最终hibernate通过criteria对象自动生成sql语句.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（了解）纯面向对象的检索方式&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Session session=HibernateUtil.getCurrentSession();
Transaction ts=null;		
try {			
  ts=session.beginTransaction();			
  Criteria cri = session.createCriteria(Employee.class).
  setMaxResults(2).addOrder(Order.desc(&amp;quot;id&amp;quot;) );//按照升序   
  List&amp;lt;Employee&amp;gt; list=cri.list();
  for(Employee e: list){
    System.out.println(e.getAaaid());
  }			
  ts.commit();			
} catch (Exception e) {			
  if(ts!=null){
    ts.rollback();
  }
  throw new RuntimeException(e.getMessage());
}finally{
  //关闭session
  if(session!=null&amp;amp;&amp;amp;session.isOpen()){
    session.close();
  }
  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;./3.png&#34; alt=&#34;png&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;mysql记录总数查询&#34;&gt;MySQL记录总数查询&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;分页查询
&lt;img src=&#34;./4.png&#34; alt=&#34;png&#34;&gt;&lt;/li&gt;
&lt;li&gt;投影查询方法
&lt;img src=&#34;./5.png&#34; alt=&#34;png&#34;&gt;&lt;/li&gt;
&lt;li&gt;记录总数查询
&lt;img src=&#34;./6.png&#34; alt=&#34;png&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;detachedcriteria&#34;&gt;DetachedCriteria&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;DetachedCriteria是什么？离线的Criteria.&lt;/li&gt;
&lt;li&gt;DetachedCriteria和Criteria区别：
&lt;ul&gt;
&lt;li&gt;Criteria创建方法：session.createCriteria&lt;/li&gt;
&lt;li&gt;DetachedCriteria创建方法：不需要session．&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DetachedCriteria和Criteria相同点：实现查询条件拼装.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　建议使用DetachedCriteria，因为DetachedCriteria创建不需要session，在任何代码中通过DetachedCriteria 拼接查询条件.
&lt;img src=&#34;./7.png&#34; alt=&#34;png&#34;&gt;
这里的HibernateUtil为打开SessionFactory.&lt;/p&gt;
&lt;h2 id=&#34;service&#34;&gt;service&lt;/h2&gt;
&lt;p&gt;　　接收servlet传入查询条件，将查询条件拼装成DetachedCritriea.
&lt;img src=&#34;./8.png&#34; alt=&#34;png&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
public Long findCustomerCount(CstCustomer cstCustomer) {
  
  //创建DetachedCriteria
  DetachedCriteria detachedCriteria = DetachedCriteria.forClass(CstCustomer.class);
  
  //根据cstCustomer中数据动态拼接查询条件
  if(cstCustomer!=null){
    //拼接客户名称查询条件，使用like
    if(cstCustomer.getCustName()!=null &amp;amp;&amp;amp; !cstCustomer.getCustName().equals(&amp;quot;&amp;quot;)){
      detachedCriteria.add(Restrictions.like(&amp;quot;custName&amp;quot;, &amp;quot;%&amp;quot;+cstCustomer.getCustName()+&amp;quot;%&amp;quot;));
    }
    //拼接联系人查询条件
    if(cstCustomer.getCustLinkman()!=null &amp;amp;&amp;amp; !cstCustomer.getCustLinkman().equals(&amp;quot;&amp;quot;)){
      detachedCriteria.add(Restrictions.eq(&amp;quot;custLinkman&amp;quot;,cstCustomer.getCustLinkman()));
    }
  }
  
  CstCustomerDao cstCustomerDao = new CstCustomerDaoImpl();
  
  return cstCustomerDao.findCustomerCount(detachedCriteria);
}
@Override
public List&amp;lt;CstCustomer&amp;gt; findCustomerList(CstCustomer cstCustomer, int firstResult, int maxResults) {
  CstCustomerDao cstCustomerDao = new CstCustomerDaoImpl();
  //创建DetachedCriteria
  DetachedCriteria detachedCriteria = DetachedCriteria.forClass(CstCustomer.class);
  
  //拼接查询条件
  //根据cstCustomer中数据动态拼接查询条件
  if(cstCustomer!=null){
    //拼接客户名称查询条件，使用like
    if(cstCustomer.getCustName()!=null &amp;amp;&amp;amp; !cstCustomer.getCustName().equals(&amp;quot;&amp;quot;)){
      detachedCriteria.add(Restrictions.like(&amp;quot;custName&amp;quot;, &amp;quot;%&amp;quot;+cstCustomer.getCustName()+&amp;quot;%&amp;quot;));
    }
    //拼接联系人查询条件
    if(cstCustomer.getCustLinkman()!=null &amp;amp;&amp;amp; !cstCustomer.getCustLinkman().equals(&amp;quot;&amp;quot;)){
      detachedCriteria.add(Restrictions.eq(&amp;quot;custLinkman&amp;quot;,cstCustomer.getCustLinkman()));
    }
  }
  
  return cstCustomerDao.findCustomerList(detachedCriteria, firstResult, maxResults);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;log4j学习&#34;&gt;log4j学习&lt;/h2&gt;
&lt;p&gt;目标：学会使用log4j自定义输出日志信息.&lt;/p&gt;
&lt;p&gt;hibernate默认使用slf4j框架.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;slf4j：提供了一套日志记录接口规范.&lt;/li&gt;
&lt;li&gt;log4j：日志接口的实现类.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　如果 使用log4j需要以classpath下添加log4j.properties文件.&lt;/p&gt;
&lt;p&gt;Log4j包括三个主要部件，分别是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;记录器（Loggers）：配置日志在哪记录.&lt;/li&gt;
&lt;li&gt;输出源（Appenders）：配置日志输出到哪里.
&lt;img src=&#34;./9.png&#34; alt=&#34;png&#34;&gt;&lt;/li&gt;
&lt;li&gt;布局（Layouts），指定日志输出格式
&lt;img src=&#34;./10.png&#34; alt=&#34;png&#34;&gt;
&lt;em&gt;记录器：&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;log4j.rootLogger=debug,A
log4j.appender.A=org.apache.log4j.ConsoleAppender
log4j.appender.A.layout=org.apache.log4j.PatternLayout
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;日志级别&lt;/em&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;日志级别由低到高为：ALL &amp;lt; TRACE &amp;lt; DEBUG &amp;lt; INFO &amp;lt; WARN &amp;lt; ERROR &amp;lt; FATAL &amp;lt; OFF.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;日志级别越低输出日志越多，因为将系统调试信息设置级别低，系统的错误信息级别要高，设置成error.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;根据log4j.properties中级别设置，将级别高的日志输出.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;在开发阶段设置为debug，在生产环境设置info或error.&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;用myeclipse进行hibernate快速开发&#34;&gt;用MyEclipse进行hibernate快速开发&lt;/h2&gt;
&lt;p&gt;　　手动配置:&lt;/p&gt;
&lt;p&gt;db(table )-&amp;gt; 手写domain对象-&amp;gt;对象关系映射文件.&lt;/p&gt;
&lt;p&gt;现在我们希望用工具完成Domain对象和关系映射文件的工作.
&lt;img src=&#34;./11.png&#34; alt=&#34;png&#34;&gt;
&lt;img src=&#34;./12.png&#34; alt=&#34;png&#34;&gt;
&lt;img src=&#34;./13.png&#34; alt=&#34;png&#34;&gt;
&lt;img src=&#34;./14.png&#34; alt=&#34;png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;错误信息&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=red&gt;java.lang.AbstractMethodError: com.microsoft.jdbc.base.BaseDatabaseMetaData.supportsGetGeneratedKeys()Z&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;解决&lt;/b&gt;：microsoft提供的数据库驱动存在bug. 需要换一种驱动连接，使用jtds（&lt;a href=&#34;http://sourceforge.net/projects/jtds/files/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;下载地址&lt;/a&gt;）下载jtds1.2版，解压得到jtds-1.2.jar，引用到eclipse中项目目录下（去除原驱动引用），更改hibernate配置文件.&lt;/p&gt;
&lt;p&gt;原驱动连接配置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;property name=&amp;quot;connection.driver_class&amp;quot;&amp;gt;com.microsoft.jdbc.sqlserver.SQLServerDriver&amp;lt;/property&amp;gt;
&amp;lt;property name=&amp;quot;connection.url&amp;quot;&amp;gt;jdbc:microsoft:sqlserver://127.0.0.1:1433;DatabaseName=hibernate&amp;lt;/property&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更改jtds连接：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;property name=&amp;quot;connection.driver_class&amp;quot;&amp;gt;net.sourceforge.jtds.jdbc.Driver&amp;lt;/property&amp;gt;
&amp;lt;property name=&amp;quot;connection.url&amp;quot;&amp;gt;jdbc:jtds:sqlserver://127.0.0.1:1433;DatabaseName=hibernate&amp;lt;/property&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;问题得到解决.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;补充&lt;/b&gt;：java代码调原驱动连接数据库是没有问题的，搭配hibernate会有此问题.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# HibernateUtil工具类：
package com.haibao.util;

import javax.persistence.Entity;
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.cfg.Configuration;

@Entity
final public class HibernateUtil {
  private static SessionFactory sessionFactory = null;
  private static ThreadLocal&amp;lt;Session&amp;gt; threadLocal = new ThreadLocal&amp;lt;Session&amp;gt;();

  private HibernateUtil(){};

  static{
    sessionFactory = new Configuration().configure().buildSessionFactory();
  }

  public static Session openSession(){
    return sessionFactory.openSession();
  }

  public static Session getCurrentSession(){
    Session session = threadLocal.get();
    if(session==null){
      session = sessionFactory.openSession();
      threadLocal.set(session);
    }
    return session;
  }
}
# 实现类：
package com.haibao.view;

import javax.persistence.Entity;

import org.hibernate.Session;
import org.hibernate.Transaction;

import com.haibao.bean.Person;
import com.haibao.util.HibernateUtil;

@Entity
public class Main {
  public static void main(String[] args) {

    Session session = null;
    Transaction ts = null;
    try {
      session = HibernateUtil.getCurrentSession();
      ts = session.beginTransaction();
      Person p = new Person();
      p.setName(&amp;quot;asd&amp;quot;);
      p.setSex(&amp;quot;男&amp;quot;);
      session.persist(p);
      ts.commit();
    } catch (Exception e) {
      if(ts!=null){
        ts.rollback();
      }
      throw new RuntimeException(e.getMessage());
    }finally{
      if(session!=null &amp;amp;&amp;amp; session.isOpen()){
        session.close();
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;hql语句hibernate-query-language&#34;&gt;HQL语句（Hibernate Query Language）&lt;/h2&gt;
&lt;p&gt;　　面向对象的查询语句，与SQL不同，HQl中的对象是区分大小写的（除了JAVA类和属性其他部分不区分大小写）；在HQL中查的是对象而不是表，并且支持多态；HQL主要通过Query来操作，Query的创建方式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Query query = session.createQuery(hql);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;　　现在使用hibernate工具，自动生成 domain 对象 和映射文件,如果我们的表有主外键的关系，则应当先映射主表，再映射从表.&lt;/p&gt;
&lt;h2 id=&#34;uniqueresult方法&#34;&gt;uniqueResult方法&lt;/h2&gt;
&lt;p&gt;　　如果我们检索一个对象，明确知道最多只有一个对象，则建议使用该方法，简单高效. 具体用法如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Student s=(Student) session.createQuery(&amp;quot;from Student where sid=&#39;20050003&#39;&amp;quot;).uniqueResult();
System.out.println(s.getSname());
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;distinct的用法&#34;&gt;distinct的用法&lt;/h2&gt;
&lt;p&gt;过滤重复的记录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//比如，显示所有学生的性别和年龄.
List list=session.createQuery(&amp;quot;select distinct sage,ssex from Student&amp;quot;).list();
  for(int i=0;i&amp;lt;list.size();i++){
    Object []  objs=(Object[]) list.get(i);
    System.out.println(objs[0].toString()+&amp;quot; &amp;quot;+objs[1].toString());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;between-and&#34;&gt;between and..&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;List list=session.createQuery(&amp;quot;select distinct sage,ssex,sname from Student where sage between 20 and 22&amp;quot;).list();
  for(int i=0;i&amp;lt;list.size();i++){
    Object []  objs=(Object[]) list.get(i);
    System.out.println(objs[0].toString()+&amp;quot; &amp;quot;+objs[1].toString()+objs[2].toString());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;innot-in&#34;&gt;in/not in&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;//查询计算机系和外语系的学生信息
List&amp;lt;Student&amp;gt; list=session.createQuery(&amp;quot;from Student where sdept in (&#39;计算机系&#39;,&#39;外语系&#39;)&amp;quot;).list();
//取出1. for 增强
for(Student s:list){
  System.out.println(s.getSname()+&amp;quot; &amp;quot;+s.getSaddress()+&amp;quot; &amp;quot;+s.getSdept());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;group-by使用&#34;&gt;group by使用&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;//显示各个系的学生的平均年龄
List&amp;lt;Object[]&amp;gt; list=session.createQuery(&amp;quot;select avg(sage),sdept from  Student group by sdept&amp;quot;).list();
  //取出1. for 增强
  for(Object[] obj:list){
    System.out.println(obj[0].toString()+&amp;quot; &amp;quot;+obj[1].toString());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;having的使用&#34;&gt;having的使用&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;//1.对分组查询后的结果，进行筛选:比如请显示人数大于3的系名称
//a. 查询各个系分别有多少学生.
List&amp;lt;Object[]&amp;gt; list=session.createQuery(&amp;quot;select count(*) as c1,sdept from  Student group by sdept having count(*)&amp;gt;3&amp;quot;).list();
//取出1. for 增强
for(Object[] obj:list){
  System.out.println(obj[0].toString()+&amp;quot; &amp;quot;+obj[1].toString());
}
//2查询女生少于200人的系
//a.查询各个系的女生有多个个
List&amp;lt;Object[]&amp;gt; list=session. createQuery(&amp;quot;select count(*) as c1,sdept from  Student where ssex=&#39;F&#39; group by sdept&amp;quot;).list();
//取出1. for 增强
for(Object[] obj:list){
  System.out.println(obj[0].toString()+&amp;quot; &amp;quot;+obj[1].toString());
}
//1.查询计算机系共多少人?-&amp;gt;如果我们返回的是一列数据
//这时我们的取法是直接取出list-&amp;gt;object 而不是 list-&amp;gt;Object[]
List&amp;lt;Object[]&amp;gt; list=session.createQuery(&amp;quot;select sage from  Student where sdept=&#39;计算机系&#39;&amp;quot;).list();
//取出1. for 增强
for(Object obj:list){
  System.out.println(obj.toString());
}
//3.查询选修11号课程的最高分和最低分.
List&amp;lt;Object[]&amp;gt; list=session.
createQuery(&amp;quot;select 11,max(grade),min(grade) from Studcourse where course.cid=11&amp;quot;).list();
//取出1. for 增强
for(Object[] obj:list){
  System.out.println(obj[0].toString()+&amp;quot; max=&amp;quot;+obj[1].toString()+&amp;quot; min=&amp;quot;+obj[2].toString());
}
//4.计算各个科目不及格的学生数量.
List&amp;lt;Object[]&amp;gt; list=session. createQuery(&amp;quot;select count(*),student.sdept from StudCourse where grade&amp;lt;60 group by student.sdept&amp;quot;).list();
//取出1. for 增强
for(Object[] obj:list){
  System.out.println(obj[0].toString()+&amp;quot; &amp;quot;+obj[1].toString());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;分页显示对象&#34;&gt;分页显示对象：&lt;/h2&gt;
&lt;p&gt;　　根据用户输入的pageNow和pageSize现实对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Query query = session.createQuery(hql);
query.setFirdtRequest(从第几条取//从0开始计算);
query.setMaxRequest(取出几条);
List list = query.list();
//list就是结果
query = session.createQuery(得到count(*)的查询语句);
int pageRow = (Integer)query.list().get(0).intValue();
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参数绑定&#34;&gt;参数绑定&lt;/h3&gt;
&lt;p&gt;　　可以用setParameter()方法来确定变量的值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Query query = session.createQuery(&amp;quot;from Student where sdept = :dept and sage&amp;gt;:age&amp;quot;);
query.setParameter(参数名，值);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用绑定参数的好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可读性好&lt;/li&gt;
&lt;li&gt;性能提高&lt;/li&gt;
&lt;li&gt;防止SQL注入（where 1=1）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;提示：也可以使用setInteger().setString()…来指定值.&lt;/p&gt;
&lt;p&gt;另外：hql语句也可以用“?”来指定带绑定的参数.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Query query = session.createQuery(“from Student where sdept = ? and sage&amp;gt;?”);
query.setParameter(0，值);
query.setParameter(1，值);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;在映射文件中得到hql语句&#34;&gt;在映射文件中得到hql语句&lt;/h2&gt;
&lt;p&gt;　　可以从某些映射文件中得到hql语句，执行查询语句，这样可以更加灵活，在某种情况下，可以考虑使用. 比如：在Student.hbm.xml中.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;query name=”myquerytest”&amp;gt;
&amp;lt;![CDATA[select sname,ssex from Student where sage&amp;gt;22]]&amp;gt;
&amp;lt;/query&amp;gt;
如何使用：
List list = session.getNameQuery(“myQuerytest”).lise();
  System.out.println(list.size());
Iterator iterator = list.iterator();
while(iterator.hasNext()){
  Object obj[] = (Object[])iterator.next();
  System.out.println(“N=”+obj[0]);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;使用子查询&#34;&gt;使用子查询&lt;/h2&gt;
&lt;h3 id=&#34;hibernate中的对象存在三种关系&#34;&gt;hibernate中的对象存在三种关系&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;one-to-one：身份证←→人&lt;/li&gt;
&lt;li&gt;one-to-many【many-to-one】部门←→员工&lt;/li&gt;
&lt;li&gt;many-to-many：老师←→学生（尽量化简）
实际开发中，如果出现了many-to-many关系，用将其装换成两个one-to-many或者many-to-one，这样程序好控制，同时不会冗余.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;criterial使用:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//查询年龄大于10岁的学生 criteria
Session s=HibernateUtil.getCurrentSession();
Transaction tx=s.beginTransaction();
Criteria cri=s.createCriteria(Student.class);
//添加检索条件
cri.add(Restrictions.gt(&amp;quot;sage&amp;quot;, new Long(10)));
List&amp;lt;Student&amp;gt; list=cri.list();
for(Student s1: list){
  System.out.println(s1.getSname());
}
tx.commit();      
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;hibernate开发的三种方式中的&#34;&gt;hibernate开发的三种方式中的&lt;/h2&gt;
&lt;p&gt;　　编写domain object + 映射文件 &amp;mdash;&amp;mdash;&amp;gt; 创建出对应的数据库,这里我们说明如果要自动的创建出对应的数据库，需要做配置(hibernate.cfg.xml).&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;property name=&amp;quot;hbm2ddl.auto&amp;quot;&amp;gt;create&amp;lt;/property&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里有四个配置值: create , update , create-drop, validate&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;create:当我们的应用程序加载hibernate.cfg.xml[new Configuration().config();]就会根据映射文件，创建出数据库, 每次都会重新创建， 原来表中的数据就没有!!!&lt;/li&gt;
&lt;li&gt;update: 如果数据库中没有该表，则创建，如果有表，则看有没有变化，如果有变化，则更新.&lt;/li&gt;
&lt;li&gt;create-drop: 在显示关闭 sessionFactory时，将drop掉数据库的schema&lt;/li&gt;
&lt;li&gt;validate: 相当于每次插入数据之前都会验证数据库中的表结构和hbm文件的结构是否一致&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　在开发测试中，我们配置哪个都可以测试，但是如果项目发布后，最好自己配置一次，让对应的数据库生成，完后取消配置.&lt;/p&gt;
&lt;p&gt;domain对象的细节:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需要一个无参的构造函数(用于hibernate反射该对象)&lt;/li&gt;
&lt;li&gt;应当有一个无业务逻辑的主键属性.&lt;/li&gt;
&lt;li&gt;给每个属性提供 get/set方法.&lt;/li&gt;
&lt;li&gt;在domian对象中的属性，只有配置到了对象映射文件xxx.hbm.xml后，才会被hiberante管理.&lt;/li&gt;
&lt;li&gt;属性一般是private范围&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对象关系映射文件的说明：&lt;/p&gt;
&lt;p&gt;　　对象关系文件中，有些属性是可以不配，hibernate会采用默认机制，比如&lt;code&gt;&amp;lt;class table=&amp;quot;?&amp;quot; &amp;gt;&lt;/code&gt; table 值不配，则以类的小写做表名；&lt;code&gt;&amp;lt;property type=&amp;quot;?&amp;quot;&amp;gt; &lt;/code&gt;type不配置，则hibernate会根据类的属性类型，选择一个适当的类型.&lt;/p&gt;
&lt;p&gt;Hibernate的三种状态：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;瞬时态：对象刚刚被创建，没有处于session的管理下，同时在数据库没有记录；&lt;/li&gt;
&lt;li&gt;持久态：既处于session的管理下，同时又被保存到数据库中（在数据库中有记录）；&lt;/li&gt;
&lt;li&gt;脱管/游离态：没有在session管理下，但在数据库中有记录.
&lt;img src=&#34;./15.png&#34; alt=&#34;png&#34;&gt;
&lt;b&gt;如何判断一个对象处于怎样的状态？&lt;/b&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;主要的依据是:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;看该对象是否处于session管理；&lt;/li&gt;
&lt;li&gt;看在数据库中有没有对应的记录.&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;瞬时态: 没有session管理,同时数据库没有对应记录;new了一个对象，此时对象就是瞬时态;瞬时态对象和数据库记录没有对关系，和session没有关系.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;持久态: 有session管理，同时在数据库中有记录; 瞬时态对象执行save变化持久层;持久态对象和数据库记录存在对应关系，和session有关系.修改对象的属性，直接将数据保证到数据库.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;管态/游离态： 没有session管理，但是在数据库中有记录.当session关闭后，持久态对象变为托管态;	托管态对象和session没有关系，可能和数据库存在对象也可能不对应.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;托管态和瞬时态区别&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;托管态对象:	和session没有关联，可能和数据库存在对应关系，托管态对象中存在主键的值.&lt;/li&gt;
&lt;li&gt;持久态对象:	和session有状态&lt;/li&gt;
&lt;li&gt;瞬时态对象:	和session没有关联，和数据库记录没有对象关系，没有主键.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;将瞬时态对象设置一个主键值，它就变为了托管态对象！！！&lt;/p&gt;
&lt;h3 id=&#34;saveorupdate方法测试&#34;&gt;saveOrUpdate方法测试：&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;对瞬时态对象执行insert操作&lt;/li&gt;
&lt;li&gt;对持久态对象执行update操作&lt;/li&gt;
&lt;li&gt;对托管态对象执行update操作&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;懒加载&#34;&gt;懒加载:&lt;/h2&gt;
&lt;p&gt;　　简述: 当我们查询一个对象的时候，在默认情况下,返回的只是该对象的普通属性（直接属性，不需要通过外键等查询得到）,当用户去使用对象属性时，才会向数据库发出再一次的查询.这种现象我们称为 lazy现象.
解决方法可以这样:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;显示初始化代理对象： Hibernate.initized(student.getDepart())；与直接属性相连的对象.&lt;/li&gt;
&lt;li&gt;修改对象关系文件 lazy  改写 lazy=false（说明：不要再one-to-many的one中设置false，在many中设置可以提高效率）
以上两种方法 不能直接解决懒加载问题.&lt;/li&gt;
&lt;li&gt;通过过滤器(web项目) openSessionInView
添加一个过滤器&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;懒加载详解&#34;&gt;懒加载详解：&lt;/h3&gt;
&lt;p&gt;　　懒加载（Load On Demand）是一种独特而又强大的数据获取方法，是指程序推迟访问数据库，这样可以保证有时候不必要的访问数据库，因为一次访问数据库是比较耗时的.
懒加载的几种情况：
首先明确一点：Domain Object是非finally的，才能实现懒加载. 解决方法：（因为要重写集合Set…）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;明确初始化
在session还没有关闭时，访问一次xxx.getXxx()，强制访问数据库. 或者Hibernate.initialize(xxx)；&lt;/li&gt;
&lt;li&gt;openSessionView
这个往往需要过滤器配合使用(web程序)；&lt;/li&gt;
&lt;li&gt;在ssh中，可以实现在service层，标准方式解决懒加载；&lt;/li&gt;
&lt;li&gt;在映射文件中配置，lazy=false.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;hibernate的关系映射&#34;&gt;Hibernate的关系映射：&lt;/h2&gt;
&lt;h3 id=&#34;mang-to-one&#34;&gt;mang-to-one：&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 对于private Department depart就不能用property many-to-one 的name=“变量名” column name=“将来生成表的名” --&amp;gt;
&amp;lt;many-to-one name=&amp;quot;depart&amp;quot;&amp;gt;
  &amp;lt;column name=&amp;quot;depart_id&amp;quot;&amp;gt;&amp;lt;/column&amp;gt;
&amp;lt;/many-to-one&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;./16.png&#34; alt=&#34;png&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;one-to-many&#34;&gt;one-to-many&lt;/h3&gt;
&lt;p&gt;需求：查询所有一号部门的学生.&lt;/p&gt;
&lt;p&gt;常规思维：&lt;code&gt;String hql = “from Student where dept.id=1”&lt;/code&gt;;&lt;/p&gt;
&lt;p&gt;还可以采用一对多：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;现在Department中添加一个Set集合，并生成get/set方法；
private Set&lt;Student&gt; stu;//一个部门可以对应多个学生&lt;/li&gt;
&lt;li&gt;在Department.hbm.xml文件中添加&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;set name=“集合对象属性名”&amp;gt;
  &amp;lt;key column=“外键名”&amp;gt;
  &amp;lt;one-to-many class=“集合存放的类名”&amp;gt;
&amp;lt;/set&amp;gt;
&amp;lt;!-- 配置onne-to-many关系 --&amp;gt;
  &amp;lt;set name=“stus” cascade=“联级”&amp;gt;
  &amp;lt;key column=“depart_id”&amp;gt;
  &amp;lt;one-to-many class=“Student”&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;one-to-one&#34;&gt;one-to-one&lt;/h3&gt;
&lt;p&gt;一对一有两种方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基于主键的一对一:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;主键关联映射：其中一个表的主键依赖于另一张表的主键而建立起的一对一的关系，这两张互相关联的表的主键一致.&lt;/li&gt;
&lt;li&gt;必须为one-to-one元素增加constrained=&amp;ldquo;true&amp;quot;属性，表明该类的主键由关联类生成.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;【要点】&lt;/b&gt;Person - IdCard&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./17.png&#34; alt=&#34;png&#34;&gt;
&lt;img src=&#34;./18.png&#34; alt=&#34;png&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;id name=”id”&amp;gt;
&amp;lt;generator class=”foreign”&amp;gt;
&amp;lt;param name=”property”&amp;gt;idCard&amp;lt;/param&amp;gt;
&amp;lt;/generator&amp;gt;
&amp;lt;/id&amp;gt;
&amp;lt;one-to-one name=”idCard” constrained=”true”/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;基于外键的一对一
和&lt;many-to-one&gt;N-1相同，多添加一个unique=&amp;ldquo;true&amp;rdquo; 属性，用以表示N的一端必须唯一，加了唯一约束，即成了1-1&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;b&gt;【举例】&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;one-to-one name=”idCard” property-ref=“person”/&amp;gt;             
&amp;lt;many-to-one name=”person” unique=”true” /&amp;gt;
# property-ref：用于指定关联类的一个属性，这个属性将会和本外键相对应
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;many-to-many&#34;&gt;many-to-many&lt;/h3&gt;
&lt;p&gt;　　学生←→课程   顾客←→商品
student:one-to-mangy
&lt;img src=&#34;./19.png&#34; alt=&#34;png&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Student{
  private Integer id;
  private String name;
  private Set&amp;lt;StuCourse&amp;gt; stuCourses;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从stucourse的角度看是 many-to-one
&lt;img src=&#34;./20.png&#34; alt=&#34;png&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class StuCourse{
  private Integer id;
  private Student student;
  private Course course;
  private Integer grade;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;courset:one-to-mangy
&lt;img src=&#34;./21.png&#34; alt=&#34;png&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Course{
  private Integer id;
  private String name;
  private Set&amp;lt;StuCourse&amp;gt; stuCourses;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;cascadeemployee-departmentbbs项目等&#34;&gt;cascade（Employee-Department、bbs项目等）&lt;/h3&gt;
&lt;p&gt;所谓级联操作就是说，当进行某个操作（添加/删除/修改…），就有hibernate自动完成. 例如：Department←→Employee当某个部门被删除后，员工也不会存在. 常用的cascade：none、all、save-update、delete、lock、refresh、evict、replic、persist、merge、delete-orphan(one-to-many). 一般对many-to-many，many-to-one不设置联级，在one-to-many和one-to-one中设置联级.&lt;/p&gt;
&lt;h3 id=&#34;在jsp页面中获取项目名称&#34;&gt;在JSP页面中获取项目名称：&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%=this.getServletContext().getContextPath()%&amp;gt; //java片段
${ pageContext.request.contextPath } //通过标签
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;缓存&#34;&gt;缓存&lt;/h2&gt;
&lt;p&gt;　　缓存的作用主要用来提高性能，可以简单的理解成一个Map；使缓存涉及到三个操作：把数据放入缓存、从缓存获取数据、删除缓存中的无效数据.&lt;/p&gt;
&lt;h3 id=&#34;一级缓存session级共享&#34;&gt;一级缓存（Session级共享）&lt;/h3&gt;
&lt;p&gt;一级缓存是 session对象中一块内存.
在同一个session中，查询一个对象是不会发出sql语句.
session关闭一级缓存不存在了，再查询对象，会发出sql.&lt;/p&gt;
&lt;p&gt;save，update，saveOrUpdate，load，get，list，iterator，lock这些方法都会将对象放在一级缓存中，一级缓存不能控制缓存的数量，所以要注意将大批量操作数据时可能造成内存溢出；可以用evict(清楚一个对象)，clear(清除所有对象)方法清除缓存的内容.
用HashMap来模拟一个Session缓存，加深对缓存的深入.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.hsp.view;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
public class MyCache {
  //使用map来模拟缓存
  static Map&amp;lt;Integer,Student&amp;gt; maps=new HashMap&amp;lt;Integer,Student&amp;gt;();
  public static void main(String[] args) {
    // TODO Auto-generated method stub

    getStudent(1);
    getStudent(1);
    getStudent(1);
    getStudent(1);
    getStudent(3);
    getStudent(3);
  }

  public static Student getStudent(Integer id){  //s.get()
    //先到缓存去
    if(maps.containsKey(id)){
      //在缓存有
      System.out.println(&amp;quot;从缓存取出&amp;quot;);
      return maps.get(id);
    }else{
      System.out.println(&amp;quot;从数据库中取&amp;quot;);
      //到数据库取
      Student stu=MyDB.getStudentFromDB(id);
      //放入缓存
      maps.put(id, stu);
      return stu;
    }
  }
}

//我的数据库
class MyDB{	
  static List&amp;lt;Student&amp;gt; lists=new  ArrayList&amp;lt;Student&amp;gt;();
  //初始化数据库,假设有三个学生
  static{
    Student s1=new Student();
    s1.setId(1);
    s1.setName(&amp;quot;aaa&amp;quot;);
    Student s2=new Student();
    s2.setId(2);
    s2.setName(&amp;quot;bbb&amp;quot;);
    Student s3=new Student();
    s3.setId(3);
    s3.setName(&amp;quot;ccc&amp;quot;);
    lists.add(s1);
    lists.add(s2);
    lists.add(s3);
  }
  public static Student getStudentFromDB(Integer id){
    for(Student s: lists){
      if(s.getId().equals(id)){
        return s;
      }
    }
    return null;// 在数据库中没有.
  }
}

class Student{
  private Integer id;
  private String name;
  public Integer getId() {
    return id;
  }
  public void setId(Integer id) {
    this.id = id;
  }
  public String getName() {
    return name;
  }
  public void setName(String name) {
    this.name = name;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;二级缓存sessionfactory级共享&#34;&gt;二级缓存（SessionFactory级共享）&lt;/h3&gt;
&lt;p&gt;&lt;b&gt;为什么需要二级缓存?&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;　　因为一级缓存有限(生命周期短),所以我们需要二级缓存(SessionFactory缓存)来弥补这个问题&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需要配置&lt;/li&gt;
&lt;li&gt;二级缓存是交给第三方去处理,常见的Hashtable , OSCache , EHCache&lt;/li&gt;
&lt;li&gt;二级缓存的原理；&lt;/li&gt;
&lt;li&gt;二级缓存的对象可能放在内存，也可能放在磁盘.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用OsCache来演示二级缓存的使用.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;配置二级缓存&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对配置说明:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;property name=&amp;quot;hbm2ddl.auto&amp;quot;&amp;gt;update&amp;lt;/property&amp;gt;
  &amp;lt;!-- 启动二级缓存 --&amp;gt;
  &amp;lt;property name=&amp;quot;cache.use_second_level_cache&amp;quot;&amp;gt;true&amp;lt;/property&amp;gt;
  &amp;lt;!-- 指定使用哪种二级缓存 --&amp;gt;
  &amp;lt;property name=&amp;quot;cache.provider_class&amp;quot;&amp;gt;org.hibernate.cache.OSCacheProvider&amp;lt;/property&amp;gt;
  &amp;lt;mapping resource=&amp;quot;com/hsp/domain/Department.hbm.xml&amp;quot; /&amp;gt;
  &amp;lt;mapping resource=&amp;quot;com/hsp/domain/Student.hbm.xml&amp;quot; /&amp;gt;
  &amp;lt;!-- 指定哪个domain启用二级缓存 
  特别说明二级缓存策略:
  1. read-only
  2. read-write
  3. nonstrict-read-write
  4. transcational
  --&amp;gt;
  &amp;lt;class-cache class=&amp;quot;com.hsp.domain.Student&amp;quot; usage=&amp;quot;read-write&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;可以把oscache.properties文件放在 src目录下，这样你可以指定放入二级缓存的对象capacity 大小. 默认1000.&lt;/li&gt;
&lt;li&gt;使用&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;// TODO Auto-generated method stub
//通过获取一个sesion,让hibernate框架运行(config-&amp;gt;加载hibernate.cfg.xml)
Session s=null;
Transaction tx=null;		
try {
//我们使用基础模板来讲解.
s=HibernateUtil.openSession();
tx=s.beginTransaction();			
//查询45号学生		
Student stu1=(Student) s.get(Student.class, 45);//45-&amp;gt;一级缓存		System.out.println(stu1.getName());
tx.commit();			
} catch (Exception e) {
  e.printStackTrace();
  if(tx!=null){
    tx.rollback();
  }
}finally{			
  if(s!=null &amp;amp;&amp;amp; s.isOpen()){
    s.close();
  }
}		
System.out.println(&amp;quot;*********************************&amp;quot;);
try {
  //我们使用基础模板来讲解.
  s=HibernateUtil.openSession();
  tx=s.beginTransaction();			
  //查询45号学生		
  Student stu1=(Student) s.get(Student.class, 45);	
  System.out.println(stu1.getName());			
  Student stu3=(Student) s.get(Student.class, 46);	
  System.out.println(stu3.getName());
    tx.commit();			
} catch (Exception e) {
  e.printStackTrace();
  if(tx!=null){
    tx.rollback();
  }
}finally{
  
  if(s!=null &amp;amp;&amp;amp; s.isOpen()){
    s.close();
  }
}

//完成一个统计，统计的信息在Sessfactory
//SessionFactory对象.
Statistics statistics= HibernateUtil.getSessionFactory().getStatistics();
System.out.println(statistics);
System.out.println(&amp;quot;放入&amp;quot;+statistics.getSecondLevelCachePutCount());
System.out.println(&amp;quot;命中&amp;quot;+statistics.getSecondLevelCacheHitCount());
System.out.println(&amp;quot;错过&amp;quot;+statistics.getSecondLevelCacheMissCount());
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;在配置了二级缓存后，请大家要注意可以通过 Statistics,查看你的配置命中率高不高.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;事务管理&#34;&gt;事务管理&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;在hibernate设置隔离级别
在hibernate.cfg.xml中设置隔离级别：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 事务隔离级别 --&amp;gt;
&amp;lt;property name=&amp;quot;hibernate.connection.isolation&amp;quot;&amp;gt;4&amp;lt;/property&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;事务控制在哪里进行？&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;service(){
  session.beginTransaction;//开启事务
  try{
  调用dao方法1
  调用dao方法2
  .....
    session.getTransaction().commit();//提交事务
  }catch(Exception ex){
    session.getTransaction().rollback();//回滚事务
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;session如何管理&#34;&gt;session如何管理&lt;/h3&gt;
&lt;p&gt;　　在service接口中，每个dao请求中使用同一个session即使用同一个数据库连接，保证多个dao调用在一个事务中. 在service执行开始处开启一个新session，将session和当前线程绑定，在每个dao调用中获取当前线程绑定的session，实现每个dao获取到的session是同一个session.
&lt;img src=&#34;./23.png&#34; alt=&#34;png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;主键增长策略&#34;&gt;主键增长策略&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;increment:
自增，每次增长1, 适用于所有数据库. 但是不要使用在多进程,主键类型是数值型 select max(id) from Student&lt;/li&gt;
&lt;li&gt;identity :
自增，每次增长1, 适用于支持identity的数据(mysql,sql server), 主键类型是数值&lt;/li&gt;
&lt;li&gt;sequence&lt;/li&gt;
&lt;li&gt;native:会根据数据类型来选择，使用identity,sequence ,hilo select hibernate_sequence.nextval from dual.主键类型是数值long , short ,int&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;id name=&amp;quot;id&amp;quot; type=&amp;quot;java.lang.Integer&amp;quot;&amp;gt; 
&amp;lt;generator class=&amp;quot;native&amp;quot;/&amp;gt;
&amp;lt;/id&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;hilo:hilo标识符生成器由Hibernate按照一种high/low算法生成标识符.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;b&gt;用法:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;id name=”id” type=”java.lang.Integer” column=”ID”&amp;gt;
&amp;lt;generator class=”hilo”&amp;gt;
  &amp;lt;param name=”table”&amp;gt;my_hi_value&amp;lt;/param&amp;gt;
  &amp;lt;param name=”column”&amp;gt;next_value&amp;lt;/param&amp;gt;
&amp;lt;/generator&amp;gt;
&amp;lt;/id&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;uuid:
会根据uuid算法，生成128-bit的字串
主键属性类型不能是数值型，而是字串型&lt;/li&gt;
&lt;li&gt;assigned:
用户自己设置主键值，所以主键属性类型可以是数值，字串&lt;/li&gt;
&lt;li&gt;映射复合主键&lt;/li&gt;
&lt;li&gt;foreign:
在one-to-one的关系中，有另一张表的主键(Person) 来决定 自己主键/外键( IdCard)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;给出一个简单原则:&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;针对oracle [主键是int/long/short 建议使用 sequence] 主键是String 使用uuid或者assinged&lt;/li&gt;
&lt;li&gt;针对 mysql [主键是 int/long/short 建议使用increment/assigend ,如果是字串 UUId/assigned]&lt;/li&gt;
&lt;li&gt;针对 sql server [主键是 int/long/short 建议使用identity/native/assinged ,如果主键是字串，使用uuid/assigned ]&lt;/li&gt;
&lt;li&gt;one-to-one 又是基于主键的则使用foreign&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;hibernate不适合的场景&#34;&gt;Hibernate不适合的场景&lt;/h2&gt;
&lt;p&gt;　　不适合OLAP（On-Line-Analytical Processing联机分析处理），已查询分析数据为主流的系统，适合OLTP（On-line transaction Processing联机事务处理）&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;OLTP&lt;/th&gt;
&lt;th&gt;OLAP&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;用户&lt;/td&gt;
&lt;td&gt;操作人员，底层管理人员&lt;/td&gt;
&lt;td&gt;决策人员，高级管理人员&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;功能&lt;/td&gt;
&lt;td&gt;日常操作管理&lt;/td&gt;
&lt;td&gt;分析决策&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DB设计&lt;/td&gt;
&lt;td&gt;面向应用&lt;/td&gt;
&lt;td&gt;面向主题&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;数据&lt;/td&gt;
&lt;td&gt;当前的，最新的，细节的，二维的分立的&lt;/td&gt;
&lt;td&gt;历史的、聚集的、多维的集成的，统一的&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;存取&lt;/td&gt;
&lt;td&gt;读/写数十条记录&lt;/td&gt;
&lt;td&gt;读/写上百万 条记录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;工作单位&lt;/td&gt;
&lt;td&gt;简单事务&lt;/td&gt;
&lt;td&gt;复杂查询&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;用户&lt;/td&gt;
&lt;td&gt;上千个&lt;/td&gt;
&lt;td&gt;上百个&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DB大小&lt;/td&gt;
&lt;td&gt;100M-GB&lt;/td&gt;
&lt;td&gt;100GB-TB&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>Struts2学习笔记</title>
      <link>https://CoMath21.github.io/post/1-struts2/</link>
      <pubDate>Fri, 29 Jan 2021 00:00:00 +0000</pubDate>
      <guid>https://CoMath21.github.io/post/1-struts2/</guid>
      <description>&lt;h2 id=&#34;1什么是struts2&#34;&gt;1、什么是Struts2:&lt;/h2&gt;
&lt;p&gt;　　Struts2是一个基于MVC设计模式的Web应用框架，它本质上相当于一个servlet，在MVC设计模式中，Struts2作为控制器(Controller)来建立模型与视图的数据交互. Struts2是WebWork2基础发展而来的.&lt;/p&gt;
&lt;h2 id=&#34;2struts2优点&#34;&gt;2、Struts2优点：&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Struts2的应用可以不依赖于Servlet API（request,response）和struts API；这种设计属于无侵入式设计.&lt;/li&gt;
&lt;li&gt;Struts2提供了拦截器,利用拦截器可以进行AOP编程,实现如权限拦截等功能.&lt;/li&gt;
&lt;li&gt;Struts2提供类型转换器,可以把特殊类型参数转换程序要的类型.&lt;/li&gt;
&lt;li&gt;Struts2提供支持多种表现层技术,如JSP,freeMarker,Velocity等.&lt;/li&gt;
&lt;li&gt;Struts2的输入校验可以对指定的方法进行校验.&lt;/li&gt;
&lt;li&gt;Struts2提供了全局范围、包范围、和Action范围的国际换资源文件管理实现.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3搭建struts2开发环境&#34;&gt;3、搭建Struts2开发环境&lt;/h2&gt;
&lt;h3 id=&#34;31开发struts2应用依赖的jar文件&#34;&gt;3.1、开发Struts2应用依赖的jar文件&lt;/h3&gt;
&lt;p&gt;开发Struts2应用需要依赖的jar文件在解压目录的lib文件夹下,不同的应用需要的JAR包是不同的. 开发Struts2程序最少需要的JAR.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;struts2-core-2.x.x.jar ：Struts2框架的核心类库.&lt;/li&gt;
&lt;li&gt;xwork-2.x.x jar ：XWork类库,Struts2在其上构建.&lt;/li&gt;
&lt;li&gt;ognl-2.6.x.jar ：对象图导航语言(Object Graph Navigation Language),struts2框架通过其读写对象的属性.&lt;/li&gt;
&lt;li&gt;freemarker-2.3.x.jar ：Struts 2的UI标签的模板使用FreeMarker编写.&lt;/li&gt;
&lt;li&gt;commons-logging-1.1.x jar ：ASF出品的日志包,Struts2框架使用这个日志包来支持Log4J和JDK1.4+的日志记录.&lt;/li&gt;
&lt;li&gt;commons-fileupload-12 .1.jar ：文件上传组件,2 .1.6版本后必须加入此文件.
&lt;img src=&#34;./1.png&#34; alt=&#34;png&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;32搭建struts2开发环境&#34;&gt;3.2、搭建Struts2开发环境&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;找到Struts2需要的几个jar包；&lt;/li&gt;
&lt;li&gt;编写配置struts2的配置文件：src下创建struts.xml文件；&lt;/li&gt;
&lt;li&gt;在web.xml中加入struts2 MVC框架启动配置&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;filter&amp;gt;
  &amp;lt;filter-name&amp;gt;struts2&amp;lt;/filter-name&amp;gt;
  &amp;lt;filter-class&amp;gt;org.apache.struts2.dispatcher.ng.filter.
StrutsPrepareAndExecuteFilter&amp;lt;/filter-class&amp;gt;
  &amp;lt;/filter&amp;gt;

  &amp;lt;filter-mapping&amp;gt;
    &amp;lt;filter-name&amp;gt;struts2&amp;lt;/filter-name&amp;gt;
    &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;
  &amp;lt;/filter-mapping&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;./2.png&#34; alt=&#34;png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;4strutsxml配置中的包介绍&#34;&gt;4、Struts.xml配置中的包介绍&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;配置包时必须指定name属性：
该属性名字可以任意,但是必须唯一,主要作用在于：如果其他包要继承该包就必须通过该属性(name属性)进行引用.&lt;/li&gt;
&lt;li&gt;包的namespace属性：
用于定义该包的命名空间,命名空间作为访问该包下Action路径的一部分. 如果不配置,默认为””(空字符串).&lt;/li&gt;
&lt;li&gt;继承方法extends：
通常每个包都应该继承struts-default包,因为Struts2很多核心的功能都是拦截器来实现的. struts-default定义了这些拦截器和Result类型；struts-default包是在struts2-core-2.jar文件中的struts-default.xml中定义的,struts-default.xml也是Struts2默认配置文件. Struts2每次都会自动加载struts-default.xml文件.&lt;br&gt;
&lt;img src=&#34;./3.png&#34; alt=&#34;png&#34;&gt;
&lt;img src=&#34;./4.png&#34; alt=&#34;png&#34;&gt;
&lt;img src=&#34;./5.png&#34; alt=&#34;png&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;41action配置中的各种默认值&#34;&gt;4.1、Action配置中的各种默认值&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;./6.png&#34; alt=&#34;png&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果没有为action指定class,默认是ActionSupport.&lt;/li&gt;
&lt;li&gt;如果没有为action指定method,默认执行action中的execute()方法.&lt;/li&gt;
&lt;li&gt;如果没有指定action的name属性,默认值为success.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;action中的result的各种转发类型&#34;&gt;Action中的result的各种转发类型&lt;/h4&gt;
&lt;p&gt;　　Struts2常用的结果类型有：dispathcher(默认值)、redirect(重定向)、redirectAction、plainText
在result中可以使用${属性名}表达式访问action中的属性,表达式里的属性名对应action中的属性.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dispathcher(默认值)：内部请求转发&lt;/li&gt;
&lt;li&gt;redirect(重定向)：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;// 格式：
&amp;lt;result type=&amp;quot;redirect&amp;quot;&amp;gt;/hello.jsp&amp;lt;/result&amp;gt;
// 如果重定向需要带参数,则用：
&amp;lt;result type=&amp;quot;redirect&amp;quot;&amp;gt;/hello.jsp?id=${id}&amp;lt;/result&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时,需要在对应的Action下有对应的变量,并且提供get属性.
注意：重定向不能访问WEB-INF下的文件.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;redirectAction(在其他*Action下)：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;// 格式：
&amp;lt;action name=&amp;quot; redirectActionName&amp;quot;&amp;gt;
&amp;lt;result type=&amp;quot; redirectAction&amp;quot;&amp;gt;重定向的name&amp;lt;/result&amp;gt;
&amp;lt;/action&amp;gt;
// 如果不不在同一个包下需配置项
&amp;lt;result type=&amp;quot; redirectAction&amp;quot;&amp;gt;
	&amp;lt;param name=&amp;quot; actionName&amp;quot;&amp;gt;xxx&amp;lt;/param&amp;gt;
&amp;lt;param name=&amp;quot; namespace&amp;quot;&amp;gt;/…/…&amp;lt;/param&amp;gt;
&amp;lt;/result&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;b&gt;补充&lt;/b&gt;.&lt;/p&gt;
&lt;p&gt;中文字符编码、解码&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编码&lt;code&gt;(java.net.URLEncoder)：URLEncoder.encode(&amp;quot;字符串&amp;quot;,&amp;quot;UTF-8&amp;quot;)&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;解码&lt;code&gt;(java.net.URLDecoder)：URLDecoder.encode(new String (request.getParameter(&amp;quot;属性名&amp;quot;).getBytes(&amp;quot;ISO8859-1&amp;quot;),&amp;quot;UTF-8&amp;quot;),&amp;quot;UTF-8&amp;quot;)&lt;/code&gt;;
JSP文件中可以用&lt;code&gt;$(param.属性名)&lt;/code&gt;访问Action中的属性(会乱码)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　plaintext(显示原始文件内容的重定向)：例如某功能需要查看源代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;action name=&amp;quot; plainText&amp;quot;&amp;gt;
	&amp;lt;result type=&amp;quot; plainText&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
&amp;lt;/action&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;注意：当该JSP文件存在中文的时候,会乱码！
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要加入：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;param name=&amp;quot; location&amp;quot;&amp;gt;/xxx.jsp&amp;lt;/param&amp;gt;&amp;lt;!—定向的路径--&amp;gt;
&amp;lt;param name=&amp;quot; charSet&amp;quot;&amp;gt;UTF-8&amp;lt;/param&amp;gt;&amp;lt;!--指定读取文件的编码--&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;附：Struts2的全视图
单个包下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;package name=&amp;quot; xxx&amp;quot; namespace=&amp;quot; /…/…&amp;quot; extends=&amp;quot; struts-default&amp;quot;&amp;gt;
&amp;lt;global-results&amp;gt;	
&amp;lt;result type=&amp;quot; mess…&amp;quot;&amp;gt;/…/…&amp;lt;/result&amp;gt;
&amp;lt;/global-results&amp;gt;
&amp;lt;/package&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;全局：(在一个包中写,然后其他包继承该包)&lt;/p&gt;
&lt;h3 id=&#34;42为action属性注入值&#34;&gt;4.2、为Action属性注入值&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;package name=&amp;quot; xxx&amp;quot; namespace=&amp;quot; /…/…&amp;quot; extends=&amp;quot; struts-default&amp;quot;&amp;gt;
&amp;lt;action name=&amp;quot; list&amp;quot; class=&amp;quot;com.haibao.HelloWorldAction&amp;quot; method=&amp;quot;execute&amp;quot;&amp;gt;
  &amp;lt;param name=&amp;quot;path &amp;quot;&amp;gt;/image&amp;lt;/param&amp;gt;
  &amp;lt;result name=&amp;quot;success &amp;quot;&amp;gt;/xxx.jsp &amp;lt;/result&amp;gt;
&amp;lt;/action&amp;gt;
&amp;lt;/package&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;附：在HelloWorldAction下必须存在“path”属性的get方法 ,访问xxx.jsp得到的是“/image”&lt;/p&gt;
&lt;h2 id=&#34;5指定struts2处理的请求后缀&#34;&gt;5、指定struts2处理的请求后缀&lt;/h2&gt;
&lt;h3 id=&#34;51默认后缀及修改&#34;&gt;5.1、默认后缀及修改&lt;/h3&gt;
&lt;p&gt;默认后缀：.action
默认后缀可以通过常量&amp;quot;struts.action.extension&amp;quot;进行修改&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;constant name=&amp;quot; struts.action.extension&amp;quot; value=&amp;quot;do&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果用户指定多个请求后缀,则多个后缀之间以英文逗号( , )隔开&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;constant name=&amp;quot; struts.action.extension&amp;quot; value=&amp;quot;do,action&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;52常用的常量&#34;&gt;5.2、常用的常量&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!--指定默认编码集,作用于HTTPServletRequest的setCharacterEncoding方法和freemarker、velocity的输出--&amp;gt;
&amp;lt;constant name=&amp;quot; struts.i18n.encoding&amp;quot; value=&amp;quot;UTF-8&amp;quot;/&amp;gt;
&amp;lt;!-- 该属性指定需要的struts2处理的后缀请求如果用户指定多个请求后缀,则多个后缀之间以英文逗号(,)隔开--&amp;gt;
&amp;lt;constant name=&amp;quot; struts.action.extension&amp;quot; value=&amp;quot;do,action&amp;quot;/&amp;gt;
&amp;lt;!-- 设置浏览器是否缓存静态内容. 默认值为true(生产环境下使用)--&amp;gt;
&amp;lt;constant name=&amp;quot;struts.serve.static.browserCache&amp;quot; value=&amp;quot;false&amp;quot;/&amp;gt;
&amp;lt;!-- 当struts的配置文件修改后,系统是否自动重新加载该文件,默认false(生产环境下使用) --&amp;gt;
&amp;lt;constant name=&amp;quot; struts.configuration.xml.reload&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
&amp;lt;!-- 开发模式下使用,这样可以打印出更详细的错误信息 --&amp;gt;
&amp;lt;constant name=&amp;quot; struts.devMode&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt; 
&amp;lt;!-- 默认的视图主题 --&amp;gt;
&amp;lt;constant name=&amp;quot; struts.ui.theme&amp;quot; value=&amp;quot;smple&amp;quot;/&amp;gt; 
&amp;lt;!-- 与Spring集成时,指定有Spring负责action对象的创建 --&amp;gt;
&amp;lt;constant name=&amp;quot; struts.objectFactory&amp;quot; value=&amp;quot;spring&amp;quot;/&amp;gt;
&amp;lt;!-- 该属性设置Struts2是否支持动态方法调用,默认为true --&amp;gt;
&amp;lt;constant name=&amp;quot; struts.enable.DynamicMethodlnvocation&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
&amp;lt;!-- 上传文件的大小限制 --&amp;gt;
&amp;lt;constant name=&amp;quot; struts.multipart.maxSize&amp;quot; value=&amp;quot;10701096&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;53常量的定义&#34;&gt;5.3、常量的定义&lt;/h3&gt;
&lt;p&gt;常量可以在struts.xml或struts.propreties中配置,建议在struts.xml中配置
在struts.xml文件中配置常量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;struts&amp;gt;
  &amp;lt;constant name=&amp;quot;struts.action.extension&amp;quot; value=&amp;quot;do&amp;quot;&amp;gt;
&amp;lt;/struts&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在struts.propreties中配置常量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struts.action.extension=do
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;常量可以在下面多个配置文件中定义,加载常量的搜索顺序为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;struts-default.xml&lt;/li&gt;
&lt;li&gt;struts-plugin.xml&lt;/li&gt;
&lt;li&gt;struts.xml&lt;/li&gt;
&lt;li&gt;struts.propreties&lt;/li&gt;
&lt;li&gt;web.xml&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;多个文件中配置了同一个常量,则后一个文件中配置的常量值会覆盖前面文件中配置的常量值.&lt;/p&gt;
&lt;h2 id=&#34;6struts2的处理流程&#34;&gt;6、Struts2的处理流程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;./7.png&#34; alt=&#34;png&#34;&gt;
　　StrutsPrepareAndExecuteFilter是Struts的核心控制器,他负责拦截由&lt;url-pattern&gt;/*&lt;/url-patternt&gt;指定的所有用户请求,当用户请求到达时,给Filter会过滤用户的请求. 默认情况下,如果用户请求路径不带后缀或者以.action结尾,这时请求被转入Struts2框架处理,否则Struts2框架将略过该请求的处理. 当请求转入Struts2框架处理时会经过一系列的拦截器,然后到Action. 与Struts1不同,Struts2对用户的每一次请求都会创建一个Action,所以Struts2中的Action是线程安全的.&lt;/p&gt;
&lt;p&gt;为应用指定多个Struts配置文件&lt;/p&gt;
&lt;p&gt;　　在大部分应用里,随着应用规模的增加,系统中Action的数量也会大大增加,导致struts.xml配置文件变得臃肿,为了避免struts.xml文件过于庞大,提高struts.xml文件的可读性,可以将一个struts.xml配置文件分解成多个配置文件,然后在struts.xml文件中包含其他配置文件(通过&lt;include&gt;元素指定多个配置文件)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;struts&amp;gt;
  &amp;lt;include file=&amp;quot;struts-user.xml&amp;quot;/&amp;gt;
  &amp;lt;include file=&amp;quot;struts-order.xml&amp;quot;/&amp;gt;
&amp;lt;/struts&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;7动态方法调用&#34;&gt;7、动态方法调用：&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;动态方法调用DMI（动态指定）,可以在url地址中动态指定action执行哪个方法,可以通过action+!+方法名. (注：只要Action对象中有这个方法,并且返回类型为String就可以调用,这样struts.xml文件配置文件就可以不需要配置method属性)：&lt;/li&gt;
&lt;li&gt;设置Struts2是否支持动态方法调用,如果没有这一行要加上去,要不然会报错误,如果你加上这一行,但是你把value值改成false,也会报错！
&lt;img src=&#34;./8.png&#34; alt=&#34;png&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;8使用通配符定义action&#34;&gt;8、使用通配符定义action&lt;/h2&gt;
&lt;p&gt;　　其中*匹配所有,在method=&amp;quot;{数字}&amp;ldquo;中用{数字}表示匹配第几个*,其中跳转页面的命名也是根据第一个*的值进行的.
&lt;img src=&#34;./9.png&#34; alt=&#34;png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;9请求参数的接收&#34;&gt;9、请求参数的接收&lt;/h2&gt;
&lt;p&gt;　　在Action中必须存在该属性并且存在该属性的set方法,这样在url中赋值才能接收到get方法直接在url后面加入&lt;code&gt;“?属性名=属性值&amp;amp;属性名=属性值”&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;91基本类型&#34;&gt;9.1、基本类型&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;./10.png&#34; alt=&#34;png&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;92复合类型&#34;&gt;9.2、复合类型&lt;/h3&gt;
&lt;p&gt;（为了减少复杂度,尽量用复合类型）
&lt;img src=&#34;./11.png&#34; alt=&#34;png&#34;&gt;
原理：Struts2首先通过反射技术调用Person的默认构造器创建product对象,然后再通过反射技术调用product中与请求参数同名的属性的setter方法来获取请求参数的值.&lt;/p&gt;
&lt;h2 id=&#34;10关于struts216接收中文请求参数乱码问题&#34;&gt;10、关于Struts2.1.6接收中文请求参数乱码问题&lt;/h2&gt;
&lt;p&gt;　　Struts2.1.6版本中存在一个Bug,即接收到的中文请求参数为乱码（以post方法提交）,原因是struts2.1.6在获取并使用了请求参数后才调用HttpServletRequest的setCharacterEncoding()方法进行编码设置,导致应用使用的就是乱码请求参数.&lt;/p&gt;
&lt;p&gt;解决方法：新建一个Filter,把这个Filter放置在Struts2的Filter之前,然后在doFilter()方法里添加一下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void doFilter(…){
  HttpServletRequest req = (HttpServletRequest)request;
  req.setCharacterEncoding(&amp;quot;UTF-8&amp;quot;);
  filterchain.doFilter(request,response);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;11自定义类型转换器&#34;&gt;11、自定义类型转换器&lt;/h2&gt;
&lt;h3 id=&#34;111局部类型转换器&#34;&gt;11.1、局部类型转换器：&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;首先需要定义类并继承DefaultTypeConverter类;&lt;/li&gt;
&lt;li&gt;在Action类所在的包下放置ActionClassName-conversion.properties文件；其中ActionClassName是Action的类名,后面的-conversion.properties是固定写法;&lt;/li&gt;
&lt;li&gt;在.properties文件中内容为：属性名称=类型转换器的全类名.
以出生年月为例：
&lt;img src=&#34;./12.png&#34; alt=&#34;png&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;112全局类型转换器&#34;&gt;11.2、全局类型转换器：&lt;/h3&gt;
&lt;p&gt;在src(根目录)下放置xwork-conversion.properties.
文件中的内容为：
带转换的类型=类型转换器的全类名
例如：java.util.Date=com.haibao.…
11.3、访问或添加属性
仅仅是为了访问添加：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public String scope() throws Exception{//方法
  ActionContext ctx = ActionContext.getContext();
  ctx.getApplication().put(&amp;quot;app&amp;quot;,&amp;quot;应用范围&amp;quot;);//往ServletContext里放入app
  ctx.getSession().put(&amp;quot;ses&amp;quot;,&amp;quot;session范围&amp;quot;)；//往ServletContext里放入ses
  ctx.put(&amp;quot;req&amp;quot;,&amp;quot;request范围&amp;quot;)；//往ServletContext里放入req
  return &amp;quot;scope&amp;quot;;//
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JSP中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;body&amp;gt;
  ${applicationScope.app}&amp;lt;br&amp;gt;
  ${sessionScope.ses}&amp;lt;br&amp;gt;
  ${requestScope.ses}&amp;lt;br&amp;gt;
&amp;lt;body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要是想得到对象：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 方法一：通过ServletActionContext类直接实现
public String rsa() throws Exception{//方法
  HttpServletRequest request = ServletActionContext.getRequest();
  ServletContext servletContext = ServletActionContext.getServletContest();
  request.setAttribute(&amp;quot;req&amp;quot;,&amp;quot;应用范围&amp;quot;);
  request.getSession().setAttribute(&amp;quot;ses&amp;quot;,&amp;quot;session范围&amp;quot;)；
  servletContext.setAttribute(&amp;quot;app&amp;quot;,&amp;quot;应用范围&amp;quot;);
  return &amp;quot;scope&amp;quot;;//
}
// 方法二：通过指定接口,有Struts框架运行时注入
public class HelloWorldAction implements ServletRequestAware,
ServletResponseAware,ServletContextAware{
  private HttpServletRequest requesr;
  private ServletContextResponse Context;
  private HttpServletResponse response;

public void setServletRequest(HttoServletRequest req){
  this.request = req;
}
public void setServletResponse(){

}
public void setServletContext(){

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;12文件上传&#34;&gt;12、文件上传&lt;/h2&gt;
&lt;h3 id=&#34;121单文件上传&#34;&gt;12.1、单文件上传&lt;/h3&gt;
&lt;p&gt;&lt;b&gt;步骤&lt;/b&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一步：在WEB-INF/lib下加入commons-fileupload-1.2.1.jar（2.1版本之后必须添加）、commons-io.jar（需要用到里面的工具类）&lt;/li&gt;
&lt;li&gt;第二步：把form表的enctype设置为：“multipart/form-data”&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;form action=&amp;quot;${pageContext.request.contextPath}/uploadAction_execute.action&amp;quot; enctype=&amp;quot;multipart/form-data&amp;quot; method=&amp;quot;post&amp;quot;&amp;gt;
    文件：&amp;lt;input type=&amp;quot;file&amp;quot; name=&amp;quot;image&amp;quot;&amp;gt;
&amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;上传&amp;quot;&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;第三步：在Action类中添加以下属性&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;public class UploadAction {
  private File image;// 文件名称
  // 如果想得到上传文件的名称,则定义文件名. 格式：文件名称+FileName
  private String imageFileName;// 得到上传文件名称
  // 如果想得到文件的类型,则定义文件名. 格式：文件名称+ContextType
  private String imageContextType;
  public String getImageFileName() {
    return imageFileName;
  }
  public void setImageFileName(String imageFileName) {
    this.imageFileName = imageFileName;
  }
  // 提供与字段名称相符的get、set属性,以便得到上传的文件
  public File getImage() {
    return image;
  }
  public void setImage(File image) {
    this.image = image;
  }
  public String execute() throws Exception {
    // 在该方法下进行保存
    String realPath = ServletActionContext.getServletContext().getRealPath(
        &amp;quot;/images&amp;quot;);// 得到根目录
    System.out.println(&amp;quot;*****&amp;quot; + realPath + &amp;quot;****&amp;quot;);
    if (image != null) {
      File savefile = new File(new File(realPath), imageFileName);// 保存到...
      if (!savefile.getParentFile().exists())
        savefile.getParentFile().mkdirs();
      FileUtils.copyFile(image, savefile);// 调用commons-io.jar下的工具类Copy文件到指定位置
      ActionContext.getContext().put(&amp;quot;message&amp;quot;, &amp;quot;上传成功&amp;quot;);// 返回信息
    }
    return &amp;quot;success&amp;quot;;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;./13.png&#34; alt=&#34;png&#34;&gt;
&lt;img src=&#34;./14.png&#34; alt=&#34;png&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;122多文件上传&#34;&gt;12.2、多文件上传&lt;/h3&gt;
&lt;p&gt;　　只需要将单文件上传的第三步：在Action类中添加以下属性中把单个文件变成数组.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class moreUploadAction {
  private File[] image;// 文件名称
  // 如果想得到上传文件的名称,则定义文件名. 格式：文件名称+FileName
  private String[] imageFileName;// 得到上传文件名称
  // 如果想得到文件的类型,则定义文件名. 格式：文件名称+ContextType
  private String[] imageContextType;
  public File[] getImage() {
    return image;
  }
  public void setImage(File[] image) {
    this.image = image;
  }
  public String[] getImageFileName() {
    return imageFileName;
  }
  public void setImageFileName(String[] imageFileName) {
    this.imageFileName = imageFileName;
  }
  public String[] getImageContextType() {
    return imageContextType;
  }
  public void setImageContextType(String[] imageContextType) {
    this.imageContextType = imageContextType;
  }
  public String execute() throws Exception {
    // 在该方法下进行保存
    String realPath = ServletActionContext.getServletContext().getRealPath(
        &amp;quot;/images&amp;quot;);// 得到根目录
    System.out.println(&amp;quot;*****&amp;quot; + realPath + &amp;quot;****&amp;quot;);
    if (image != null) {
      File savedir = new File(realPath);
      if (!savedir.exists())
        savedir.mkdirs();
      for (int i = 0; i &amp;lt; image.length; i++) {
        File savefile = new File(savedir, imageFileName[i]);// 保存到...
        FileUtils.copyFile(image[i], savefile);// 调用commons-io.jar下的工具类Copy文件到指定位置
      }
  ActionContext.getContext().put(&amp;quot;message&amp;quot;, &amp;quot;上传成功&amp;quot;);// 返回信息
    }
    return &amp;quot;success&amp;quot;;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;13自定义拦截器&#34;&gt;13、自定义拦截器&lt;/h2&gt;
&lt;p&gt;需求：对于登陆的用户可以访问Action中的所有方法,而没有登录的用户则不可以访问任何方法.&lt;/p&gt;
&lt;p&gt;方法：添加自定义拦截器. 实现&lt;code&gt;com.opensymphony.xwork2.interceptor.interceptor&lt;/code&gt;接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
public String intercept(ActionInvocation arg0) throws Exception {
  // 当拦截到Action时执行该方法
  // 得到session中存在的对象
  Object user = ActionContext.getContext()
.getSession().get(&amp;quot;user&amp;quot;);
  // 如果希望被拦截的的方法执行,调用arg0.invoke();
  if (user != null)
    return arg0.invoke();//如果User不为null,代表合法用户,允许访问方法
  // 返回的是Action中对应方法的返回值String
  ActionContext.getContext().put(&amp;quot;message&amp;quot;, &amp;quot;请先登录&amp;quot;);
  return &amp;quot;success&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在struts.xml中定义拦截器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 定义拦截器 --&amp;gt;
&amp;lt;interceptors&amp;gt;
  &amp;lt;!-- 自定义拦截器 --&amp;gt;
  &amp;lt;interceptor name=&amp;quot;permission&amp;quot; class=&amp;quot;com.haibao.interceptor.PermissionInterceptor&amp;quot; /&amp;gt;
  &amp;lt;!-- 定义拦截器栈  目的：使得Struts2自带的拦截器有效 --&amp;gt;
  &amp;lt;interceptor-stack name=&amp;quot;permissionStack&amp;quot;&amp;gt;
    &amp;lt;interceptor-ref name=&amp;quot;defaultStack&amp;quot;/&amp;gt;
    &amp;lt;interceptor-ref name=&amp;quot;permission&amp;quot;/&amp;gt;
  &amp;lt;/interceptor-stack&amp;gt;
&amp;lt;/interceptors&amp;gt;
&amp;lt;action name=&amp;quot;loginAction_*&amp;quot; class=&amp;quot;com.haibao.action.LoginAction&amp;quot;	method=&amp;quot;{1}&amp;quot;&amp;gt;
&amp;lt;result name=&amp;quot;success&amp;quot;&amp;gt;/WEB-INF/page/LoginPage.jsp&amp;lt;/result&amp;gt;
&amp;lt;interceptor-ref name=&amp;quot;permissionStack&amp;quot;/&amp;gt;
&amp;lt;/action&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：
如果直接在action中定义使用拦截器,则不会在使用Struts自带拦截器！这样Struts2的优势就没有了，所以引入拦截器栈的概念，在拦截器栈中要把Struts的拦截器写在前面，以保证web项目会首先执行Struts再带的拦截器.
如果想所有的程序都是用自定义的拦截器，可以使用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;default-interceptor-ref name=&amp;quot;permissionStack&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;效果演示：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;直接访问会被拦截：
&lt;img src=&#34;./15.png&#34; alt=&#34;png&#34;&gt;
登录后访问
&lt;img src=&#34;./16.png&#34; alt=&#34;png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;14输入校验&#34;&gt;14、输入校验&lt;/h2&gt;
&lt;p&gt;　　Struts2中可以实现对action的所有方法进行校验或者对action的指定方法进项校验，实现方法有两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;采用手工编写代码实现&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;对所有方法进行校验
　　重写validate()方法实现，validate()方法会校验action中所有的与execute方法签名相同的方法. 当某个数据校验失败时，调用addFieldError()方法往系统的fieldErrors添加校验失败信息，（为了使用addFieldError()方法，action可以继承ActionSupport），如果系统的fieldError包含失败信息，struts2会将请求转发到名为input的result. 在input视图中可以通过&amp;lt;s:fielderror/&amp;gt;显示失败信息. 需要引入标签&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%@ taglab url=&amp;quot;/struts-tags&amp;quot; prefix=&amp;quot;s&amp;quot;%&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public void validate(){
  if(this.mobile==null||&amp;quot;&amp;quot;.equals(this.mobile.trim())){
    this.addFieldError(&amp;quot;username&amp;quot;,&amp;quot;用户名不能为空&amp;quot;);
  }
  if(this.mobile==null||&amp;quot;&amp;quot;.equals(this.mobile.trim())){
    this.addFieldError(&amp;quot;mobile&amp;quot;,&amp;quot;手机号不能为空&amp;quot;);
  }else{
      if(!Pattern.compile(&amp;quot;^1[358]\\d{9}&amp;quot;).matcher(this.mobile.trim()).matches()){
      this.addFieldError(&amp;quot;mobile&amp;quot;,&amp;quot;手机号格式不正确&amp;quot;);
    }
  }		
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;对指定方法进行校验&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　重写validateXxx()方法实现，validate()方法会校验action中所有的与execute方法签名相同的方法. 当某个数据校验失败时，调用addFieldError()方法往系统的fieldErrors添加校验失败信息，（为了使用addFieldError()方法，action可以继承ActionSupport），如果系统的fieldError包含失败信息，struts2会将请求转发到名为input的result. 在input视图中可以通过&amp;lt;s:fielderror/&amp;gt;显示失败信息. 需要引入标签&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%@ taglab url=&amp;quot;/struts-tags&amp;quot; prefix=&amp;quot;s&amp;quot;%&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public void validateUpdata(){
  if(this.mobile==null||&amp;quot;&amp;quot;.equals(this.mobile.trim())){
    this.addFieldError(&amp;quot;username&amp;quot;,&amp;quot;用户名不能为空&amp;quot;);
  }
  if(this.mobile==null||&amp;quot;&amp;quot;.equals(this.mobile.trim())){
    this.addFieldError(&amp;quot;mobile&amp;quot;,&amp;quot;手机号不能为空&amp;quot;);
  }else{
      if(!Patten.compile(&amp;quot;^1[358]\\d{9}&amp;quot;).matcher(this.mobile.trim()).matches()){
      this.addFieldError(&amp;quot;mobile&amp;quot;,&amp;quot;手机号格式不正确&amp;quot;);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;输入校验的流程
&lt;ul&gt;
&lt;li&gt;类型转换器队请求参数执行类型转换，并把转换后的赋值给action中的属性.&lt;/li&gt;
&lt;li&gt;如果在执行类型转换的过程中出现异常，系统会将异常信息保存到ActionContext，conversionError拦截器将异常信息封装到fieldErrors里. 不管类型转换是否出现异常，都会进入第3步.&lt;/li&gt;
&lt;li&gt;系统通过反射技术先调用action中的validateXxx()方法，Xxx为方法名.&lt;/li&gt;
&lt;li&gt;在调用action中的validate()方法.&lt;/li&gt;
&lt;li&gt;经过上面4步，如果系统中的fieldErrors存在错误信息（即存放错误信息的集合的size&amp;gt;0），系统自动将请求转发至名称为input视图. 如果系统中的fieldErrors没有任何错误信息，系统将执行action中的处理方法.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;基于XML配置方式实现&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;　　&lt;b&gt;a) 对所有方法进行校验&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;　　在Action相同包下创建ActionClassName-validation.xml文件.
&lt;img src=&#34;./17.png&#34; alt=&#34;png&#34;&gt;
Struts2 的验证规则大概有以下数种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;required:必填校验器，要求field的值不能为null&lt;/li&gt;
&lt;li&gt;requiredstring:必填字符串校验器，要求field的值不能为null,并且长度大于0，默  认情况下会对字符串去掉前后空格&lt;/li&gt;
&lt;li&gt;int:整数校验器，要求field的值必须在整数范围内，min指定最小值，max指定最大值&lt;/li&gt;
&lt;li&gt;double:双精度浮点数校验器&lt;/li&gt;
&lt;li&gt;date:日期校验器&lt;/li&gt;
&lt;li&gt;expression:表达式校验器&lt;/li&gt;
&lt;li&gt;fieldexpression:字段表达式校验器&lt;/li&gt;
&lt;li&gt;email:电子邮件校验器，要求如果field的值非空，则必须是合法的邮件地址&lt;/li&gt;
&lt;li&gt;url:网址校验器，要求如果field的值非空，则必须是合法的url地址&lt;/li&gt;
&lt;li&gt;visitor:Visitor校验器，用于校验action的复合属性，它指定一个校验文件用于校验复合属性中的属性&lt;/li&gt;
&lt;li&gt;conversion:转换校验器&lt;/li&gt;
&lt;li&gt;stringlength:字符串长度校验器&lt;/li&gt;
&lt;li&gt;regex:正则表达式校验器&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;常用的验证规则&#34;&gt;常用的验证规则：&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;必填检验&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;validators&amp;gt;
&amp;lt;field name=&amp;quot;username&amp;quot;&amp;gt;
&amp;lt;field-validator type=&amp;quot;required&amp;quot;&amp;gt;
&amp;lt;message&amp;gt;指定检验失败的提示信息&amp;lt;/message&amp;gt;
&amp;lt;/field-validator&amp;gt;
&amp;lt;/field&amp;gt;
&amp;lt;/validators&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;必填字符串检验&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;validators&amp;gt;
&amp;lt;field name=&amp;quot;username&amp;quot;&amp;gt;
&amp;lt;field-validator type=&amp;quot;requiredstring&amp;quot;&amp;gt;
&amp;lt;param name=&amp;quot;trim&amp;quot;&amp;gt;true&amp;lt;/param&amp;gt;
&amp;lt;message&amp;gt;指定检验失败的提示信息&amp;lt;/message&amp;gt;
&amp;lt;/field-validator&amp;gt;
&amp;lt;/field&amp;gt;
&amp;lt;/validators&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;整数检验器/浮点检验&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;validators&amp;gt;
&amp;lt;field name=&amp;quot;age&amp;quot;&amp;gt;
&amp;lt;field-validator type=&amp;quot;int&amp;quot;&amp;gt;
&amp;lt;param name=&amp;quot;min&amp;quot;&amp;gt;1&amp;lt;/param&amp;gt;
&amp;lt;param name=&amp;quot;max&amp;quot;&amp;gt;150&amp;lt;/param&amp;gt;
&amp;lt;message&amp;gt;年纪必须在1到150之间&amp;lt;/message&amp;gt;
&amp;lt;/field-validator&amp;gt;
&amp;lt;/field&amp;gt;
&amp;lt;/validators&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;日期检验&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;validators&amp;gt;
&amp;lt;field name=&amp;quot;birth&amp;quot;&amp;gt;
&amp;lt;field-validator type=&amp;quot;date&amp;quot;&amp;gt;
&amp;lt;param name=&amp;quot;min&amp;quot;&amp;gt;1900-01-01&amp;lt;/param&amp;gt;
&amp;lt;param name=&amp;quot;max&amp;quot;&amp;gt;2050-02-21&amp;lt;/param&amp;gt;
&amp;lt;message key=&amp;quot;birth.range&amp;quot;/&amp;gt;
&amp;lt;/field-validator&amp;gt;
&amp;lt;/field&amp;gt;
&amp;lt;/validators&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;字段表达式检验器(要求指定字段满足一个逻辑表达式)&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;validators&amp;gt;
&amp;lt;field name=&amp;quot;re_pass&amp;quot;&amp;gt;
&amp;lt;field-validator type=&amp;quot;fieldexpression&amp;quot;&amp;gt;
&amp;lt;!--指定逻辑表达式 --&amp;gt;
&amp;lt;param name=&amp;quot;expression&amp;quot;&amp;gt; (pass eq re_pass)&amp;lt;/param&amp;gt;
&amp;lt;message&amp;gt;密码必须和确认密码相等&amp;lt;/message&amp;gt;
&amp;lt;/field-validator&amp;gt;
&amp;lt;/field&amp;gt;
&amp;lt;/validators&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;邮件地址校验&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;validators&amp;gt;
&amp;lt;field name=&amp;quot;email&amp;quot;&amp;gt;
&amp;lt;field-validator type=&amp;quot;email&amp;quot;&amp;gt;
&amp;lt;message&amp;gt;你的电子邮件地址必须是一个有效的电邮地址&amp;lt;/message&amp;gt;
&amp;lt;/field-validator&amp;gt;
&amp;lt;/field&amp;gt;
&amp;lt;/validators&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;网址检验&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;validators&amp;gt;
&amp;lt;field name=&amp;quot;url&amp;quot;&amp;gt;
&amp;lt;field-validator type=&amp;quot;url&amp;quot;&amp;gt;
&amp;lt;message&amp;gt;你的主页地址必须是一个有效的网址&amp;lt;/message&amp;gt;
&amp;lt;/field-validator&amp;gt;
&amp;lt;/field&amp;gt;
&amp;lt;/validators&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;8&#34;&gt;
&lt;li&gt;字符串长度检验&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;validators&amp;gt;
&amp;lt;field name=&amp;quot;user&amp;quot;&amp;gt;
&amp;lt;field-validator type=&amp;quot;stringlength&amp;quot;&amp;gt;
&amp;lt;param name=&amp;quot;minlength&amp;quot;&amp;gt;4&amp;lt;/param&amp;gt;
&amp;lt;param name=&amp;quot;maxlength&amp;quot;&amp;gt;20&amp;lt;/param&amp;gt;
&amp;lt;message&amp;gt;你的用户名长度必须在4到20之间&amp;lt;/message&amp;gt;
&amp;lt;/field-validator&amp;gt;
&amp;lt;/field&amp;gt;
&amp;lt;/validators&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;9&#34;&gt;
&lt;li&gt;正则表达式检验&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;validators&amp;gt;
&amp;lt;field name=&amp;quot;user&amp;quot;&amp;gt;
&amp;lt;field-validator type=&amp;quot;regex&amp;quot;&amp;gt;
&amp;lt;param name=&amp;quot;regex&amp;quot;&amp;gt;&amp;lt;![CDATA[(\w{4,25})]]&amp;gt;&amp;lt;/param&amp;gt;
&amp;lt;message&amp;gt;您输入的用户名只能是字母和数组，且长度必须在4到25之间&amp;lt;/message&amp;gt;
&amp;lt;/field-validator&amp;gt;
&amp;lt;/field&amp;gt;
&amp;lt;/validators
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;　　&lt;b&gt;b) 对指定方法进行校验&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;　　取名更改为ActionClassName-ActionName-validation.xml&lt;/p&gt;
&lt;p&gt;&lt;b&gt;注意&lt;/b&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当action同时提供了两个校验方法，则按照“所有方法”，“指定方法”的顺序汇总后执行；如果后面的文件包含前面文件的方法发生冲突，则只是用后面文件中的校验规则.&lt;/li&gt;
&lt;li&gt;当action继承了另外一个action，父类action的校验文件会先被搜索到.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;15国际化&#34;&gt;15、国际化&lt;/h2&gt;
&lt;p&gt;准备资源文件，资源文件的命名格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;baseName_language_country.propeties
baseName_language.propeties
baseName.propeties
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中baseName是资源文件的基本名，可以自定义，但language和country必须是java支持的语言和国家.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;中国：baseName_zh_CN.properties&lt;/li&gt;
&lt;li&gt;美国：baseName_en_US.properties&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果没有使用开发工具，对于中文的属性文件，应该使用JDK提供的native2ascii命令把文件转换为Unicode编码的文件. 命令使用如下：
native2ascii 源文件.properties 目标文件.properties&lt;/p&gt;
&lt;h3 id=&#34;151配置全局资源与输出国际化信息&#34;&gt;15.1、配置全局资源与输出国际化信息&lt;/h3&gt;
&lt;p&gt;当准备好资源文件之后，可以在struts.xml中通过struts.custom.i18n.resources常量把资源文件定义为全局变量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;constant name=&amp;quot;struts.custom.i18n.resources&amp;quot; value=&amp;quot;baseName&amp;quot;/ &amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中baseName为资源的基本名.
之后就可以在页面或者action中访问国际化信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在JSP页面中使用&lt;code&gt;&amp;lt;s:text name=&amp;quot;&amp;quot;/&amp;gt;&lt;/code&gt;标签输出国际化信息；&lt;code&gt;&amp;lt;s:text name=&amp;quot;user&amp;quot;/&amp;gt;&lt;/code&gt;,name为资源文件中的Key.&lt;/li&gt;
&lt;li&gt;在Action类中，可以继承ActionSupport，使用getText()方法得到国际化信息，该方法的第一个参数用于指定资源文件中的Key.&lt;/li&gt;
&lt;li&gt;在表单标签中，通过Key属性指定资源文件中的Key，如：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;s:textfield name=&amp;quot;realname&amp;quot; key=&amp;quot;use&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;输出带占位符的国际化信息&#34;&gt;输出带占位符的国际化信息&lt;/h4&gt;
&lt;p&gt;资源文件中的内容如下：
welcome={0},你好{1}&lt;/p&gt;
&lt;h3 id=&#34;152jsp页面中输出占位符的国际化信息&#34;&gt;15.2、JSP页面中输出占位符的国际化信息&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;s:text name=&amp;quot;welcome&amp;quot;&amp;gt;
  &amp;lt;s:param&amp;gt;熊大&amp;lt;/s:param&amp;gt;
  &amp;lt;s:param&amp;gt;学习&amp;lt;/s:param&amp;gt;
&amp;lt;s:text/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;　　在Action类中获取带占位符的国际化信息，可以使用getText(String Key，String[] args)或者getText(String Key，List args)方法&lt;/p&gt;
&lt;h3 id=&#34;153包范围资源文件&#34;&gt;15.3、包范围资源文件&lt;/h3&gt;
&lt;p&gt;　　在一个大型应用中，整个应用有大量的内容需要实现国际化，如果把国际化的内容放置在全局资源属性文件中，显然会导致资源文件变的庞大、臃肿、不便于维护，支个时候可以针对不同末班，使用包范围来组织国际化文件.&lt;/p&gt;
&lt;p&gt;方法：在java的包下放置package_language_country.properties资源文件，package为固定写法，处于该包及子包下的action都可以访问该资源，当查到指定Key的消息时，系统会先从package资源文件查找，当不存在对应的Key时，才会从常量struts.custom.i18n.resources指定的资源文件中寻找.&lt;/p&gt;
&lt;h3 id=&#34;154action范围资源文件&#34;&gt;15.4、Action范围资源文件&lt;/h3&gt;
&lt;p&gt;　　在Action类所在的路径，放置ActionClassName_languaage_country.properties资源文件，ActionClassName为action类的简单名称；当指定key的消息时，系统会先从ActionClassName_languaage_country.properties资源文件中查找.&lt;/p&gt;
&lt;h3 id=&#34;155jsp中直接访问某个资源文件&#34;&gt;15.5、JSP中直接访问某个资源文件&lt;/h3&gt;
&lt;p&gt;struts2提供了&amp;lt;s:i18n&amp;gt;标签，使用&amp;lt;s:i18n&amp;gt;标签可以在类路径下直接从某个资源文件中获取国际化数据，无需任何配置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;s:i18n name=&amp;quot;realname&amp;quot;&amp;gt;
  &amp;lt;s:text name=&amp;quot;realname&amp;quot;/&amp;gt;
&amp;lt;s:i18n&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;realname为要访问的资源文件的基本名&lt;/p&gt;
&lt;p&gt;如果要访问的资源文件在类路径的某个包下，可以访问：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;s:i18n name=&amp;quot;com/haibao/action/package&amp;quot;&amp;gt;
  &amp;lt;s:text name=&amp;quot;realname&amp;quot;&amp;gt;
    &amp;lt;s:param&amp;gt;熊大&amp;lt;/s:param&amp;gt;
  &amp;lt;/s:text/&amp;gt;
&amp;lt;s:i18n&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面访问com.haibao.action包下基本名为&lt;font color=red&gt;package&lt;/font&gt;的资源文件.&lt;/p&gt;
&lt;h2 id=&#34;16ognl表达式语言&#34;&gt;16、OGNL表达式语言&lt;/h2&gt;
&lt;p&gt;　　OGNL是Object Graphic Navigation Language（对象图导航语言）的缩写，是一个开源的项目. Struts2框架采用OGNL作为默认的表达式语言.&lt;/p&gt;
&lt;p&gt;相对于EL表达式，OGNL提供了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持对象方法调用：如xxx.sayHello()；&lt;/li&gt;
&lt;li&gt;支持类静态方法调用和值访问，表达式的格式为@[类全名（包括路径）]@[方法名|值名]
例如：&lt;code&gt;@java.lang.String@format(&#39;foo %s&#39;，bar)&lt;/code&gt;
或者 &lt;code&gt;@com.haibao.Constant@APP_NAME&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;操作集合对象.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　Ognl有一个上下文（Context）概念，它实现了了java.utils.Map接口，Struts2中说明：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;上下文（Context）的实现为ActionContext. 当Struts2接受一个请求时，会迅速创建ActionContext，ValueStack，action. 然后把action存进ValueStack，所以action的实例变量可以被OGNL访问.&lt;/li&gt;
&lt;li&gt;访问上下文（Context）中的对象需要使用#符号标注命名空间. 如&lt;code&gt;#application、#session&lt;/code&gt;. 如：&lt;code&gt;#application[&#39;userName&#39;]==#application.userName//获得application中userName值. &lt;/code&gt;
（#session对象、#request对象、#paramete对象、attr对象—按照page—request—session—application顺序访问其属性）.&lt;/li&gt;
&lt;li&gt;OGNL设定了一个跟对象（root）对象，在Struts2中根对象就是ValueStack（值栈）. 如果访问根对象中的属性，则可以省略#命名空间，直接访问该对象的属性即可. 如：${foo}//获得栈值中某个对象的foo属性.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意：Struts2中，OGNL表达式需要配合Struts标签使用. 如：&lt;code&gt;&amp;lt;s:property value=&amp;quot;name&amp;quot;&amp;gt;&lt;/code&gt;；使用EL表达式能够访问valueStack中对象的属性，原因是：Struts2对HTTPServletRequest作了进一步的封装.&lt;/p&gt;
&lt;h2 id=&#34;17采用ognl表达式创建listmap集合对象&#34;&gt;17、采用OGNL表达式创建List/Map集合对象&lt;/h2&gt;
&lt;h3 id=&#34;171试用如下直接生成一个list对象&#34;&gt;17.1、试用如下直接生成一个List对象：&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;s:set name=&amp;quot;list&amp;quot; value=&amp;quot;{&#39;zhangsan&#39;,&#39;lisi&#39;,&#39;wangwu&#39;}&amp;quot;/&amp;gt;
&amp;lt;s:iterator value=&amp;quot;#list&amp;quot;&amp;gt;&amp;lt;!-- 迭代器 --&amp;gt;
	&amp;lt;s:property/&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;/s:iterator&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;./18.png&#34; alt=&#34;png&#34;&gt;
　　Set标签用于将某个值放入指定范围&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;scope：指定变量被放置的范围，该属性可以接受application、session、request、page或action. 如果没有设置该属性，则默认放置在OGNL Context中.&lt;/li&gt;
&lt;li&gt;value：赋给变量的值，如果没有设置该属性，则将ValueStack栈顶的值赋值给变量.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;生成一个Map对象：(Key&amp;ndash;Value)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;s:set name=&amp;quot;foobar&amp;quot; value=&amp;quot;#{&#39;k1&#39;: &#39;value1&#39;,&#39;k2&#39;:&#39;value2&#39;}&amp;quot;/&amp;gt;
&amp;lt;s:iterator value=&amp;quot;# foobar &amp;quot;&amp;gt;&amp;lt;!-- 迭代器 --&amp;gt;
  &amp;lt;s:property value=&amp;quot;key&amp;quot;/&amp;gt;=&amp;lt;s:property value=&amp;quot;value&amp;quot;/&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;/s:iterator&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;java 迭代方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for(Map.Entry&amp;lt;String,Integer&amp;gt;entry:maps.entrySet){
  System.out.println(entry.getKey()+&amp;quot;=&amp;quot;+entry.getValue());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;18采用ognl表达式判断对象是否存在于集合中&#34;&gt;18、采用OGNL表达式判断对象是否存在于集合中&lt;/h2&gt;
&lt;p&gt;使用in和not in
in表达式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;s:if test=&amp;quot;foor&amp;quot; in {&#39;foo&#39;, &#39;bar&#39;}&amp;gt;
在
&amp;lt;/s:if&amp;gt;
&amp;lt;s:else&amp;gt;
  不在
&amp;lt;/s:else&amp;gt;
not in 表达式
&amp;lt;s:if test=&amp;quot;foor&amp;quot; not in {&#39;foo&#39;,&#39;bar&#39;}&amp;gt;
  不在
&amp;lt;/s:if&amp;gt;
&amp;lt;s:else&amp;gt;
  在
&amp;lt;/s:else&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;附加：
除了in和not in之外OGNL还允许使用某个规则获得集合对象的子集&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;?:获得所有符合逻辑的元素.&lt;/li&gt;
&lt;li&gt;^:获得符合逻辑的第一个元素.&lt;/li&gt;
&lt;li&gt;$:获得符合逻辑的最后一个元素.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;s:iterator value=&amp;quot;books.{?#this.price}35}&amp;quot;	/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;19常用标签&#34;&gt;19、常用标签&lt;/h2&gt;
&lt;h3 id=&#34;191propert标签&#34;&gt;19.1、propert标签：&lt;/h3&gt;
&lt;p&gt;用于输出指定值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;s:set name=&amp;quot;name&amp;quot; value=&amp;quot;kk&amp;quot;/&amp;gt;
&amp;lt;s:property value=&amp;quot;#name&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;default:可选属性，如果需要输出指定的属性值为null，则显示该属性指定的值.&lt;/li&gt;
&lt;li&gt;value：可选属性，指定需要输出的属性值，如果没有指定该属性，则默认输出ValueStack栈顶的值.&lt;/li&gt;
&lt;li&gt;escape：可选属性，指定是否格式化HTML代码.&lt;/li&gt;
&lt;li&gt;id：可选属性，指定还元素的标识.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;192iterator标签&#34;&gt;19.2、iterator标签&lt;/h3&gt;
&lt;p&gt;iterator标签用于对集合进行迭代，治理的集合包含List、Set和数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;s:set name=&amp;quot;list&amp;quot; value=&amp;quot;{&#39;foo&#39;,&#39;bar&#39;}&amp;quot;/&amp;gt;
&amp;lt;s:iterator value=&amp;quot;#list&amp;quot; status=&amp;quot;st&amp;quot;&amp;gt;
&amp;lt;s:color=&amp;lt;s:if test=&amp;quot;#st.odd&amp;quot;&amp;gt;red&amp;lt;/s:if&amp;gt;&amp;lt;s:else&amp;gt;blue&amp;lt;/s:else&amp;gt;&amp;gt;
  &amp;lt;s:property/&amp;gt;&amp;lt;/font&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;/s:iterator&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;value:可选属性，指定被迭代的集合，如果没有设置该属性，则使用ValueStack栈顶的集合&lt;/li&gt;
&lt;li&gt;id:可选属性，指定即合理元素的id. （过时）&lt;/li&gt;
&lt;li&gt;status：该属性指定迭代时的IteratorStatus实例. 该实例包含以下几个方法：
&lt;ul&gt;
&lt;li&gt;int getCount()，返回当前迭代了几个元素&lt;/li&gt;
&lt;li&gt;int getIndex()，返回当前迭代元素的索引&lt;/li&gt;
&lt;li&gt;boolean isEven()，返回当前被迭代元素的索引是否为偶数&lt;/li&gt;
&lt;li&gt;boolean isOdd()，返回当前被迭代元素的索引是否为奇数&lt;/li&gt;
&lt;li&gt;boolean isFirst()，返回当前被迭代元素的索引是否是第一个元素&lt;/li&gt;
&lt;li&gt;boolean isLast()，返回当前被迭代元素的索引是否最后一个元素&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;193url标签&#34;&gt;19.3、url标签&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;s:url value=&amp;quot;hellowoeld_add&amp;quot; namespace=&amp;quot;/test&amp;quot;&amp;gt;&amp;lt;s:param name=&amp;quot;person&amp;quot; value=&amp;quot;23&amp;quot;/&amp;gt;&amp;lt;/s:url&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生成类似如下路径：
/&lt;font color=red&gt;struts&lt;/font&gt;/test/helloworld_add&lt;font color=red&gt;.adtion&lt;/font&gt;?persom=23
红色部分为内容路径&lt;/p&gt;
&lt;p&gt;当标签的属性作为字符串类型处理时，“%”符号的用途试计算OGNL表达式的值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;s:set value=&amp;quot;myurl&amp;quot; value=&#39;&amp;quot;http://www.sohu.com&amp;quot;&#39;/&amp;gt;
&amp;lt;s:url value=&amp;quot;myurl&amp;quot;/&amp;gt;&amp;lt;/br&amp;gt;
&amp;lt;s:url value=&amp;quot;%{#myurl}&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# myurl
http://www.sohu.com
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;194表单标签checkboxlist复选框&#34;&gt;19.4、表单标签：checkboxlist复选框&lt;/h3&gt;
&lt;p&gt;如果集合为list&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;s:checkboxlist name=&amp;quot;list&amp;quot; list=&amp;quot;{&#39;Java&#39;,&#39;.Net&#39;,&#39;Ror&#39;,&#39;PHP&#39;}&amp;quot; value=&amp;quot;{&#39;Java&#39;,&#39;.Net&#39;}&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生成如下html代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&amp;quot;checkbox&amp;quot; name=&amp;quot;list&amp;quot; value=&amp;quot;Java&amp;quot; checked=&amp;quot;checked&amp;quot;/&amp;gt;&amp;lt;lable&amp;gt;Java&amp;lt;/lable&amp;gt;
&amp;lt;input type=&amp;quot;checkbox&amp;quot; name=&amp;quot;list&amp;quot; value=&amp;quot;.Net&amp;quot; checked=&amp;quot;checked&amp;quot;/&amp;gt;&amp;lt;lable&amp;gt;.Net&amp;lt;/lable&amp;gt;
&amp;lt;input type=&amp;quot;checkbox&amp;quot; name=&amp;quot;list&amp;quot; value=&amp;quot; Ror&amp;quot;/&amp;gt;&amp;lt;lable&amp;gt;Ror&amp;lt;/lable&amp;gt;
&amp;lt;input type=&amp;quot;checkbox&amp;quot; name=&amp;quot;list&amp;quot; value=&amp;quot; PHP&amp;quot;/&amp;gt;&amp;lt;lable&amp;gt;PHP&amp;lt;/lable&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果集合为Map&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;s:checkboxlist name=&amp;quot;map&amp;quot; list=&amp;quot;#{1:&#39;Java&#39;,2:&#39;.Net&#39;,3:&#39;Ror&#39;,4:&#39;PHP&#39;}&amp;quot; listKey=&amp;quot;key&amp;quot; listValue=&amp;quot;value&amp;quot; value=&amp;quot;{1,2,3}&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生成如下html代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&amp;quot;checkbox&amp;quot; name=&amp;quot;map&amp;quot; value=&amp;quot;1&amp;quot; checked=&amp;quot;checked&amp;quot;/&amp;gt;&amp;lt;lable&amp;gt;Java&amp;lt;/lable&amp;gt;
&amp;lt;input type=&amp;quot;checkbox&amp;quot; name=&amp;quot;map&amp;quot; value=&amp;quot;2&amp;quot; checked=&amp;quot;checked&amp;quot;/&amp;gt;&amp;lt;lable&amp;gt;.Net&amp;lt;/lable&amp;gt;
&amp;lt;input type=&amp;quot;checkbox&amp;quot; name=&amp;quot;map&amp;quot; value=&amp;quot;3&amp;quot; checked=&amp;quot;checked&amp;quot;/&amp;gt;&amp;lt;lable&amp;gt;Ror&amp;lt;/lable&amp;gt;
&amp;lt;input type=&amp;quot;checkbox&amp;quot; name=&amp;quot;map&amp;quot; value=&amp;quot;4&amp;quot;/&amp;gt;&amp;lt;lable&amp;gt;PHP&amp;lt;/lable&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果集合里存放的是javabean&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%
  Person p1 = new Person(1,&amp;quot;第一个&amp;quot;);
  Person p1 = new Person(2,&amp;quot;第一个&amp;quot;);
  List&amp;lt;Person&amp;gt; list = new ArrayList&amp;lt;Person&amp;gt;();
  list.add(p1);
  list.add(p2);
  request.setAttribute(&amp;quot;person&amp;quot;, list);
%&amp;gt;
&amp;lt;s:checkboxlist list=&amp;quot;#request.persons&amp;quot; listKey=&amp;quot;personid&amp;quot; listValue=&amp;quot;name&amp;quot;&amp;gt;&amp;lt;/s:checkboxlist&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;personid和name为Person的属性
生成如下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&amp;quot;checkbox&amp;quot; name=&amp;quot;beans&amp;quot; value=&amp;quot;1&amp;quot;/&amp;gt;&amp;lt;lable&amp;gt;第一个&amp;lt;/lable&amp;gt;
&amp;lt;input type=&amp;quot;checkbox&amp;quot; name=&amp;quot;beans&amp;quot; value=&amp;quot;2&amp;quot;/&amp;gt;&amp;lt;lable&amp;gt;第二个&amp;lt;/lable&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;195表单标签radio单选框&#34;&gt;19.5、表单标签：radio单选框&lt;/h3&gt;
&lt;p&gt;如果集合为list&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;s:radio name=&amp;quot;list&amp;quot; list=&amp;quot;{&#39;Java&#39;,&#39;.Net&#39;,&#39;Ror&#39;,&#39;PHP&#39;}&amp;quot; value=&amp;quot;&#39;Java&#39;&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生成如下html代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&amp;quot;radio&amp;quot; name=&amp;quot;list&amp;quot; value=&amp;quot;Java&amp;quot; checked=&amp;quot;checked&amp;quot;/&amp;gt;&amp;lt;lable&amp;gt;Java&amp;lt;/lable&amp;gt;
&amp;lt;input type=&amp;quot;radio&amp;quot; name=&amp;quot;list&amp;quot; value=&amp;quot;.Net&amp;quot;/&amp;gt;
&amp;lt;input type=&amp;quot;radio&amp;quot; name=&amp;quot;list&amp;quot; value=&amp;quot;Ror&amp;quot;/&amp;gt;
&amp;lt;input type=&amp;quot;radio&amp;quot; name=&amp;quot;list&amp;quot; value=&amp;quot;PHP&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果集合为Map&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;s:radio name=&amp;quot;map&amp;quot; list=&amp;quot;#{1:&#39;Java&#39;,2:&#39;.Net&#39;3:,&#39;Ror&#39;,4:&#39;PHP&#39;}&amp;quot; 
listKey=&amp;quot;key&amp;quot; listValue=&amp;quot;value&amp;quot; value=&amp;quot;1&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生成如下html代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&amp;quot;radio&amp;quot; name=&amp;quot;map&amp;quot; value=&amp;quot;1&amp;quot; checked=&amp;quot;checked&amp;quot;/&amp;gt;&amp;lt;lable&amp;gt;Java&amp;lt;/lable&amp;gt;
&amp;lt;input type=&amp;quot;radio&amp;quot; name=&amp;quot;map&amp;quot; value=&amp;quot;2&amp;quot;/&amp;gt;&amp;lt;lable&amp;gt;.Net&amp;lt;/lable&amp;gt;
&amp;lt;input type=&amp;quot;radio&amp;quot; name=&amp;quot;map&amp;quot; value=&amp;quot;3&amp;quot;/&amp;gt;&amp;lt;lable&amp;gt;Ror&amp;lt;/lable&amp;gt;
&amp;lt;input type=&amp;quot;radio&amp;quot; name=&amp;quot;map&amp;quot; value=&amp;quot;4&amp;quot;/&amp;gt;&amp;lt;lable&amp;gt;PHP&amp;lt;/lable&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果集合里存放的是javabean&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%
  Person p1 = new Person(1,&amp;quot;第一个&amp;quot;);
  Person p1 = new Person(2,&amp;quot;第一个&amp;quot;);
  List&amp;lt;Person&amp;gt; list = new ArrayList&amp;lt;Person&amp;gt;();
  list.add(p1);
  list.add(p2);
  request.setAttribute(&amp;quot;person&amp;quot;, list);
%&amp;gt;
&amp;lt;s:radio name=&amp;quot;beans&amp;quot; list=&amp;quot;#request.persons&amp;quot; listKey=&amp;quot;personid&amp;quot; listValue=&amp;quot;name&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;personid和name为Person的属性
生成如下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&amp;quot;radio&amp;quot; name=&amp;quot;beans&amp;quot; value=&amp;quot;1&amp;quot;/&amp;gt;&amp;lt;lable&amp;gt;第一个&amp;lt;/lable&amp;gt;
&amp;lt;input type=&amp;quot;radio&amp;quot; name=&amp;quot;beans&amp;quot; value=&amp;quot;2&amp;quot;/&amp;gt;&amp;lt;lable&amp;gt;第二个&amp;lt;/lable&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;196表单标签select下拉选择框&#34;&gt;19.6、表单标签select下拉选择框&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;s:select name=&amp;quot;list&amp;quot; list=&amp;quot;{&#39;Java&#39;,&#39;.Net&#39;}&amp;quot; value=&amp;quot;&#39;Java&#39;&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生成如下html代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;s:select name=&amp;quot;list&amp;quot; id=&amp;quot;list&amp;quot;&amp;gt;
&amp;lt;option value=&amp;quot;Java&amp;quot; selected=&amp;quot;selected&amp;quot;&amp;gt;Java&amp;lt;option/&amp;gt;
&amp;lt;option value=&amp;quot;.Net&amp;quot;&amp;gt;.Net &amp;lt;option/&amp;gt;
&amp;lt;/select&amp;gt;
&amp;lt;s:select name=&amp;quot;map&amp;quot; list=&amp;quot;#{1:&#39;Java&#39;,2:&#39;.Net&#39;3:,&#39;Ror&#39;,4:&#39;PHP&#39;}&amp;quot; 
listKey=&amp;quot;key&amp;quot; listValue=&amp;quot;value&amp;quot; value=&amp;quot;1&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生成如下html代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;s:select name=&amp;quot;list&amp;quot; id=&amp;quot;list&amp;quot;&amp;gt;
&amp;lt;option value=&amp;quot;1&amp;quot; selected=&amp;quot;selected&amp;quot;&amp;gt;Java&amp;lt;option/&amp;gt;
&amp;lt;option value=&amp;quot;2&amp;quot;&amp;gt;.Net&amp;lt;option/&amp;gt;
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;20stoken标签放置重复提交&#34;&gt;20、&amp;lt;s:token/&amp;gt;标签放置重复提交&lt;/h2&gt;
&lt;p&gt;&amp;lt;s:token/&amp;gt;标签放置重复提交用法如下：
第一步：在表单中加入&amp;lt;s:token/&amp;gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;s:form action=&amp;quot;Action_execute()&amp;quot; method=&amp;quot;post&amp;quot; &amp;gt;
  姓名&amp;lt;s:textfield name=&amp;quot;name&amp;quot;/&amp;gt;&amp;lt;s:token/&amp;gt;
  &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;发送&amp;quot;/&amp;gt;
&amp;lt;/s:form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二步：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;action name=&amp;quot;Action_*&amp;quot; class=&amp;quot;com.haibao.action.XMLvalidate&amp;quot;
      method=&amp;quot;{1}&amp;quot;&amp;gt;
  &amp;lt;interceptor-ref name=&amp;quot;defaultStack&amp;quot;/&amp;gt;
  &amp;lt;interceptor-ref name=&amp;quot;token&amp;quot;/&amp;gt;
  &amp;lt;result name=&amp;quot;ivalid.token&amp;quot;&amp;gt;/message.jsp&amp;lt;/result&amp;gt;
  &amp;lt;result name=&amp;quot;success&amp;quot;&amp;gt;/WEB-INF/page/message.jsp&amp;lt;/result&amp;gt;
&amp;lt;/action&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上配置加入了“token”拦截器和“ivalid.token”结果，因为“token”拦截器在会话的token与请求的token不一致时，将会直接返回“ivalid.token”结果.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
