<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Struts2 | CoMath</title>
    <link>https://CoMath21.github.io/tag/struts2/</link>
      <atom:link href="https://CoMath21.github.io/tag/struts2/index.xml" rel="self" type="application/rss+xml" />
    <description>Struts2</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh-Hans</language><copyright>© 2021 CoMath Powered by Hugo Theme Academic</copyright><lastBuildDate>Fri, 29 Jan 2021 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://CoMath21.github.io/images/logo_hud8da91bfe93f3d7d35fd2296e35ef0bf_39934_300x300_fit_lanczos_2.png</url>
      <title>Struts2</title>
      <link>https://CoMath21.github.io/tag/struts2/</link>
    </image>
    
    <item>
      <title>Struts2学习笔记</title>
      <link>https://CoMath21.github.io/post/1-struts2/</link>
      <pubDate>Fri, 29 Jan 2021 00:00:00 +0000</pubDate>
      <guid>https://CoMath21.github.io/post/1-struts2/</guid>
      <description>&lt;h2 id=&#34;1什么是struts2&#34;&gt;1、什么是Struts2:&lt;/h2&gt;
&lt;p&gt;　　Struts2是一个基于MVC设计模式的Web应用框架，它本质上相当于一个servlet，在MVC设计模式中，Struts2作为控制器(Controller)来建立模型与视图的数据交互. Struts2是WebWork2基础发展而来的.&lt;/p&gt;
&lt;h2 id=&#34;2struts2优点&#34;&gt;2、Struts2优点：&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Struts2的应用可以不依赖于Servlet API（request,response）和struts API；这种设计属于无侵入式设计.&lt;/li&gt;
&lt;li&gt;Struts2提供了拦截器,利用拦截器可以进行AOP编程,实现如权限拦截等功能.&lt;/li&gt;
&lt;li&gt;Struts2提供类型转换器,可以把特殊类型参数转换程序要的类型.&lt;/li&gt;
&lt;li&gt;Struts2提供支持多种表现层技术,如JSP,freeMarker,Velocity等.&lt;/li&gt;
&lt;li&gt;Struts2的输入校验可以对指定的方法进行校验.&lt;/li&gt;
&lt;li&gt;Struts2提供了全局范围、包范围、和Action范围的国际换资源文件管理实现.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3搭建struts2开发环境&#34;&gt;3、搭建Struts2开发环境&lt;/h2&gt;
&lt;h3 id=&#34;31开发struts2应用依赖的jar文件&#34;&gt;3.1、开发Struts2应用依赖的jar文件&lt;/h3&gt;
&lt;p&gt;开发Struts2应用需要依赖的jar文件在解压目录的lib文件夹下,不同的应用需要的JAR包是不同的. 开发Struts2程序最少需要的JAR.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;struts2-core-2.x.x.jar ：Struts2框架的核心类库.&lt;/li&gt;
&lt;li&gt;xwork-2.x.x jar ：XWork类库,Struts2在其上构建.&lt;/li&gt;
&lt;li&gt;ognl-2.6.x.jar ：对象图导航语言(Object Graph Navigation Language),struts2框架通过其读写对象的属性.&lt;/li&gt;
&lt;li&gt;freemarker-2.3.x.jar ：Struts 2的UI标签的模板使用FreeMarker编写.&lt;/li&gt;
&lt;li&gt;commons-logging-1.1.x jar ：ASF出品的日志包,Struts2框架使用这个日志包来支持Log4J和JDK1.4+的日志记录.&lt;/li&gt;
&lt;li&gt;commons-fileupload-12 .1.jar ：文件上传组件,2 .1.6版本后必须加入此文件.
&lt;img src=&#34;./1.png&#34; alt=&#34;png&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;32搭建struts2开发环境&#34;&gt;3.2、搭建Struts2开发环境&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;找到Struts2需要的几个jar包；&lt;/li&gt;
&lt;li&gt;编写配置struts2的配置文件：src下创建struts.xml文件；&lt;/li&gt;
&lt;li&gt;在web.xml中加入struts2 MVC框架启动配置&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;filter&amp;gt;
  &amp;lt;filter-name&amp;gt;struts2&amp;lt;/filter-name&amp;gt;
  &amp;lt;filter-class&amp;gt;org.apache.struts2.dispatcher.ng.filter.
StrutsPrepareAndExecuteFilter&amp;lt;/filter-class&amp;gt;
  &amp;lt;/filter&amp;gt;

  &amp;lt;filter-mapping&amp;gt;
    &amp;lt;filter-name&amp;gt;struts2&amp;lt;/filter-name&amp;gt;
    &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;
  &amp;lt;/filter-mapping&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;./2.png&#34; alt=&#34;png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;4strutsxml配置中的包介绍&#34;&gt;4、Struts.xml配置中的包介绍&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;配置包时必须指定name属性：
该属性名字可以任意,但是必须唯一,主要作用在于：如果其他包要继承该包就必须通过该属性(name属性)进行引用.&lt;/li&gt;
&lt;li&gt;包的namespace属性：
用于定义该包的命名空间,命名空间作为访问该包下Action路径的一部分. 如果不配置,默认为””(空字符串).&lt;/li&gt;
&lt;li&gt;继承方法extends：
通常每个包都应该继承struts-default包,因为Struts2很多核心的功能都是拦截器来实现的. struts-default定义了这些拦截器和Result类型；struts-default包是在struts2-core-2.jar文件中的struts-default.xml中定义的,struts-default.xml也是Struts2默认配置文件. Struts2每次都会自动加载struts-default.xml文件.&lt;br&gt;
&lt;img src=&#34;./3.png&#34; alt=&#34;png&#34;&gt;
&lt;img src=&#34;./4.png&#34; alt=&#34;png&#34;&gt;
&lt;img src=&#34;./5.png&#34; alt=&#34;png&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;41action配置中的各种默认值&#34;&gt;4.1、Action配置中的各种默认值&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;./6.png&#34; alt=&#34;png&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果没有为action指定class,默认是ActionSupport.&lt;/li&gt;
&lt;li&gt;如果没有为action指定method,默认执行action中的execute()方法.&lt;/li&gt;
&lt;li&gt;如果没有指定action的name属性,默认值为success.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;action中的result的各种转发类型&#34;&gt;Action中的result的各种转发类型&lt;/h4&gt;
&lt;p&gt;　　Struts2常用的结果类型有：dispathcher(默认值)、redirect(重定向)、redirectAction、plainText
在result中可以使用${属性名}表达式访问action中的属性,表达式里的属性名对应action中的属性.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dispathcher(默认值)：内部请求转发&lt;/li&gt;
&lt;li&gt;redirect(重定向)：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;// 格式：
&amp;lt;result type=&amp;quot;redirect&amp;quot;&amp;gt;/hello.jsp&amp;lt;/result&amp;gt;
// 如果重定向需要带参数,则用：
&amp;lt;result type=&amp;quot;redirect&amp;quot;&amp;gt;/hello.jsp?id=${id}&amp;lt;/result&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时,需要在对应的Action下有对应的变量,并且提供get属性.
注意：重定向不能访问WEB-INF下的文件.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;redirectAction(在其他*Action下)：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;// 格式：
&amp;lt;action name=&amp;quot; redirectActionName&amp;quot;&amp;gt;
&amp;lt;result type=&amp;quot; redirectAction&amp;quot;&amp;gt;重定向的name&amp;lt;/result&amp;gt;
&amp;lt;/action&amp;gt;
// 如果不不在同一个包下需配置项
&amp;lt;result type=&amp;quot; redirectAction&amp;quot;&amp;gt;
	&amp;lt;param name=&amp;quot; actionName&amp;quot;&amp;gt;xxx&amp;lt;/param&amp;gt;
&amp;lt;param name=&amp;quot; namespace&amp;quot;&amp;gt;/…/…&amp;lt;/param&amp;gt;
&amp;lt;/result&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;b&gt;补充&lt;/b&gt;.&lt;/p&gt;
&lt;p&gt;中文字符编码、解码&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编码&lt;code&gt;(java.net.URLEncoder)：URLEncoder.encode(&amp;quot;字符串&amp;quot;,&amp;quot;UTF-8&amp;quot;)&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;解码&lt;code&gt;(java.net.URLDecoder)：URLDecoder.encode(new String (request.getParameter(&amp;quot;属性名&amp;quot;).getBytes(&amp;quot;ISO8859-1&amp;quot;),&amp;quot;UTF-8&amp;quot;),&amp;quot;UTF-8&amp;quot;)&lt;/code&gt;;
JSP文件中可以用&lt;code&gt;$(param.属性名)&lt;/code&gt;访问Action中的属性(会乱码)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　plaintext(显示原始文件内容的重定向)：例如某功能需要查看源代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;action name=&amp;quot; plainText&amp;quot;&amp;gt;
	&amp;lt;result type=&amp;quot; plainText&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
&amp;lt;/action&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;注意：当该JSP文件存在中文的时候,会乱码！
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要加入：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;param name=&amp;quot; location&amp;quot;&amp;gt;/xxx.jsp&amp;lt;/param&amp;gt;&amp;lt;!—定向的路径--&amp;gt;
&amp;lt;param name=&amp;quot; charSet&amp;quot;&amp;gt;UTF-8&amp;lt;/param&amp;gt;&amp;lt;!--指定读取文件的编码--&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;附：Struts2的全视图
单个包下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;package name=&amp;quot; xxx&amp;quot; namespace=&amp;quot; /…/…&amp;quot; extends=&amp;quot; struts-default&amp;quot;&amp;gt;
&amp;lt;global-results&amp;gt;	
&amp;lt;result type=&amp;quot; mess…&amp;quot;&amp;gt;/…/…&amp;lt;/result&amp;gt;
&amp;lt;/global-results&amp;gt;
&amp;lt;/package&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;全局：(在一个包中写,然后其他包继承该包)&lt;/p&gt;
&lt;h3 id=&#34;42为action属性注入值&#34;&gt;4.2、为Action属性注入值&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;package name=&amp;quot; xxx&amp;quot; namespace=&amp;quot; /…/…&amp;quot; extends=&amp;quot; struts-default&amp;quot;&amp;gt;
&amp;lt;action name=&amp;quot; list&amp;quot; class=&amp;quot;com.haibao.HelloWorldAction&amp;quot; method=&amp;quot;execute&amp;quot;&amp;gt;
  &amp;lt;param name=&amp;quot;path &amp;quot;&amp;gt;/image&amp;lt;/param&amp;gt;
  &amp;lt;result name=&amp;quot;success &amp;quot;&amp;gt;/xxx.jsp &amp;lt;/result&amp;gt;
&amp;lt;/action&amp;gt;
&amp;lt;/package&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;附：在HelloWorldAction下必须存在“path”属性的get方法 ,访问xxx.jsp得到的是“/image”&lt;/p&gt;
&lt;h2 id=&#34;5指定struts2处理的请求后缀&#34;&gt;5、指定struts2处理的请求后缀&lt;/h2&gt;
&lt;h3 id=&#34;51默认后缀及修改&#34;&gt;5.1、默认后缀及修改&lt;/h3&gt;
&lt;p&gt;默认后缀：.action
默认后缀可以通过常量&amp;quot;struts.action.extension&amp;quot;进行修改&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;constant name=&amp;quot; struts.action.extension&amp;quot; value=&amp;quot;do&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果用户指定多个请求后缀,则多个后缀之间以英文逗号( , )隔开&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;constant name=&amp;quot; struts.action.extension&amp;quot; value=&amp;quot;do,action&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;52常用的常量&#34;&gt;5.2、常用的常量&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!--指定默认编码集,作用于HTTPServletRequest的setCharacterEncoding方法和freemarker、velocity的输出--&amp;gt;
&amp;lt;constant name=&amp;quot; struts.i18n.encoding&amp;quot; value=&amp;quot;UTF-8&amp;quot;/&amp;gt;
&amp;lt;!-- 该属性指定需要的struts2处理的后缀请求如果用户指定多个请求后缀,则多个后缀之间以英文逗号(,)隔开--&amp;gt;
&amp;lt;constant name=&amp;quot; struts.action.extension&amp;quot; value=&amp;quot;do,action&amp;quot;/&amp;gt;
&amp;lt;!-- 设置浏览器是否缓存静态内容. 默认值为true(生产环境下使用)--&amp;gt;
&amp;lt;constant name=&amp;quot;struts.serve.static.browserCache&amp;quot; value=&amp;quot;false&amp;quot;/&amp;gt;
&amp;lt;!-- 当struts的配置文件修改后,系统是否自动重新加载该文件,默认false(生产环境下使用) --&amp;gt;
&amp;lt;constant name=&amp;quot; struts.configuration.xml.reload&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
&amp;lt;!-- 开发模式下使用,这样可以打印出更详细的错误信息 --&amp;gt;
&amp;lt;constant name=&amp;quot; struts.devMode&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt; 
&amp;lt;!-- 默认的视图主题 --&amp;gt;
&amp;lt;constant name=&amp;quot; struts.ui.theme&amp;quot; value=&amp;quot;smple&amp;quot;/&amp;gt; 
&amp;lt;!-- 与Spring集成时,指定有Spring负责action对象的创建 --&amp;gt;
&amp;lt;constant name=&amp;quot; struts.objectFactory&amp;quot; value=&amp;quot;spring&amp;quot;/&amp;gt;
&amp;lt;!-- 该属性设置Struts2是否支持动态方法调用,默认为true --&amp;gt;
&amp;lt;constant name=&amp;quot; struts.enable.DynamicMethodlnvocation&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
&amp;lt;!-- 上传文件的大小限制 --&amp;gt;
&amp;lt;constant name=&amp;quot; struts.multipart.maxSize&amp;quot; value=&amp;quot;10701096&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;53常量的定义&#34;&gt;5.3、常量的定义&lt;/h3&gt;
&lt;p&gt;常量可以在struts.xml或struts.propreties中配置,建议在struts.xml中配置
在struts.xml文件中配置常量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;struts&amp;gt;
  &amp;lt;constant name=&amp;quot;struts.action.extension&amp;quot; value=&amp;quot;do&amp;quot;&amp;gt;
&amp;lt;/struts&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在struts.propreties中配置常量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struts.action.extension=do
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;常量可以在下面多个配置文件中定义,加载常量的搜索顺序为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;struts-default.xml&lt;/li&gt;
&lt;li&gt;struts-plugin.xml&lt;/li&gt;
&lt;li&gt;struts.xml&lt;/li&gt;
&lt;li&gt;struts.propreties&lt;/li&gt;
&lt;li&gt;web.xml&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;多个文件中配置了同一个常量,则后一个文件中配置的常量值会覆盖前面文件中配置的常量值.&lt;/p&gt;
&lt;h2 id=&#34;6struts2的处理流程&#34;&gt;6、Struts2的处理流程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;./7.png&#34; alt=&#34;png&#34;&gt;
　　StrutsPrepareAndExecuteFilter是Struts的核心控制器,他负责拦截由&lt;url-pattern&gt;/*&lt;/url-patternt&gt;指定的所有用户请求,当用户请求到达时,给Filter会过滤用户的请求. 默认情况下,如果用户请求路径不带后缀或者以.action结尾,这时请求被转入Struts2框架处理,否则Struts2框架将略过该请求的处理. 当请求转入Struts2框架处理时会经过一系列的拦截器,然后到Action. 与Struts1不同,Struts2对用户的每一次请求都会创建一个Action,所以Struts2中的Action是线程安全的.&lt;/p&gt;
&lt;p&gt;为应用指定多个Struts配置文件&lt;/p&gt;
&lt;p&gt;　　在大部分应用里,随着应用规模的增加,系统中Action的数量也会大大增加,导致struts.xml配置文件变得臃肿,为了避免struts.xml文件过于庞大,提高struts.xml文件的可读性,可以将一个struts.xml配置文件分解成多个配置文件,然后在struts.xml文件中包含其他配置文件(通过&lt;include&gt;元素指定多个配置文件)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;struts&amp;gt;
  &amp;lt;include file=&amp;quot;struts-user.xml&amp;quot;/&amp;gt;
  &amp;lt;include file=&amp;quot;struts-order.xml&amp;quot;/&amp;gt;
&amp;lt;/struts&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;7动态方法调用&#34;&gt;7、动态方法调用：&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;动态方法调用DMI（动态指定）,可以在url地址中动态指定action执行哪个方法,可以通过action+!+方法名. (注：只要Action对象中有这个方法,并且返回类型为String就可以调用,这样struts.xml文件配置文件就可以不需要配置method属性)：&lt;/li&gt;
&lt;li&gt;设置Struts2是否支持动态方法调用,如果没有这一行要加上去,要不然会报错误,如果你加上这一行,但是你把value值改成false,也会报错！
&lt;img src=&#34;./8.png&#34; alt=&#34;png&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;8使用通配符定义action&#34;&gt;8、使用通配符定义action&lt;/h2&gt;
&lt;p&gt;　　其中*匹配所有,在method=&amp;quot;{数字}&amp;ldquo;中用{数字}表示匹配第几个*,其中跳转页面的命名也是根据第一个*的值进行的.
&lt;img src=&#34;./9.png&#34; alt=&#34;png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;9请求参数的接收&#34;&gt;9、请求参数的接收&lt;/h2&gt;
&lt;p&gt;　　在Action中必须存在该属性并且存在该属性的set方法,这样在url中赋值才能接收到get方法直接在url后面加入&lt;code&gt;“?属性名=属性值&amp;amp;属性名=属性值”&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;91基本类型&#34;&gt;9.1、基本类型&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;./10.png&#34; alt=&#34;png&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;92复合类型&#34;&gt;9.2、复合类型&lt;/h3&gt;
&lt;p&gt;（为了减少复杂度,尽量用复合类型）
&lt;img src=&#34;./11.png&#34; alt=&#34;png&#34;&gt;
原理：Struts2首先通过反射技术调用Person的默认构造器创建product对象,然后再通过反射技术调用product中与请求参数同名的属性的setter方法来获取请求参数的值.&lt;/p&gt;
&lt;h2 id=&#34;10关于struts216接收中文请求参数乱码问题&#34;&gt;10、关于Struts2.1.6接收中文请求参数乱码问题&lt;/h2&gt;
&lt;p&gt;　　Struts2.1.6版本中存在一个Bug,即接收到的中文请求参数为乱码（以post方法提交）,原因是struts2.1.6在获取并使用了请求参数后才调用HttpServletRequest的setCharacterEncoding()方法进行编码设置,导致应用使用的就是乱码请求参数.&lt;/p&gt;
&lt;p&gt;解决方法：新建一个Filter,把这个Filter放置在Struts2的Filter之前,然后在doFilter()方法里添加一下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void doFilter(…){
  HttpServletRequest req = (HttpServletRequest)request;
  req.setCharacterEncoding(&amp;quot;UTF-8&amp;quot;);
  filterchain.doFilter(request,response);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;11自定义类型转换器&#34;&gt;11、自定义类型转换器&lt;/h2&gt;
&lt;h3 id=&#34;111局部类型转换器&#34;&gt;11.1、局部类型转换器：&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;首先需要定义类并继承DefaultTypeConverter类;&lt;/li&gt;
&lt;li&gt;在Action类所在的包下放置ActionClassName-conversion.properties文件；其中ActionClassName是Action的类名,后面的-conversion.properties是固定写法;&lt;/li&gt;
&lt;li&gt;在.properties文件中内容为：属性名称=类型转换器的全类名.
以出生年月为例：
&lt;img src=&#34;./12.png&#34; alt=&#34;png&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;112全局类型转换器&#34;&gt;11.2、全局类型转换器：&lt;/h3&gt;
&lt;p&gt;在src(根目录)下放置xwork-conversion.properties.
文件中的内容为：
带转换的类型=类型转换器的全类名
例如：java.util.Date=com.haibao.…
11.3、访问或添加属性
仅仅是为了访问添加：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public String scope() throws Exception{//方法
  ActionContext ctx = ActionContext.getContext();
  ctx.getApplication().put(&amp;quot;app&amp;quot;,&amp;quot;应用范围&amp;quot;);//往ServletContext里放入app
  ctx.getSession().put(&amp;quot;ses&amp;quot;,&amp;quot;session范围&amp;quot;)；//往ServletContext里放入ses
  ctx.put(&amp;quot;req&amp;quot;,&amp;quot;request范围&amp;quot;)；//往ServletContext里放入req
  return &amp;quot;scope&amp;quot;;//
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JSP中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;body&amp;gt;
  ${applicationScope.app}&amp;lt;br&amp;gt;
  ${sessionScope.ses}&amp;lt;br&amp;gt;
  ${requestScope.ses}&amp;lt;br&amp;gt;
&amp;lt;body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要是想得到对象：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 方法一：通过ServletActionContext类直接实现
public String rsa() throws Exception{//方法
  HttpServletRequest request = ServletActionContext.getRequest();
  ServletContext servletContext = ServletActionContext.getServletContest();
  request.setAttribute(&amp;quot;req&amp;quot;,&amp;quot;应用范围&amp;quot;);
  request.getSession().setAttribute(&amp;quot;ses&amp;quot;,&amp;quot;session范围&amp;quot;)；
  servletContext.setAttribute(&amp;quot;app&amp;quot;,&amp;quot;应用范围&amp;quot;);
  return &amp;quot;scope&amp;quot;;//
}
// 方法二：通过指定接口,有Struts框架运行时注入
public class HelloWorldAction implements ServletRequestAware,
ServletResponseAware,ServletContextAware{
  private HttpServletRequest requesr;
  private ServletContextResponse Context;
  private HttpServletResponse response;

public void setServletRequest(HttoServletRequest req){
  this.request = req;
}
public void setServletResponse(){

}
public void setServletContext(){

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;12文件上传&#34;&gt;12、文件上传&lt;/h2&gt;
&lt;h3 id=&#34;121单文件上传&#34;&gt;12.1、单文件上传&lt;/h3&gt;
&lt;p&gt;&lt;b&gt;步骤&lt;/b&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一步：在WEB-INF/lib下加入commons-fileupload-1.2.1.jar（2.1版本之后必须添加）、commons-io.jar（需要用到里面的工具类）&lt;/li&gt;
&lt;li&gt;第二步：把form表的enctype设置为：“multipart/form-data”&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;form action=&amp;quot;${pageContext.request.contextPath}/uploadAction_execute.action&amp;quot; enctype=&amp;quot;multipart/form-data&amp;quot; method=&amp;quot;post&amp;quot;&amp;gt;
    文件：&amp;lt;input type=&amp;quot;file&amp;quot; name=&amp;quot;image&amp;quot;&amp;gt;
&amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;上传&amp;quot;&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;第三步：在Action类中添加以下属性&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;public class UploadAction {
  private File image;// 文件名称
  // 如果想得到上传文件的名称,则定义文件名. 格式：文件名称+FileName
  private String imageFileName;// 得到上传文件名称
  // 如果想得到文件的类型,则定义文件名. 格式：文件名称+ContextType
  private String imageContextType;
  public String getImageFileName() {
    return imageFileName;
  }
  public void setImageFileName(String imageFileName) {
    this.imageFileName = imageFileName;
  }
  // 提供与字段名称相符的get、set属性,以便得到上传的文件
  public File getImage() {
    return image;
  }
  public void setImage(File image) {
    this.image = image;
  }
  public String execute() throws Exception {
    // 在该方法下进行保存
    String realPath = ServletActionContext.getServletContext().getRealPath(
        &amp;quot;/images&amp;quot;);// 得到根目录
    System.out.println(&amp;quot;*****&amp;quot; + realPath + &amp;quot;****&amp;quot;);
    if (image != null) {
      File savefile = new File(new File(realPath), imageFileName);// 保存到...
      if (!savefile.getParentFile().exists())
        savefile.getParentFile().mkdirs();
      FileUtils.copyFile(image, savefile);// 调用commons-io.jar下的工具类Copy文件到指定位置
      ActionContext.getContext().put(&amp;quot;message&amp;quot;, &amp;quot;上传成功&amp;quot;);// 返回信息
    }
    return &amp;quot;success&amp;quot;;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;./13.png&#34; alt=&#34;png&#34;&gt;
&lt;img src=&#34;./14.png&#34; alt=&#34;png&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;122多文件上传&#34;&gt;12.2、多文件上传&lt;/h3&gt;
&lt;p&gt;　　只需要将单文件上传的第三步：在Action类中添加以下属性中把单个文件变成数组.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class moreUploadAction {
  private File[] image;// 文件名称
  // 如果想得到上传文件的名称,则定义文件名. 格式：文件名称+FileName
  private String[] imageFileName;// 得到上传文件名称
  // 如果想得到文件的类型,则定义文件名. 格式：文件名称+ContextType
  private String[] imageContextType;
  public File[] getImage() {
    return image;
  }
  public void setImage(File[] image) {
    this.image = image;
  }
  public String[] getImageFileName() {
    return imageFileName;
  }
  public void setImageFileName(String[] imageFileName) {
    this.imageFileName = imageFileName;
  }
  public String[] getImageContextType() {
    return imageContextType;
  }
  public void setImageContextType(String[] imageContextType) {
    this.imageContextType = imageContextType;
  }
  public String execute() throws Exception {
    // 在该方法下进行保存
    String realPath = ServletActionContext.getServletContext().getRealPath(
        &amp;quot;/images&amp;quot;);// 得到根目录
    System.out.println(&amp;quot;*****&amp;quot; + realPath + &amp;quot;****&amp;quot;);
    if (image != null) {
      File savedir = new File(realPath);
      if (!savedir.exists())
        savedir.mkdirs();
      for (int i = 0; i &amp;lt; image.length; i++) {
        File savefile = new File(savedir, imageFileName[i]);// 保存到...
        FileUtils.copyFile(image[i], savefile);// 调用commons-io.jar下的工具类Copy文件到指定位置
      }
  ActionContext.getContext().put(&amp;quot;message&amp;quot;, &amp;quot;上传成功&amp;quot;);// 返回信息
    }
    return &amp;quot;success&amp;quot;;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;13自定义拦截器&#34;&gt;13、自定义拦截器&lt;/h2&gt;
&lt;p&gt;需求：对于登陆的用户可以访问Action中的所有方法,而没有登录的用户则不可以访问任何方法.&lt;/p&gt;
&lt;p&gt;方法：添加自定义拦截器. 实现&lt;code&gt;com.opensymphony.xwork2.interceptor.interceptor&lt;/code&gt;接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
public String intercept(ActionInvocation arg0) throws Exception {
  // 当拦截到Action时执行该方法
  // 得到session中存在的对象
  Object user = ActionContext.getContext()
.getSession().get(&amp;quot;user&amp;quot;);
  // 如果希望被拦截的的方法执行,调用arg0.invoke();
  if (user != null)
    return arg0.invoke();//如果User不为null,代表合法用户,允许访问方法
  // 返回的是Action中对应方法的返回值String
  ActionContext.getContext().put(&amp;quot;message&amp;quot;, &amp;quot;请先登录&amp;quot;);
  return &amp;quot;success&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在struts.xml中定义拦截器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 定义拦截器 --&amp;gt;
&amp;lt;interceptors&amp;gt;
  &amp;lt;!-- 自定义拦截器 --&amp;gt;
  &amp;lt;interceptor name=&amp;quot;permission&amp;quot; class=&amp;quot;com.haibao.interceptor.PermissionInterceptor&amp;quot; /&amp;gt;
  &amp;lt;!-- 定义拦截器栈  目的：使得Struts2自带的拦截器有效 --&amp;gt;
  &amp;lt;interceptor-stack name=&amp;quot;permissionStack&amp;quot;&amp;gt;
    &amp;lt;interceptor-ref name=&amp;quot;defaultStack&amp;quot;/&amp;gt;
    &amp;lt;interceptor-ref name=&amp;quot;permission&amp;quot;/&amp;gt;
  &amp;lt;/interceptor-stack&amp;gt;
&amp;lt;/interceptors&amp;gt;
&amp;lt;action name=&amp;quot;loginAction_*&amp;quot; class=&amp;quot;com.haibao.action.LoginAction&amp;quot;	method=&amp;quot;{1}&amp;quot;&amp;gt;
&amp;lt;result name=&amp;quot;success&amp;quot;&amp;gt;/WEB-INF/page/LoginPage.jsp&amp;lt;/result&amp;gt;
&amp;lt;interceptor-ref name=&amp;quot;permissionStack&amp;quot;/&amp;gt;
&amp;lt;/action&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：
如果直接在action中定义使用拦截器,则不会在使用Struts自带拦截器！这样Struts2的优势就没有了，所以引入拦截器栈的概念，在拦截器栈中要把Struts的拦截器写在前面，以保证web项目会首先执行Struts再带的拦截器.
如果想所有的程序都是用自定义的拦截器，可以使用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;default-interceptor-ref name=&amp;quot;permissionStack&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;效果演示：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;直接访问会被拦截：
&lt;img src=&#34;./15.png&#34; alt=&#34;png&#34;&gt;
登录后访问
&lt;img src=&#34;./16.png&#34; alt=&#34;png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;14输入校验&#34;&gt;14、输入校验&lt;/h2&gt;
&lt;p&gt;　　Struts2中可以实现对action的所有方法进行校验或者对action的指定方法进项校验，实现方法有两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;采用手工编写代码实现&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;对所有方法进行校验
　　重写validate()方法实现，validate()方法会校验action中所有的与execute方法签名相同的方法. 当某个数据校验失败时，调用addFieldError()方法往系统的fieldErrors添加校验失败信息，（为了使用addFieldError()方法，action可以继承ActionSupport），如果系统的fieldError包含失败信息，struts2会将请求转发到名为input的result. 在input视图中可以通过&amp;lt;s:fielderror/&amp;gt;显示失败信息. 需要引入标签&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%@ taglab url=&amp;quot;/struts-tags&amp;quot; prefix=&amp;quot;s&amp;quot;%&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public void validate(){
  if(this.mobile==null||&amp;quot;&amp;quot;.equals(this.mobile.trim())){
    this.addFieldError(&amp;quot;username&amp;quot;,&amp;quot;用户名不能为空&amp;quot;);
  }
  if(this.mobile==null||&amp;quot;&amp;quot;.equals(this.mobile.trim())){
    this.addFieldError(&amp;quot;mobile&amp;quot;,&amp;quot;手机号不能为空&amp;quot;);
  }else{
      if(!Pattern.compile(&amp;quot;^1[358]\\d{9}&amp;quot;).matcher(this.mobile.trim()).matches()){
      this.addFieldError(&amp;quot;mobile&amp;quot;,&amp;quot;手机号格式不正确&amp;quot;);
    }
  }		
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;对指定方法进行校验&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　重写validateXxx()方法实现，validate()方法会校验action中所有的与execute方法签名相同的方法. 当某个数据校验失败时，调用addFieldError()方法往系统的fieldErrors添加校验失败信息，（为了使用addFieldError()方法，action可以继承ActionSupport），如果系统的fieldError包含失败信息，struts2会将请求转发到名为input的result. 在input视图中可以通过&amp;lt;s:fielderror/&amp;gt;显示失败信息. 需要引入标签&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%@ taglab url=&amp;quot;/struts-tags&amp;quot; prefix=&amp;quot;s&amp;quot;%&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public void validateUpdata(){
  if(this.mobile==null||&amp;quot;&amp;quot;.equals(this.mobile.trim())){
    this.addFieldError(&amp;quot;username&amp;quot;,&amp;quot;用户名不能为空&amp;quot;);
  }
  if(this.mobile==null||&amp;quot;&amp;quot;.equals(this.mobile.trim())){
    this.addFieldError(&amp;quot;mobile&amp;quot;,&amp;quot;手机号不能为空&amp;quot;);
  }else{
      if(!Patten.compile(&amp;quot;^1[358]\\d{9}&amp;quot;).matcher(this.mobile.trim()).matches()){
      this.addFieldError(&amp;quot;mobile&amp;quot;,&amp;quot;手机号格式不正确&amp;quot;);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;输入校验的流程
&lt;ul&gt;
&lt;li&gt;类型转换器队请求参数执行类型转换，并把转换后的赋值给action中的属性.&lt;/li&gt;
&lt;li&gt;如果在执行类型转换的过程中出现异常，系统会将异常信息保存到ActionContext，conversionError拦截器将异常信息封装到fieldErrors里. 不管类型转换是否出现异常，都会进入第3步.&lt;/li&gt;
&lt;li&gt;系统通过反射技术先调用action中的validateXxx()方法，Xxx为方法名.&lt;/li&gt;
&lt;li&gt;在调用action中的validate()方法.&lt;/li&gt;
&lt;li&gt;经过上面4步，如果系统中的fieldErrors存在错误信息（即存放错误信息的集合的size&amp;gt;0），系统自动将请求转发至名称为input视图. 如果系统中的fieldErrors没有任何错误信息，系统将执行action中的处理方法.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;基于XML配置方式实现&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;　　&lt;b&gt;a) 对所有方法进行校验&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;　　在Action相同包下创建ActionClassName-validation.xml文件.
&lt;img src=&#34;./17.png&#34; alt=&#34;png&#34;&gt;
Struts2 的验证规则大概有以下数种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;required:必填校验器，要求field的值不能为null&lt;/li&gt;
&lt;li&gt;requiredstring:必填字符串校验器，要求field的值不能为null,并且长度大于0，默  认情况下会对字符串去掉前后空格&lt;/li&gt;
&lt;li&gt;int:整数校验器，要求field的值必须在整数范围内，min指定最小值，max指定最大值&lt;/li&gt;
&lt;li&gt;double:双精度浮点数校验器&lt;/li&gt;
&lt;li&gt;date:日期校验器&lt;/li&gt;
&lt;li&gt;expression:表达式校验器&lt;/li&gt;
&lt;li&gt;fieldexpression:字段表达式校验器&lt;/li&gt;
&lt;li&gt;email:电子邮件校验器，要求如果field的值非空，则必须是合法的邮件地址&lt;/li&gt;
&lt;li&gt;url:网址校验器，要求如果field的值非空，则必须是合法的url地址&lt;/li&gt;
&lt;li&gt;visitor:Visitor校验器，用于校验action的复合属性，它指定一个校验文件用于校验复合属性中的属性&lt;/li&gt;
&lt;li&gt;conversion:转换校验器&lt;/li&gt;
&lt;li&gt;stringlength:字符串长度校验器&lt;/li&gt;
&lt;li&gt;regex:正则表达式校验器&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;常用的验证规则&#34;&gt;常用的验证规则：&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;必填检验&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;validators&amp;gt;
&amp;lt;field name=&amp;quot;username&amp;quot;&amp;gt;
&amp;lt;field-validator type=&amp;quot;required&amp;quot;&amp;gt;
&amp;lt;message&amp;gt;指定检验失败的提示信息&amp;lt;/message&amp;gt;
&amp;lt;/field-validator&amp;gt;
&amp;lt;/field&amp;gt;
&amp;lt;/validators&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;必填字符串检验&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;validators&amp;gt;
&amp;lt;field name=&amp;quot;username&amp;quot;&amp;gt;
&amp;lt;field-validator type=&amp;quot;requiredstring&amp;quot;&amp;gt;
&amp;lt;param name=&amp;quot;trim&amp;quot;&amp;gt;true&amp;lt;/param&amp;gt;
&amp;lt;message&amp;gt;指定检验失败的提示信息&amp;lt;/message&amp;gt;
&amp;lt;/field-validator&amp;gt;
&amp;lt;/field&amp;gt;
&amp;lt;/validators&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;整数检验器/浮点检验&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;validators&amp;gt;
&amp;lt;field name=&amp;quot;age&amp;quot;&amp;gt;
&amp;lt;field-validator type=&amp;quot;int&amp;quot;&amp;gt;
&amp;lt;param name=&amp;quot;min&amp;quot;&amp;gt;1&amp;lt;/param&amp;gt;
&amp;lt;param name=&amp;quot;max&amp;quot;&amp;gt;150&amp;lt;/param&amp;gt;
&amp;lt;message&amp;gt;年纪必须在1到150之间&amp;lt;/message&amp;gt;
&amp;lt;/field-validator&amp;gt;
&amp;lt;/field&amp;gt;
&amp;lt;/validators&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;日期检验&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;validators&amp;gt;
&amp;lt;field name=&amp;quot;birth&amp;quot;&amp;gt;
&amp;lt;field-validator type=&amp;quot;date&amp;quot;&amp;gt;
&amp;lt;param name=&amp;quot;min&amp;quot;&amp;gt;1900-01-01&amp;lt;/param&amp;gt;
&amp;lt;param name=&amp;quot;max&amp;quot;&amp;gt;2050-02-21&amp;lt;/param&amp;gt;
&amp;lt;message key=&amp;quot;birth.range&amp;quot;/&amp;gt;
&amp;lt;/field-validator&amp;gt;
&amp;lt;/field&amp;gt;
&amp;lt;/validators&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;字段表达式检验器(要求指定字段满足一个逻辑表达式)&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;validators&amp;gt;
&amp;lt;field name=&amp;quot;re_pass&amp;quot;&amp;gt;
&amp;lt;field-validator type=&amp;quot;fieldexpression&amp;quot;&amp;gt;
&amp;lt;!--指定逻辑表达式 --&amp;gt;
&amp;lt;param name=&amp;quot;expression&amp;quot;&amp;gt; (pass eq re_pass)&amp;lt;/param&amp;gt;
&amp;lt;message&amp;gt;密码必须和确认密码相等&amp;lt;/message&amp;gt;
&amp;lt;/field-validator&amp;gt;
&amp;lt;/field&amp;gt;
&amp;lt;/validators&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;邮件地址校验&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;validators&amp;gt;
&amp;lt;field name=&amp;quot;email&amp;quot;&amp;gt;
&amp;lt;field-validator type=&amp;quot;email&amp;quot;&amp;gt;
&amp;lt;message&amp;gt;你的电子邮件地址必须是一个有效的电邮地址&amp;lt;/message&amp;gt;
&amp;lt;/field-validator&amp;gt;
&amp;lt;/field&amp;gt;
&amp;lt;/validators&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;网址检验&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;validators&amp;gt;
&amp;lt;field name=&amp;quot;url&amp;quot;&amp;gt;
&amp;lt;field-validator type=&amp;quot;url&amp;quot;&amp;gt;
&amp;lt;message&amp;gt;你的主页地址必须是一个有效的网址&amp;lt;/message&amp;gt;
&amp;lt;/field-validator&amp;gt;
&amp;lt;/field&amp;gt;
&amp;lt;/validators&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;8&#34;&gt;
&lt;li&gt;字符串长度检验&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;validators&amp;gt;
&amp;lt;field name=&amp;quot;user&amp;quot;&amp;gt;
&amp;lt;field-validator type=&amp;quot;stringlength&amp;quot;&amp;gt;
&amp;lt;param name=&amp;quot;minlength&amp;quot;&amp;gt;4&amp;lt;/param&amp;gt;
&amp;lt;param name=&amp;quot;maxlength&amp;quot;&amp;gt;20&amp;lt;/param&amp;gt;
&amp;lt;message&amp;gt;你的用户名长度必须在4到20之间&amp;lt;/message&amp;gt;
&amp;lt;/field-validator&amp;gt;
&amp;lt;/field&amp;gt;
&amp;lt;/validators&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;9&#34;&gt;
&lt;li&gt;正则表达式检验&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;validators&amp;gt;
&amp;lt;field name=&amp;quot;user&amp;quot;&amp;gt;
&amp;lt;field-validator type=&amp;quot;regex&amp;quot;&amp;gt;
&amp;lt;param name=&amp;quot;regex&amp;quot;&amp;gt;&amp;lt;![CDATA[(\w{4,25})]]&amp;gt;&amp;lt;/param&amp;gt;
&amp;lt;message&amp;gt;您输入的用户名只能是字母和数组，且长度必须在4到25之间&amp;lt;/message&amp;gt;
&amp;lt;/field-validator&amp;gt;
&amp;lt;/field&amp;gt;
&amp;lt;/validators
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;　　&lt;b&gt;b) 对指定方法进行校验&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;　　取名更改为ActionClassName-ActionName-validation.xml&lt;/p&gt;
&lt;p&gt;&lt;b&gt;注意&lt;/b&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当action同时提供了两个校验方法，则按照“所有方法”，“指定方法”的顺序汇总后执行；如果后面的文件包含前面文件的方法发生冲突，则只是用后面文件中的校验规则.&lt;/li&gt;
&lt;li&gt;当action继承了另外一个action，父类action的校验文件会先被搜索到.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;15国际化&#34;&gt;15、国际化&lt;/h2&gt;
&lt;p&gt;准备资源文件，资源文件的命名格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;baseName_language_country.propeties
baseName_language.propeties
baseName.propeties
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中baseName是资源文件的基本名，可以自定义，但language和country必须是java支持的语言和国家.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;中国：baseName_zh_CN.properties&lt;/li&gt;
&lt;li&gt;美国：baseName_en_US.properties&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果没有使用开发工具，对于中文的属性文件，应该使用JDK提供的native2ascii命令把文件转换为Unicode编码的文件. 命令使用如下：
native2ascii 源文件.properties 目标文件.properties&lt;/p&gt;
&lt;h3 id=&#34;151配置全局资源与输出国际化信息&#34;&gt;15.1、配置全局资源与输出国际化信息&lt;/h3&gt;
&lt;p&gt;当准备好资源文件之后，可以在struts.xml中通过struts.custom.i18n.resources常量把资源文件定义为全局变量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;constant name=&amp;quot;struts.custom.i18n.resources&amp;quot; value=&amp;quot;baseName&amp;quot;/ &amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中baseName为资源的基本名.
之后就可以在页面或者action中访问国际化信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在JSP页面中使用&lt;code&gt;&amp;lt;s:text name=&amp;quot;&amp;quot;/&amp;gt;&lt;/code&gt;标签输出国际化信息；&lt;code&gt;&amp;lt;s:text name=&amp;quot;user&amp;quot;/&amp;gt;&lt;/code&gt;,name为资源文件中的Key.&lt;/li&gt;
&lt;li&gt;在Action类中，可以继承ActionSupport，使用getText()方法得到国际化信息，该方法的第一个参数用于指定资源文件中的Key.&lt;/li&gt;
&lt;li&gt;在表单标签中，通过Key属性指定资源文件中的Key，如：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;s:textfield name=&amp;quot;realname&amp;quot; key=&amp;quot;use&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;输出带占位符的国际化信息&#34;&gt;输出带占位符的国际化信息&lt;/h4&gt;
&lt;p&gt;资源文件中的内容如下：
welcome={0},你好{1}&lt;/p&gt;
&lt;h3 id=&#34;152jsp页面中输出占位符的国际化信息&#34;&gt;15.2、JSP页面中输出占位符的国际化信息&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;s:text name=&amp;quot;welcome&amp;quot;&amp;gt;
  &amp;lt;s:param&amp;gt;熊大&amp;lt;/s:param&amp;gt;
  &amp;lt;s:param&amp;gt;学习&amp;lt;/s:param&amp;gt;
&amp;lt;s:text/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;　　在Action类中获取带占位符的国际化信息，可以使用getText(String Key，String[] args)或者getText(String Key，List args)方法&lt;/p&gt;
&lt;h3 id=&#34;153包范围资源文件&#34;&gt;15.3、包范围资源文件&lt;/h3&gt;
&lt;p&gt;　　在一个大型应用中，整个应用有大量的内容需要实现国际化，如果把国际化的内容放置在全局资源属性文件中，显然会导致资源文件变的庞大、臃肿、不便于维护，支个时候可以针对不同末班，使用包范围来组织国际化文件.&lt;/p&gt;
&lt;p&gt;方法：在java的包下放置package_language_country.properties资源文件，package为固定写法，处于该包及子包下的action都可以访问该资源，当查到指定Key的消息时，系统会先从package资源文件查找，当不存在对应的Key时，才会从常量struts.custom.i18n.resources指定的资源文件中寻找.&lt;/p&gt;
&lt;h3 id=&#34;154action范围资源文件&#34;&gt;15.4、Action范围资源文件&lt;/h3&gt;
&lt;p&gt;　　在Action类所在的路径，放置ActionClassName_languaage_country.properties资源文件，ActionClassName为action类的简单名称；当指定key的消息时，系统会先从ActionClassName_languaage_country.properties资源文件中查找.&lt;/p&gt;
&lt;h3 id=&#34;155jsp中直接访问某个资源文件&#34;&gt;15.5、JSP中直接访问某个资源文件&lt;/h3&gt;
&lt;p&gt;struts2提供了&amp;lt;s:i18n&amp;gt;标签，使用&amp;lt;s:i18n&amp;gt;标签可以在类路径下直接从某个资源文件中获取国际化数据，无需任何配置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;s:i18n name=&amp;quot;realname&amp;quot;&amp;gt;
  &amp;lt;s:text name=&amp;quot;realname&amp;quot;/&amp;gt;
&amp;lt;s:i18n&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;realname为要访问的资源文件的基本名&lt;/p&gt;
&lt;p&gt;如果要访问的资源文件在类路径的某个包下，可以访问：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;s:i18n name=&amp;quot;com/haibao/action/package&amp;quot;&amp;gt;
  &amp;lt;s:text name=&amp;quot;realname&amp;quot;&amp;gt;
    &amp;lt;s:param&amp;gt;熊大&amp;lt;/s:param&amp;gt;
  &amp;lt;/s:text/&amp;gt;
&amp;lt;s:i18n&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面访问com.haibao.action包下基本名为&lt;font color=red&gt;package&lt;/font&gt;的资源文件.&lt;/p&gt;
&lt;h2 id=&#34;16ognl表达式语言&#34;&gt;16、OGNL表达式语言&lt;/h2&gt;
&lt;p&gt;　　OGNL是Object Graphic Navigation Language（对象图导航语言）的缩写，是一个开源的项目. Struts2框架采用OGNL作为默认的表达式语言.&lt;/p&gt;
&lt;p&gt;相对于EL表达式，OGNL提供了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持对象方法调用：如xxx.sayHello()；&lt;/li&gt;
&lt;li&gt;支持类静态方法调用和值访问，表达式的格式为@[类全名（包括路径）]@[方法名|值名]
例如：&lt;code&gt;@java.lang.String@format(&#39;foo %s&#39;，bar)&lt;/code&gt;
或者 &lt;code&gt;@com.haibao.Constant@APP_NAME&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;操作集合对象.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　Ognl有一个上下文（Context）概念，它实现了了java.utils.Map接口，Struts2中说明：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;上下文（Context）的实现为ActionContext. 当Struts2接受一个请求时，会迅速创建ActionContext，ValueStack，action. 然后把action存进ValueStack，所以action的实例变量可以被OGNL访问.&lt;/li&gt;
&lt;li&gt;访问上下文（Context）中的对象需要使用#符号标注命名空间. 如&lt;code&gt;#application、#session&lt;/code&gt;. 如：&lt;code&gt;#application[&#39;userName&#39;]==#application.userName//获得application中userName值. &lt;/code&gt;
（#session对象、#request对象、#paramete对象、attr对象—按照page—request—session—application顺序访问其属性）.&lt;/li&gt;
&lt;li&gt;OGNL设定了一个跟对象（root）对象，在Struts2中根对象就是ValueStack（值栈）. 如果访问根对象中的属性，则可以省略#命名空间，直接访问该对象的属性即可. 如：${foo}//获得栈值中某个对象的foo属性.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意：Struts2中，OGNL表达式需要配合Struts标签使用. 如：&lt;code&gt;&amp;lt;s:property value=&amp;quot;name&amp;quot;&amp;gt;&lt;/code&gt;；使用EL表达式能够访问valueStack中对象的属性，原因是：Struts2对HTTPServletRequest作了进一步的封装.&lt;/p&gt;
&lt;h2 id=&#34;17采用ognl表达式创建listmap集合对象&#34;&gt;17、采用OGNL表达式创建List/Map集合对象&lt;/h2&gt;
&lt;h3 id=&#34;171试用如下直接生成一个list对象&#34;&gt;17.1、试用如下直接生成一个List对象：&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;s:set name=&amp;quot;list&amp;quot; value=&amp;quot;{&#39;zhangsan&#39;,&#39;lisi&#39;,&#39;wangwu&#39;}&amp;quot;/&amp;gt;
&amp;lt;s:iterator value=&amp;quot;#list&amp;quot;&amp;gt;&amp;lt;!-- 迭代器 --&amp;gt;
	&amp;lt;s:property/&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;/s:iterator&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;./18.png&#34; alt=&#34;png&#34;&gt;
　　Set标签用于将某个值放入指定范围&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;scope：指定变量被放置的范围，该属性可以接受application、session、request、page或action. 如果没有设置该属性，则默认放置在OGNL Context中.&lt;/li&gt;
&lt;li&gt;value：赋给变量的值，如果没有设置该属性，则将ValueStack栈顶的值赋值给变量.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;生成一个Map对象：(Key&amp;ndash;Value)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;s:set name=&amp;quot;foobar&amp;quot; value=&amp;quot;#{&#39;k1&#39;: &#39;value1&#39;,&#39;k2&#39;:&#39;value2&#39;}&amp;quot;/&amp;gt;
&amp;lt;s:iterator value=&amp;quot;# foobar &amp;quot;&amp;gt;&amp;lt;!-- 迭代器 --&amp;gt;
  &amp;lt;s:property value=&amp;quot;key&amp;quot;/&amp;gt;=&amp;lt;s:property value=&amp;quot;value&amp;quot;/&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;/s:iterator&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;java 迭代方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for(Map.Entry&amp;lt;String,Integer&amp;gt;entry:maps.entrySet){
  System.out.println(entry.getKey()+&amp;quot;=&amp;quot;+entry.getValue());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;18采用ognl表达式判断对象是否存在于集合中&#34;&gt;18、采用OGNL表达式判断对象是否存在于集合中&lt;/h2&gt;
&lt;p&gt;使用in和not in
in表达式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;s:if test=&amp;quot;foor&amp;quot; in {&#39;foo&#39;, &#39;bar&#39;}&amp;gt;
在
&amp;lt;/s:if&amp;gt;
&amp;lt;s:else&amp;gt;
  不在
&amp;lt;/s:else&amp;gt;
not in 表达式
&amp;lt;s:if test=&amp;quot;foor&amp;quot; not in {&#39;foo&#39;,&#39;bar&#39;}&amp;gt;
  不在
&amp;lt;/s:if&amp;gt;
&amp;lt;s:else&amp;gt;
  在
&amp;lt;/s:else&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;附加：
除了in和not in之外OGNL还允许使用某个规则获得集合对象的子集&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;?:获得所有符合逻辑的元素.&lt;/li&gt;
&lt;li&gt;^:获得符合逻辑的第一个元素.&lt;/li&gt;
&lt;li&gt;$:获得符合逻辑的最后一个元素.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;s:iterator value=&amp;quot;books.{?#this.price}35}&amp;quot;	/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;19常用标签&#34;&gt;19、常用标签&lt;/h2&gt;
&lt;h3 id=&#34;191propert标签&#34;&gt;19.1、propert标签：&lt;/h3&gt;
&lt;p&gt;用于输出指定值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;s:set name=&amp;quot;name&amp;quot; value=&amp;quot;kk&amp;quot;/&amp;gt;
&amp;lt;s:property value=&amp;quot;#name&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;default:可选属性，如果需要输出指定的属性值为null，则显示该属性指定的值.&lt;/li&gt;
&lt;li&gt;value：可选属性，指定需要输出的属性值，如果没有指定该属性，则默认输出ValueStack栈顶的值.&lt;/li&gt;
&lt;li&gt;escape：可选属性，指定是否格式化HTML代码.&lt;/li&gt;
&lt;li&gt;id：可选属性，指定还元素的标识.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;192iterator标签&#34;&gt;19.2、iterator标签&lt;/h3&gt;
&lt;p&gt;iterator标签用于对集合进行迭代，治理的集合包含List、Set和数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;s:set name=&amp;quot;list&amp;quot; value=&amp;quot;{&#39;foo&#39;,&#39;bar&#39;}&amp;quot;/&amp;gt;
&amp;lt;s:iterator value=&amp;quot;#list&amp;quot; status=&amp;quot;st&amp;quot;&amp;gt;
&amp;lt;s:color=&amp;lt;s:if test=&amp;quot;#st.odd&amp;quot;&amp;gt;red&amp;lt;/s:if&amp;gt;&amp;lt;s:else&amp;gt;blue&amp;lt;/s:else&amp;gt;&amp;gt;
  &amp;lt;s:property/&amp;gt;&amp;lt;/font&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;/s:iterator&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;value:可选属性，指定被迭代的集合，如果没有设置该属性，则使用ValueStack栈顶的集合&lt;/li&gt;
&lt;li&gt;id:可选属性，指定即合理元素的id. （过时）&lt;/li&gt;
&lt;li&gt;status：该属性指定迭代时的IteratorStatus实例. 该实例包含以下几个方法：
&lt;ul&gt;
&lt;li&gt;int getCount()，返回当前迭代了几个元素&lt;/li&gt;
&lt;li&gt;int getIndex()，返回当前迭代元素的索引&lt;/li&gt;
&lt;li&gt;boolean isEven()，返回当前被迭代元素的索引是否为偶数&lt;/li&gt;
&lt;li&gt;boolean isOdd()，返回当前被迭代元素的索引是否为奇数&lt;/li&gt;
&lt;li&gt;boolean isFirst()，返回当前被迭代元素的索引是否是第一个元素&lt;/li&gt;
&lt;li&gt;boolean isLast()，返回当前被迭代元素的索引是否最后一个元素&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;193url标签&#34;&gt;19.3、url标签&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;s:url value=&amp;quot;hellowoeld_add&amp;quot; namespace=&amp;quot;/test&amp;quot;&amp;gt;&amp;lt;s:param name=&amp;quot;person&amp;quot; value=&amp;quot;23&amp;quot;/&amp;gt;&amp;lt;/s:url&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生成类似如下路径：
/&lt;font color=red&gt;struts&lt;/font&gt;/test/helloworld_add&lt;font color=red&gt;.adtion&lt;/font&gt;?persom=23
红色部分为内容路径&lt;/p&gt;
&lt;p&gt;当标签的属性作为字符串类型处理时，“%”符号的用途试计算OGNL表达式的值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;s:set value=&amp;quot;myurl&amp;quot; value=&#39;&amp;quot;http://www.sohu.com&amp;quot;&#39;/&amp;gt;
&amp;lt;s:url value=&amp;quot;myurl&amp;quot;/&amp;gt;&amp;lt;/br&amp;gt;
&amp;lt;s:url value=&amp;quot;%{#myurl}&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# myurl
http://www.sohu.com
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;194表单标签checkboxlist复选框&#34;&gt;19.4、表单标签：checkboxlist复选框&lt;/h3&gt;
&lt;p&gt;如果集合为list&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;s:checkboxlist name=&amp;quot;list&amp;quot; list=&amp;quot;{&#39;Java&#39;,&#39;.Net&#39;,&#39;Ror&#39;,&#39;PHP&#39;}&amp;quot; value=&amp;quot;{&#39;Java&#39;,&#39;.Net&#39;}&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生成如下html代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&amp;quot;checkbox&amp;quot; name=&amp;quot;list&amp;quot; value=&amp;quot;Java&amp;quot; checked=&amp;quot;checked&amp;quot;/&amp;gt;&amp;lt;lable&amp;gt;Java&amp;lt;/lable&amp;gt;
&amp;lt;input type=&amp;quot;checkbox&amp;quot; name=&amp;quot;list&amp;quot; value=&amp;quot;.Net&amp;quot; checked=&amp;quot;checked&amp;quot;/&amp;gt;&amp;lt;lable&amp;gt;.Net&amp;lt;/lable&amp;gt;
&amp;lt;input type=&amp;quot;checkbox&amp;quot; name=&amp;quot;list&amp;quot; value=&amp;quot; Ror&amp;quot;/&amp;gt;&amp;lt;lable&amp;gt;Ror&amp;lt;/lable&amp;gt;
&amp;lt;input type=&amp;quot;checkbox&amp;quot; name=&amp;quot;list&amp;quot; value=&amp;quot; PHP&amp;quot;/&amp;gt;&amp;lt;lable&amp;gt;PHP&amp;lt;/lable&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果集合为Map&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;s:checkboxlist name=&amp;quot;map&amp;quot; list=&amp;quot;#{1:&#39;Java&#39;,2:&#39;.Net&#39;,3:&#39;Ror&#39;,4:&#39;PHP&#39;}&amp;quot; listKey=&amp;quot;key&amp;quot; listValue=&amp;quot;value&amp;quot; value=&amp;quot;{1,2,3}&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生成如下html代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&amp;quot;checkbox&amp;quot; name=&amp;quot;map&amp;quot; value=&amp;quot;1&amp;quot; checked=&amp;quot;checked&amp;quot;/&amp;gt;&amp;lt;lable&amp;gt;Java&amp;lt;/lable&amp;gt;
&amp;lt;input type=&amp;quot;checkbox&amp;quot; name=&amp;quot;map&amp;quot; value=&amp;quot;2&amp;quot; checked=&amp;quot;checked&amp;quot;/&amp;gt;&amp;lt;lable&amp;gt;.Net&amp;lt;/lable&amp;gt;
&amp;lt;input type=&amp;quot;checkbox&amp;quot; name=&amp;quot;map&amp;quot; value=&amp;quot;3&amp;quot; checked=&amp;quot;checked&amp;quot;/&amp;gt;&amp;lt;lable&amp;gt;Ror&amp;lt;/lable&amp;gt;
&amp;lt;input type=&amp;quot;checkbox&amp;quot; name=&amp;quot;map&amp;quot; value=&amp;quot;4&amp;quot;/&amp;gt;&amp;lt;lable&amp;gt;PHP&amp;lt;/lable&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果集合里存放的是javabean&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%
  Person p1 = new Person(1,&amp;quot;第一个&amp;quot;);
  Person p1 = new Person(2,&amp;quot;第一个&amp;quot;);
  List&amp;lt;Person&amp;gt; list = new ArrayList&amp;lt;Person&amp;gt;();
  list.add(p1);
  list.add(p2);
  request.setAttribute(&amp;quot;person&amp;quot;, list);
%&amp;gt;
&amp;lt;s:checkboxlist list=&amp;quot;#request.persons&amp;quot; listKey=&amp;quot;personid&amp;quot; listValue=&amp;quot;name&amp;quot;&amp;gt;&amp;lt;/s:checkboxlist&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;personid和name为Person的属性
生成如下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&amp;quot;checkbox&amp;quot; name=&amp;quot;beans&amp;quot; value=&amp;quot;1&amp;quot;/&amp;gt;&amp;lt;lable&amp;gt;第一个&amp;lt;/lable&amp;gt;
&amp;lt;input type=&amp;quot;checkbox&amp;quot; name=&amp;quot;beans&amp;quot; value=&amp;quot;2&amp;quot;/&amp;gt;&amp;lt;lable&amp;gt;第二个&amp;lt;/lable&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;195表单标签radio单选框&#34;&gt;19.5、表单标签：radio单选框&lt;/h3&gt;
&lt;p&gt;如果集合为list&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;s:radio name=&amp;quot;list&amp;quot; list=&amp;quot;{&#39;Java&#39;,&#39;.Net&#39;,&#39;Ror&#39;,&#39;PHP&#39;}&amp;quot; value=&amp;quot;&#39;Java&#39;&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生成如下html代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&amp;quot;radio&amp;quot; name=&amp;quot;list&amp;quot; value=&amp;quot;Java&amp;quot; checked=&amp;quot;checked&amp;quot;/&amp;gt;&amp;lt;lable&amp;gt;Java&amp;lt;/lable&amp;gt;
&amp;lt;input type=&amp;quot;radio&amp;quot; name=&amp;quot;list&amp;quot; value=&amp;quot;.Net&amp;quot;/&amp;gt;
&amp;lt;input type=&amp;quot;radio&amp;quot; name=&amp;quot;list&amp;quot; value=&amp;quot;Ror&amp;quot;/&amp;gt;
&amp;lt;input type=&amp;quot;radio&amp;quot; name=&amp;quot;list&amp;quot; value=&amp;quot;PHP&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果集合为Map&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;s:radio name=&amp;quot;map&amp;quot; list=&amp;quot;#{1:&#39;Java&#39;,2:&#39;.Net&#39;3:,&#39;Ror&#39;,4:&#39;PHP&#39;}&amp;quot; 
listKey=&amp;quot;key&amp;quot; listValue=&amp;quot;value&amp;quot; value=&amp;quot;1&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生成如下html代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&amp;quot;radio&amp;quot; name=&amp;quot;map&amp;quot; value=&amp;quot;1&amp;quot; checked=&amp;quot;checked&amp;quot;/&amp;gt;&amp;lt;lable&amp;gt;Java&amp;lt;/lable&amp;gt;
&amp;lt;input type=&amp;quot;radio&amp;quot; name=&amp;quot;map&amp;quot; value=&amp;quot;2&amp;quot;/&amp;gt;&amp;lt;lable&amp;gt;.Net&amp;lt;/lable&amp;gt;
&amp;lt;input type=&amp;quot;radio&amp;quot; name=&amp;quot;map&amp;quot; value=&amp;quot;3&amp;quot;/&amp;gt;&amp;lt;lable&amp;gt;Ror&amp;lt;/lable&amp;gt;
&amp;lt;input type=&amp;quot;radio&amp;quot; name=&amp;quot;map&amp;quot; value=&amp;quot;4&amp;quot;/&amp;gt;&amp;lt;lable&amp;gt;PHP&amp;lt;/lable&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果集合里存放的是javabean&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%
  Person p1 = new Person(1,&amp;quot;第一个&amp;quot;);
  Person p1 = new Person(2,&amp;quot;第一个&amp;quot;);
  List&amp;lt;Person&amp;gt; list = new ArrayList&amp;lt;Person&amp;gt;();
  list.add(p1);
  list.add(p2);
  request.setAttribute(&amp;quot;person&amp;quot;, list);
%&amp;gt;
&amp;lt;s:radio name=&amp;quot;beans&amp;quot; list=&amp;quot;#request.persons&amp;quot; listKey=&amp;quot;personid&amp;quot; listValue=&amp;quot;name&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;personid和name为Person的属性
生成如下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&amp;quot;radio&amp;quot; name=&amp;quot;beans&amp;quot; value=&amp;quot;1&amp;quot;/&amp;gt;&amp;lt;lable&amp;gt;第一个&amp;lt;/lable&amp;gt;
&amp;lt;input type=&amp;quot;radio&amp;quot; name=&amp;quot;beans&amp;quot; value=&amp;quot;2&amp;quot;/&amp;gt;&amp;lt;lable&amp;gt;第二个&amp;lt;/lable&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;196表单标签select下拉选择框&#34;&gt;19.6、表单标签select下拉选择框&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;s:select name=&amp;quot;list&amp;quot; list=&amp;quot;{&#39;Java&#39;,&#39;.Net&#39;}&amp;quot; value=&amp;quot;&#39;Java&#39;&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生成如下html代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;s:select name=&amp;quot;list&amp;quot; id=&amp;quot;list&amp;quot;&amp;gt;
&amp;lt;option value=&amp;quot;Java&amp;quot; selected=&amp;quot;selected&amp;quot;&amp;gt;Java&amp;lt;option/&amp;gt;
&amp;lt;option value=&amp;quot;.Net&amp;quot;&amp;gt;.Net &amp;lt;option/&amp;gt;
&amp;lt;/select&amp;gt;
&amp;lt;s:select name=&amp;quot;map&amp;quot; list=&amp;quot;#{1:&#39;Java&#39;,2:&#39;.Net&#39;3:,&#39;Ror&#39;,4:&#39;PHP&#39;}&amp;quot; 
listKey=&amp;quot;key&amp;quot; listValue=&amp;quot;value&amp;quot; value=&amp;quot;1&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生成如下html代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;s:select name=&amp;quot;list&amp;quot; id=&amp;quot;list&amp;quot;&amp;gt;
&amp;lt;option value=&amp;quot;1&amp;quot; selected=&amp;quot;selected&amp;quot;&amp;gt;Java&amp;lt;option/&amp;gt;
&amp;lt;option value=&amp;quot;2&amp;quot;&amp;gt;.Net&amp;lt;option/&amp;gt;
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;20stoken标签放置重复提交&#34;&gt;20、&amp;lt;s:token/&amp;gt;标签放置重复提交&lt;/h2&gt;
&lt;p&gt;&amp;lt;s:token/&amp;gt;标签放置重复提交用法如下：
第一步：在表单中加入&amp;lt;s:token/&amp;gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;s:form action=&amp;quot;Action_execute()&amp;quot; method=&amp;quot;post&amp;quot; &amp;gt;
  姓名&amp;lt;s:textfield name=&amp;quot;name&amp;quot;/&amp;gt;&amp;lt;s:token/&amp;gt;
  &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;发送&amp;quot;/&amp;gt;
&amp;lt;/s:form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二步：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;action name=&amp;quot;Action_*&amp;quot; class=&amp;quot;com.haibao.action.XMLvalidate&amp;quot;
      method=&amp;quot;{1}&amp;quot;&amp;gt;
  &amp;lt;interceptor-ref name=&amp;quot;defaultStack&amp;quot;/&amp;gt;
  &amp;lt;interceptor-ref name=&amp;quot;token&amp;quot;/&amp;gt;
  &amp;lt;result name=&amp;quot;ivalid.token&amp;quot;&amp;gt;/message.jsp&amp;lt;/result&amp;gt;
  &amp;lt;result name=&amp;quot;success&amp;quot;&amp;gt;/WEB-INF/page/message.jsp&amp;lt;/result&amp;gt;
&amp;lt;/action&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上配置加入了“token”拦截器和“ivalid.token”结果，因为“token”拦截器在会话的token与请求的token不一致时，将会直接返回“ivalid.token”结果.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
